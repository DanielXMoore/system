{"source":{"NOTES.md":{"content":"Notes\n=====\n\n2021-07-10\n----------\n\nImplemented lazy loading of AWS libraries. This begins the exploration of more\nlazy loading for things like stylus, CoffeeScript and other compilers. This will\nkeep the system library small and ensure that people aren't forced to pay for\ncapabilities they don't use.\n\nIt should in theory be possible to lazy load without polluting the global\nnamespace but that is a serious scope creep for limited benefit. It may make\nsense for things like CoffeeScript or stylus compilers but for AWS I pray that\nwe'll never want two versions at once.\n\n2019-12-25\n----------\n\nMigrate `Model` into `system`. Explored using a single param `self` rather than\n`I`, `self`. Pro: single param include makes more sense than the dual param for\nstateless mixins like `Bindable`. Con: Having the state as a nested parameter of the\nobject is a little weird and makes calling in the normal case awkward. It also\nmakes re-hydrating from JSON or pojo more difficult than it needs to be.\n\nConclusion: keep the two param but expand `include` to handle single param\nfunctions by special casing `mixin.length === 1` to skip the `I` param.\n\n2019-10-26\n----------\n\nTesting on fs libs.\n\nRemoving dependencies on Model, using our Bindable. Avoiding implicit system\ndependencies.\n\nOrganize deps?\n\n```\nsystem.UI\nsystem.FS\nsystem.DB\n\nðŸ‘ðŸ‘ðŸ‘ðŸ‘ðŸ‘ðŸ‘ðŸ‘ðŸ‘ðŸ‘ðŸ‘\n```\n\n\n2019-10-20\n----------\n\nðŸŽ¶ _Ladytron - Destroy Everything You Touch_ ðŸŽ¶\n\nGoal: Consolidate FS into `lib/fs`\n\n- [ ] Mount\n- [ ] S3\n- [ ] IndexedDB\n- [ ] Package\n- [ ] Add tests!\n- [ ] Reduce / Clean up Deps\n- [ ] Expose Mountable Root FS\n\nGathering from `zine` and `briefcase`\n\n2019-10-18\n----------\n\nConsolidated styles into one file. \n\nGoal: get template and view previews working for system client in Prometheus.\n\nFor views adding require \"../setup\" creates a system client shim to work.\nThink about templates... Got it with one weird plugin trick!\n\n2019-09-21\n----------\n\nUpdated Jadelet2 with the Firefox fix\nRemoved Jadelet v1 support\nPulled in Observable (non-rewrite v0.4.0-pre)\n\n2019-09-11\n----------\n\nMoving in the new Jadelet parser and runtime. Plan to also move in othe package\ndependencies and make this more of a comprenhensive runtime lib for ZineOS. The\nplan is to also pull in Observable and Bindable, maybe even merge with system\nclient. We can always reconsider splitting out the UI stuff later, but having a\nfuller core lib makes sense, especially if it doesn't get too large.\n\n---\n\nWrapping simple promise returning handlers around the modal should make it easy\nto prompt.\n"},"README.md":{"content":"System\n======\n\nSystem is the framework and API layer for creating Whimsy.Space apps.\n\n- `app`\n  - `Base`\n- `aws`\n- `fs`\n  - `Dexie` IndexedDB\n  - `Package` Explore a package as a filesystem\n  - `Mount` A meta-file system where that mounts other systems as paths.\n  - `S3` AWS S3\n- `pkg` Utilities for loading, building, running packages.\n- [ui](#ui)\n  - `applyStyle(styleSource, name)` TODO: this should be automatic in most cases\n  - `Bindable` TODO: Not quite the right place?\n  - `ContextMenu`\n  - `Jadelet`\n  - `MenuBar`\n  - `Modal`\n  - `Observable`\n  - `Progress`\n  - `Window`\n- `util`\n  - `Postmaster`\n\n\n[Architecture](https://danielx.net/wiki/architecture.html)\n\nfs\n----------\n\nThe filesystem has common operations for listing, reading, writing, and deleting\nfiles. Both local and cloud backends are implemented. Different systems can be\nmounted at paths and have events translated cleanly. That's some of the magic \nthat powers `My Briefcase`.\n\npkg\n---\n\nBuild and run applications with packaging.\n\n**Deprecated** `parseDependencyPath(string, registry)` parses a path to resolve a package\nshorthand to an https url. These paths are used in declaring dependencies in\npackage configs like:\n\n```coffee\ndependencies:\n  postmaster: \"distri/postmaster:master\"\n```\n\nWe should just switch to using https urls. If a specific build tool wants to\nhandle short names or a registry then that is up to the tool.\n\n`htmlBlob(pkg, opts)` Create a blob object containing html of the package with a\nself executing wrapper. This blob can then be published as a standalone webpage\nor launched inside an iframe.\n\nui\n---\n\nArtisanal User Interface\n\n### Menus\n\n- Context Menu\n- Menu Bar\n- Nested submenus\n\nSimple DSL for creating menus and binding to handlers.\n\n```\n{ContextMenu} = require \"ui\"\n\ncontextMenu = ContextMenu()\ndocument.body.appendChild contextMenu.element\n```\n\n### Modals\n\n- Alert\n- Confirm\n- Prompt\n\nPromise returning prompts, confirms, etc.\n\n### Actions\n\nHotkeys, help text, icons, enabled/disabled states.\n\n### Z-Indexes\n\nIs there a sane way to do z-indexes? Right now I'm just listing them.\n\nModal: 1000\nContext Menu: 2000\n\nNaming Conventions\n---\n\n`system` provides many namespaces such as `system.fs`, `system.ui`, etc.\nNamespaces are lower case.\n\nThose namespaces provide constructors and methods. Methods are lower initial\ncamel-case:\n\n`system.util.style(...)`\n\nConstructors are upper initial camel-case and should _not_ be called with `new`.\n\n`system.ui.Window(...)`\n\nRuntime\n-------\n\nExperimenting with delegating more App plumbing to system through `app.Base`.\n\nCurrently implemented as something like this in ZineOS:\n\n```\nself.executePackageInIFrame\n  distribution:\n    main: \n      content: \"\"\"\n        global.app = system.app.Base({\n          pkg: PACKAGE\n        });\n        require(\"./app\");\n        app.trigger(\"boot\");\n      \"\"\"\n    app:\n      content: source\n  dependencies:\n    \"!system\": PACKAGE.dependencies[\"!system\"]\n```\n\nIt makes a shim package, passing ZineOS's `!system` dependency through, then\ninitializing a global `app` using the runtime's `system.app.Base` to wire up all the\nbiz, then requires the single `app` file. Finally it triggers the `boot` event\nfor the app.\n\nThis kind of pattern may make its way into a `util` in `system` one day. Still\nexperimenting with the details.\n\nDeprecations\n---\n\n`system.client` is a deprecated namespace from when `system` was synonymous with\n`system.host` and all the other namespaces lived under `system.client`.\n"},"TODO.md":{"content":"TODO\n====\n\n## v0.5.2\n\n- [ ] UI\n  - [ ] Update base CSS, apply consistent resets, default fonts, headings,\nforms, buttons, tables, etc.\n  - [x] Try out CSS variables for theming!\n  - [x] Style Ace searchbox\n- [x] The object exported is `lib/runtime` with a .launch method. This is a\n  little strange and due to historical accident. It would be better to export\n  the entire package and include a compatible `system.launch`.\n- [ ] `acct.Account` refreshCredentials should be limited to one active request\nat a time.\n- [x] Expand Base/Mount fs with additional QoL capabilities like\n  `fs.write \"path.js\", \"string content\"`. This way the utility functionality\n  will be in one place. It will also be able to mount additional systems like\n  `/local/`, `/session/`, etc.\n- [ ] Consolidate lib/util and runtime util exports.\n- [x] Fix cached \"Invalid Date\" meta data when saving files in S3FS.\n- [x] Jadelet SVG support\n- [x] Import `require` lib\n- [ ] Move caching out of S3FS and into Mount or even closer to the UI as an\noption.\n\nOrganization\n------------\n\nOrganize the system libraries, how they are exposed and grouped. Think about\nthe system proxy and sending messages to the host system. Think about the\nnested layers of launching apps and hooking up system handlers.\n\nConsiderations:\n\n- Make it easy to launch an app and bind its filesystem to a subfolder of the\nhost system.\n\nBugs\n----\n\n- [x] My Briefcase can't load files in the root level, messes up the path.\n\nChores\n------\n\n- [ ] Don't require `pkg` to be attached to `app` maybe pass it in as an extra\n  config to `BaseApp`\n\nv1\n---\n\nGoing to require a bit of exploration and improvements to core tools first.\n\n- [ ] Lazy Loaders\n  - [x] AWS\n  - [ ] Compilers\n    - [ ] CoffeeScript\n    - [ ] Stylus\n- [ ] UI playground Docs and Examples\n  - [ ] Context Menu\n  - [ ] Window\n  - [ ] Modal\n- [ ] Explore and have fun!\n- [ ] Rewrite views with new knowledge of improving performance\n- [ ] Simplify where possible\n- [ ] Publish / Share components\n  - [ ] Maybe use new plugin tech?!?!1/\n- [ ] Customizable styles\n- [x] Restyle with new danielx.net aesthetics\n  - [x] No border radius\n  - [x] Box Shadow\n- [x] Figure out relationship to system-client, Jadelet, Observable, and other\ndependencies. See [Architecture](https://danielx.net/wiki/architecture.html)!\n  - [x] Remove bindable dep and have it in lib\n  - [x] Merge system-client into here and have this become system-client.\n    - [x] Lib\n      - [x] drop\n      - [x] extensions\n      - [x] file-io\n      - [x] system-client\n    - ~Postmaster dep~\n      - Can't run tests easily inside iframes, crashes chrome...\n      - This will be maintained from danielx.net/editor/ for now\n  - [x] Fix template testing in Prometheus\n    - [x] Template testing depends on `system.client.Jadelet2`, if a project\n    doesn't include the `!system` dependency then it won't have that for the\n    preview.\n- [x] Update to Jadelet2\n\nWhimsy.space system library should have a full featured UI and utility\nfunctions. This will give you everything you need to construct apps. It will\nalso provide a consistent API and sytle.\n\nIt should cover creating apps in iframes, `My Briefcase` integration, common\nutility libs. Common extensions. This environment should be comfortable. It\nshould be relatively portable, but don't break your ass favoring portability\nover ergonomics. The proper weighting is that portability is just ergonomics\nover a different timeline.\n\nError Reporting?\n------\n\n```\n// Move error event handlers into runtime as well\n// Handle non-error objects\n// Can only send serializable things across\nwindow.addEventListener('error', function(e) {\n  // system.error(\"heyy\");\n});\nwindow.addEventListener('unhandledrejection', function (e) {\n  // system.error({\n  //   message: e.reason.message,\n  //   stack: e.reason.stack\n  // });\n});\n```\n\nv0\n---\n\n    Modals\n    ---\n    âœ”ï¸Alert\n    âœ”ï¸Prompt\n    âœ”Confirm\n    âœ”General\n\n    Menus\n    ---\n    âœ”ï¸Menu Bar\n    âœ”ï¸Context Menu\n    âœ”ï¸Keyboard Navigation (Up, Down, Left, Right)\n    âœ”ï¸Accelerator Keys\n    âœ”ï¸Display Hotkeys\n    âœ”ï¸Indicate Enabled/Disabled\n    âœ”ï¸Nested Submenus\n\n    Toaster/Popup Notifications\n    ---\n    Animations\n    Native notifications?\n\n    Global Hotkeys\n\n    Loader / Progress\n\n    Documentation\n    ---\n    Modals\n    Menus\n    Context Menus\n    Hotkeys\n    Windows\n\n    Examples\n    ---\n    âœ”Modal Progress Bar\n\n    Windows\n    ---\n    âœ”Draggable\n    âœ”Resizable (Need to add invisible overlay when moving the mouse so iframes don't jank up the resize)\n    âœ”Close\n    âœ”Maximize\n    âœ”Z-Index\n    Option Menu\n\nTOMAYBE\n=======\n\nTile Windows\n\nForms\n\nTables/Grids\n\nLists\n\nFile Trees\n"},"demo.coffee":{"content":"{\n  AceEditor\n  applyStyle\n  ContextMenu\n  FuzzyListView\n  Login\n  MenuBar\n  Modal\n  Observable\n  Util:{parseMenu}, \n  Progress\n  Style\n  Table\n  Window\n} = require \"./lib/ui/index\"\n\n{o} = require \"./util\"\n\nJadelet = require \"./lib/jadelet\"\n\nnotepadMenuText = require \"./samples/notepad-menu\"\nnotepadMenuParsed = parseMenu notepadMenuText\n\nFormSampleTemplate = require \"./samples/test-form\"\n\nglobal.PACKAGE = PACKAGE\napplyStyle Style.all, \"system\"\napplyStyle require(\"./style/demo\"), \"demo\"\n\nsampleMenuParsed = parseMenu \"\"\"\n  [M]odal\n    [A]lert\n    [C]onfirm\n    [P]rompt\n    [F]orm\n    F[u]zzy List\n    P[r]ogress\n  [T]est Nesting\n    Test[1]\n      Hello\n      Wat\n    Test[2]\n      [N]ested\n      -----\n      [R]ad\n        So Rad\n        =====\n        Hella\n          Hecka\n            Super Hecka\n              Wicked\n          ---\n          -\n          -\n          ==\n  [W]indow\n    [L]ogin\n    New [I]mage -> newImage\n    New [P]ixel -> newPixel\n    New [T]ext -> newText\n    New [S]preadsheet -> newSheet\n\"\"\"\n{element} = MenuBar\n  items: sampleMenuParsed,\n  handlers:\n    alert: ->\n      Modal.alert \"yolo\"\n    prompt: ->\n      Modal.prompt \"Pretty cool, eh?\", \"Yeah!\"\n      .then console.log\n    confirm: ->\n      Modal.confirm \"Jawsome!\"\n      .then console.log\n    form: ->\n      Modal.form FormSampleTemplate\n        cancel: (e) ->\n          e.preventDefault()\n          Modal.hide()\n      .then console.log\n    fuzzyList: ->\n      view = FuzzyListView\n        items: ->\n          Object.keys PACKAGE.source\n        ItemTemplate: (item) ->\n          {content} = PACKAGE.source[item]\n\n          Template = Jadelet.exec \"\"\"\n            div\n              span.name @name\n              span.length(style=\"float: right; font-style: italic; margin-right: 1rem\") @size\n          \"\"\"\n\n          Template\n            name: item\n            size: content.length\n\n        maxItems: ->\n          9999\n        submit: (item) ->\n          Modal.hide()\n\n          console.log PACKAGE.source[item]\n\n      Modal.form view.element,\n        cancellable: true\n    login: ->\n      new Promise (resolve, reject) ->\n        Login({\n          resolve\n          reject\n        })\n      .then (account) ->\n        console.log account\n\n        # account.fs.write \"/shared-auth-test.txt\", new Blob [\"hi from login ui :)\"]\n      .catch ->\n        console.log \"Login cancelled\"\n\n    progress: ->\n      initialMessage = \"Reticulating splines\"\n      progressView = Progress\n        value: 0\n        max: 2\n        message: initialMessage\n\n      Modal.show progressView.element,\n        cancellable: false\n\n      intervalId = setInterval ->\n        newValue = progressView.value() + 1/60\n        ellipsesCount = Math.floor(newValue * 4) % 4\n        ellipses = [0...ellipsesCount].map ->\n          \".\"\n        .join(\"\")\n        progressView.value(newValue)\n        progressView.message(initialMessage + ellipses)\n        if newValue > 2\n          clearInterval intervalId\n          Modal.hide()\n      , 15\n    newImage: ->\n      img = document.createElement \"img\"\n      img.src = \"https://s3.amazonaws.com/whimsyspace-databucket-1g3p6d9lcl6x1/danielx/data/pI1mvEvxcXJk4mNHNUW-kZsNJsrPDXcAtgguyYETRXQ\"\n\n      addWindow\n        title: \"Yoo\"\n        content: img\n        iconEmoji: \"ðŸ’¼\"\n\n    newPixel: ->\n      frame = document.createElement \"iframe\"\n      frame.src = \"https://danielx.net/pixel-editor/embedded/\"\n\n      addWindow\n        title: \"Pixel\"\n        content: frame\n\n    newText: ->\n      AceEditor.preload()\n      .then ->\n        editor = AceEditor()\n\n        addWindow\n          title: \"Notepad.exe\"\n          content: editor.element\n\n    newSheet: ->\n      data = [0...5].map (i) ->\n        id: i\n        name: \"yolo\"\n        color: \"#FF0000\"\n\n      InputTemplate = require \"./templates/input\"\n      RowElement = (datum) ->\n        tr = document.createElement \"tr\"\n        types = [\n          \"number\"\n          \"text\"\n          \"color\"\n        ]\n\n        Object.keys(datum).forEach (key, i) ->\n          td = document.createElement \"td\"\n          td.appendChild InputTemplate\n            value: o datum, key\n            type: types[i]\n\n          tr.appendChild td\n\n        return tr\n\n      {element} = tableView = Table {\n        data\n        RowElement\n      }\n\n      menuBar = MenuBar\n        items: parseMenu \"\"\"\n          Insert\n            Row -> insertRow\n          Help\n            About\n        \"\"\"\n        handlers:\n          about: ->\n            Modal.alert \"Spreadsheet v0.0.1 by Daniel X Moore\"\n          insertRow: ->\n            data.push\n              id: 50\n              name: \"new\"\n              color: \"#FF00FF\"\n\n            tableView.render()\n\n      addWindow\n        title: \"Spreadsheet [DEMO VERSION]\"\n        content: element\n        menuBar: menuBar.element\n\ndocument.body.appendChild element\n\ndesktop = document.createElement \"desktop\"\ndocument.body.appendChild desktop\n\ncontextMenu = ContextMenu\n  items: sampleMenuParsed[1][1]\n  handlers: {}\n\ndesktop.addEventListener \"contextmenu\", (e) ->\n  if e.target is desktop\n    e.preventDefault()\n\n    contextMenu.display\n      inElement: document.body\n      x: e.pageX\n      y: e.pageY\n\naddWindow = (params) ->\n  windowView = Window params\n\n  desktop.appendChild windowView.element\n\n  return windowView\n"},"hotkeys.coffee":{"path":"hotkeys.coffee","content":"###\nHotkeys\n=======\n\nBind hotkeys\n\n    Hotkey = require \"hotkey\"\n\n    Hotkey \"ctrl+r\", ->\n      alert \"radical!\"\n\nWe'd like to be able to generate a list of hotkeys with descriptions.\n\nQuestions\n---------\n\nShould we just use Mousetrap?\n\nMaybe, but it may have different semantics with preventDefault/defaultPrevented.\n\nShould we allow binding to specific elements?\n\nImagine a windowing OS where non-iframe apps are inside draggable windows. We'd\nlike to have each 'app' able to have its own hotkeys and at the same time have\nglobal OS level hotkeys.\n\nShould `defaultPrevented` prevent executing the hotkey action? Yes\n\nShould executing a hotkey preventDefault? Yes\n\n###\n\n# TODO: This is just a rough outline\nmodule.exports = (element) ->\n  handlers = {}\n\n  handle = (event) ->\n    {key} = event\n\n    modifiersActive = [\"alt\", \"ctrl\", \"meta\", \"shift\"].filter (modifier) ->\n      event[\"#{modifier}Key\"]\n\n    combo = modifiersActive.concat(key).join(\"+\")\n\n    # TODO: Don't trigger \"plain\" events in input/text fields\n\n    handlers[combo]?(e)\n","mode":"100644","type":"blob"},"lib/assert.coffee":{"path":"lib/assert.coffee","content":"module.exports = (condition, message) ->\n  throw new Error message unless condition\n","mode":"100644","type":"blob"},"lib/indent-parse.coffee":{"path":"lib/indent-parse.coffee","content":"top = (stack) ->\n  stack[stack.length - 1]\n\nparse = (source) ->\n  stack = [[]]\n  indentation = /^(  )*/\n  depth = 0\n\n  source.split(\"\\n\").forEach (line, lineNumber) ->\n    match = line.match(indentation)[0]\n    text = line.replace(match, \"\")\n    newDepth = match.length / 2\n\n    return unless text.trim().length\n    current = text\n\n    if newDepth > depth\n      unless newDepth is depth + 1\n        throw new Error \"Unexpected indentation on line #{lineNumber}\"\n      # We're one level further in\n      # Convert the simple string to a [label, items] pair\n      items = []\n      prev = top(stack)\n      prev.push [prev.pop(), items]\n      stack.push items\n    else if newDepth < depth\n      # Pop stack to correct depth\n      stack = stack.slice(0, newDepth + 1)\n\n    depth = newDepth\n\n    top(stack).push current\n\n  return stack[0]\n\nmodule.exports = parse\n","mode":"100644","type":"blob"},"main.coffee":{"content":"# We require the polyfill and the extensions, it is our convention\nrequire \"./lib/polyfill\"\nrequire \"./lib/extensions\"\n\n# Launch demo if we are the published package (not a lib)\nif PACKAGE.name is \"ROOT\"\n  require \"./demo\"\n\nmodule.exports = require \"./lib/exports\"\n"},"modal.coffee":{"content":"###\nModal\n\nDisplay modal alerts or dialogs.\n\nModal has promise returning equivalents of the native browser:\n\n- Alert\n- Confirm\n- Prompt\n\nThese accept the same arguments and return a promise fulfilled with\nthe same return value as the native methods.\n\nYou can display any element in the modal:\n\n    modal.show myElement\n\n###\n\nJadelet = require \"./lib/jadelet\"\n\n{formDataToObject, handle, empty} = require \"./util\"\n\nPromptTemplate = require \"./templates/modal/prompt\"\nModalTemplate = require \"./templates/modal\"\nCancelButtonTemplate = require \"./templates/cancel-button\"\nInputTemplate = require \"./templates/input\"\n\nmodal = ModalTemplate()\n\nFocusTrap = Jadelet.exec \"\"\"\n  span(@focus tabindex=0)\n\"\"\"\n\ncancellable = true\nmodal.onclick = (e) ->\n  if e.target is modal and cancellable\n    Modal.hide()\n\ndocument.addEventListener \"keydown\", (e) ->\n  unless e.defaultPrevented\n    if e.key is \"Escape\" and Modal.visible() and cancellable\n      e.preventDefault()\n      Modal.hide()\n\ndocument.body.appendChild modal\n\ncloseHandler = null\n\nprompt = (params) ->\n  new Promise (resolve) ->\n    element = PromptTemplate params\n\n    Modal.show element,\n      cancellable: false\n      closeHandler: resolve\n    element.querySelector(params.focus)?.focus()\n\nmodule.exports = Modal =\n  show: (element, options) ->\n    # Close if open\n    if modal.classList.contains \"active\"\n      Modal.hide()\n\n    if typeof options is \"function\"\n      closeHandler = options\n    else\n      closeHandler = options?.closeHandler\n      if options?.cancellable?\n        cancellable = options.cancellable\n\n    empty(modal).appendChild(element)\n    modal.classList.add \"active\"\n\n  hide: (dataForHandler) ->\n    closeHandler?(dataForHandler)\n    modal.classList.remove \"active\"\n    cancellable = true\n    empty(modal)\n\n  visible: ->\n    modal.classList.contains \"active\"\n\n  alert: (message) ->\n    prompt\n      title: \"Alert\"\n      message: message\n      focus: \"button\"\n      confirm: handle ->\n        Modal.hide()\n\n  prompt: (message, defaultValue=\"\", title=\"Prompt\") ->\n    prompt\n      title: title\n      message: message\n      focus: \"input\"\n      inputElement: InputTemplate\n        type: \"text\"\n        value: defaultValue\n      cancelButton: CancelButtonTemplate\n        cancel: handle ->\n          Modal.hide(null)\n      confirm: handle ->\n        Modal.hide modal.querySelector(\"input\").value\n\n  confirm: (message, title=\"Confirm\") ->\n    prompt\n      title: title\n      message: message\n      focus: \"button\"\n      cancelButton: CancelButtonTemplate\n        cancel: handle ->\n          Modal.hide(false)\n      confirm: handle ->\n        Modal.hide(true)\n\n  form: (formElement, options={}) ->\n    {\n      cancellable\n    } = options\n    \n    cancellable ?= false\n    \n    new Promise (resolve) ->\n      submitHandler = handle (e) ->\n        formData = new FormData(formElement)\n        result = formDataToObject(formData)\n        Modal.hide(result)\n\n      formElement.addEventListener \"submit\", submitHandler\n\n      focusFirstElement = (e) ->\n        el = formElement.querySelector(\"\"\"\n          button,\n          [href],\n          input,\n          select,\n          textarea,\n          [tabindex]:not([tabindex=\"-1\"])\n        \"\"\")\n\n        if el\n          e?.preventDefault()\n          el.focus()\n\n      Modal.show formElement,\n        cancellable: cancellable\n        closeHandler: (result) ->\n          formElement.removeEventListener \"submit\", submitHandler\n          focusTrap.remove()\n          resolve(result)\n\n      # Focus first focusable form element and trap focus in modal\n      focusFirstElement()\n      # tabindex focus trap\n      focusTrap = FocusTrap\n        focus: focusFirstElement\n      formElement.appendChild focusTrap\n\n      return\n"},"pixie.cson":{"content":"name: \"system\"\nversion: \"0.5.3\"\npublishPath: \"/My Briefcase/public/danielx.net/\"\ndependencies: {}\nremoteDependencies: [\n  \"https://danielx.net/cdn/dexie/2.0.4.min.js\"\n]\ncognito:\n  identityPoolId: 'us-east-1:4fe22da5-bb5e-4a78-a260-74ae0a140bf9'\n  poolData:\n    UserPoolId : 'us-east-1_cfvrlBLXG'\n    ClientId : '3fd84r6idec9iork4e9l43mp61'\n"},"samples/notepad-menu.coffee":{"path":"samples/notepad-menu.coffee","content":"module.exports = \"\"\"\n  [F]ile\n    [N]ew\n    [O]pen\n    [S]ave\n    Save [A]s\n    -\n    Page Set[u]p\n    [P]rint\n    -\n    E[x]it\n  [E]dit\n    [U]ndo\n    Redo\n    -\n    Cu[t]\n    [C]opy\n    [P]aste\n    De[l]ete\n    -\n    [F]ind\n    Find [N]ext\n    [R]eplace\n    [G]o To\n    -\n    Select [A]ll\n    Time/[D]ate\n  F[o]rmat\n    [W]ord Wrap\n    [F]ont...\n  [V]iew\n    [S]tatus Bar\n  [H]elp\n    View [H]elp\n    -\n    [A]bout Notepad\n\"\"\"\n","mode":"100644","type":"blob"},"samples/test-form.jadelet":{"content":"form\n  h1 Cool Form Bro\n  p\n    a(href=\"https://yolo.biz\") Yolo\n    a.button Link Button\n  input(name=\"yolo\")\n  input(name=\"x\" value=\"Lorem\")\n  input(name=\"y\" value=\"florem\")\n  input(name=\"z\" type=\"number\" value=5)\n  input(name=\"file\" type=\"file\")\n  textarea(name=\"text\")\n  button Submit\n  button(click=@cancel) Cancel\n"},"templates/input.jadelet":{"content":"input(@value @type)\n"},"templates/menu-item.jadelet":{"content":"menu-item(@class @click @mousemove @disabled)\n  label\n    @title\n    span.hotkey @hotkey\n    span.decoration @decoration\n  @content\n"},"templates/menu-separator.jadelet":{"path":"templates/menu-separator.jadelet","content":"menu-item\n  hr\n","mode":"100644","type":"blob"},"templates/menu.jadelet":{"content":"menu(@class @click @style) @items\n"},"templates/modal.jadelet":{"path":"templates/modal.jadelet","content":"#modal\n","mode":"100644","type":"blob"},"templates/modal/prompt.jadelet":{"content":"form(submit=@confirm tabindex=-1)\n  h1 @title\n  p @message\n  @inputElement\n  button OK\n  @cancelButton\n"},"templates/progress.jadelet":{"content":"loader\n  p @message\n  progress(@class @value @max)\n"},"templates/table.jadelet":{"content":"container\n  table(@keydown)\n    thead\n      @headerElements\n    tbody\n"},"templates/window.jadelet":{"content":"window(@class)\n  resize.n.h\n  resize.e.v\n  resize.s.h\n  resize.w.v\n  resize.n.e.h\n  resize.n.e.v\n  resize.n.w.h\n  resize.n.w.v\n  resize.s.e.h\n  resize.s.e.v\n  resize.s.w.h\n  resize.s.w.v\n  header\n    icon(style=@iconStyle) @iconEmoji\n    title-bar(dblclick=@maximize) @title\n    control.minimize(click=@minimize)\n    control.maximize(click=@maximize)\n    control.restore(click=@restore)\n    control.close(click=@close)\n  @menuBar\n  viewport\n    @content\n"},"test/menu-item.coffee":{"content":"PACKAGE.name = \"test\"\nrequire \"../main\"\n\nMenuItemView = require \"../views/menu-item\"\nObservable = require \"../lib/observable\"\n\ndescribe \"MenuItem\", ->\n  # TODO: Make context root optional\n\n  it \"should have correct custom action names\", ->\n    called = false\n\n    menuItem = MenuItemView\n      label: \"Cool -> Super Cool\"\n      contextRoot:\n        activeItem: ->\n        handlers:\n          \"Super Cool\": ->\n            called = true\n\n    assert !called\n    menuItem.click()\n    assert called\n"},"test/menu-parser.coffee":{"content":"parse = require \"../lib/indent-parse\"\n\ndescribe \"Menu Parser\", ->\n  it \"should parse menus into lists\", ->\n    data = \"\"\"\n      File\n    \"\"\"\n\n    results = parse(data)\n    assert.deepEqual [\"File\"], results\n\n  it \"should parse empty\", ->\n    data = \"\"\"\n    \"\"\"\n\n    assert.deepEqual [], parse(data)\n\n  it \"should deal with nesting ok\", ->\n    data = \"\"\"\n      File\n        Open\n        Save\n      Edit\n        Copy\n        Paste\n      Help\n    \"\"\"\n\n    results = parse(data)\n    assert.deepEqual [\n      [\"File\", [\"Open\", \"Save\"]]\n      [\"Edit\", [\"Copy\", \"Paste\"]]\n      \"Help\"\n    ], results\n\n  it \"should parse big ol' menus\", ->\n    results = parse \"\"\"\n      File\n        New\n        Open\n        Save\n        Save As\n      Edit\n        Undo\n        Redo\n        -\n        Cut\n        Copy\n        Paste\n        Delete\n        -\n        Find\n        Find Next\n        Replace\n        Go To\n        -\n        Select All\n        Time/Date\n      Format\n        Word Wrap\n        Font...\n      View\n        Status Bar\n      Help\n        View Help\n        -\n        About Notepad\n    \"\"\"\n\n    assert.deepEqual [\n      [\"File\", [\"New\", \"Open\", \"Save\", \"Save As\"]]\n      [\"Edit\", [\"Undo\", \"Redo\", \"-\", \"Cut\", \"Copy\", \"Paste\", \"Delete\", \"-\", \"Find\", \"Find Next\", \"Replace\", \"Go To\", \"-\", \"Select All\", \"Time/Date\"]]\n      [\"Format\", [\"Word Wrap\", \"Font...\"]]\n      [\"View\", [\"Status Bar\"]]\n      [\"Help\", [\"View Help\", \"-\", \"About Notepad\"]]\n    ], results\n\n  it \"should parse hella nested menus\", ->\n    results = parse \"\"\"\n      File\n        Special\n          Nested\n            Super\n              Awesome\n    \"\"\"\n\n    assert.deepEqual [\n      [\"File\", [\n        [\"Special\", [\n          [\"Nested\", [\n            [\"Super\", [\n              \"Awesome\"\n            ]]\n          ]]\n        ]]\n      ]]\n    ], results\n"},"test/menu.coffee":{"content":"MenuView = require \"../views/menu\"\nObservable = require \"../lib/observable\"\n\ndescribe \"Menu\", ->\n  # TODO: Make context root optional\n\n  it \"should work with plain ol' items\", ->\n    menu = MenuView\n      items: [\n        \"Cool\"\n        \"Rad\"\n      ]\n      contextRoot:\n        activeItem: Observable null\n        handlers: {}\n\n    assert.equal menu.items().length, 2\n\n  it \"should allow observable items\", ->\n    items = Observable [\n      \"Cool\"\n      [\"Rad\", [\"2rad\", \"2Furious\"]]\n    ]\n\n    menu = MenuView\n      items: items\n      contextRoot:\n        activeItem: Observable null\n        handlers: {}\n\n    assert.equal menu.items().length, 2\n\n    items [\n      \"New Stuff\"\n    ]\n\n    assert.equal menu.items().length, 1\n"},"test/modal.coffee":{"content":"PACKAGE.name = \"test\"\n{Modal} = require \"../lib/ui/index\"\n\ndescribe \"Modal\", ->\n  it \"shoud be totally chill\", ->\n    element = document.createElement \"p\"\n\n    called = false\n    handler = (value) ->\n      called = true\n      assert.equal value, \"yolo\"\n\n    Modal.show(element, handler)\n    Modal.hide('yolo')\n\n    assert called\n"},"util.coffee":{"content":"# TODO: This is mostly internal utils / helpers\n# a lot is experimenting with APIs and ergonomics\n# These are not the public utils that we plan to export.\n\nObservable = require \"./lib/observable\"\n\nA = (attr) ->\n  (x) -> x[attr]\n\nF = (methodName) ->\n  (x) -> x[methodName]()\n\nget = (x, context) ->\n  if typeof x is 'function'\n    x.call(context)\n  else\n    x\n\n# Observable attribute helper\no = (object, name) ->\n  attribute = Observable(object[name])\n\n  attribute.observe (newValue) ->\n    object[name] = newValue\n\n  return attribute\n\n# Handle events by preventing the default action\nhandle = (fn) ->\n  (e) ->\n    return if e?.defaultPrevented\n    e?.preventDefault()\n    fn.call(this, e)\n\n# I hope I don't hate myself for this later\n# S for Safe invoke, invoke the method of the object, if it exists and is a\n# function, otherwise return the provided default value\nS = (object, method, defaultValue) ->\n  ->\n    if typeof object?[method] is 'function'\n      object[method]()\n    else\n      defaultValue\n\nasElement = A('element')\n\naccelerateItem = (items, key) ->\n  [acceleratedItem] = items.filter (item) ->\n    item.accelerator is key\n\n  if acceleratedItem\n    # TODO: should there be some kind of exec rather than click action?\n    acceleratedItem.click()\n\nisDescendant = (element, ancestor) ->\n  return unless element\n\n  while (parent = element.parentElement)\n    return true if element is ancestor\n    element = parent\n\nadvance = (list, amount) ->\n  [currentItem] = list.filter (item) ->\n    item.active()\n\n  activeItemIndex = list.indexOf(currentItem) + amount\n\n  if activeItemIndex < 0\n    activeItemIndex = list.length - 1\n  else if activeItemIndex >= list.length\n    activeItemIndex = 0\n\n  list[activeItemIndex]\n\n# TODO: Nested objects?\n# TODO: Convert keys ending in [] to array entries?\n# Just keeping it simple and crushing duplicate names\nformDataToObject = (formData) ->\n  Array.from(formData.entries()).reduce (object, [key, value]) ->\n    object[key] = value\n\n    object\n  , {}\n\n# Get the view associated with a dom element\n# This will let us use the dom tree rather than manage a separate tree\n# to dispatch events at the view level\n# the assumption is that a .view property is written to the root element in the\n# view when rendering a view's template element\nelementView = (element) ->\n  return unless element\n  return element.view if element.view\n  elementView element.parentElement\n\n# Remove all children from a dom node\nempty = (node) ->\n  while node.hasChildNodes()\n    node.removeChild(node.lastChild)\n\n  return node\n\nmodule.exports = Util =\n  htmlEscape: (string) ->\n    String(string).replace /[&<>\"'\\/]/g, (s) ->\n      entityMap[s]\n\n  A: A\n  F: F\n  S: S\n  o: o\n\n  advance: advance\n  asElement: asElement\n  accelerateItem: accelerateItem\n\n  elementView: elementView\n  empty: empty\n  formDataToObject: formDataToObject\n  get: get\n  handle: handle\n  isDescendant: isDescendant\n\n\nentityMap =\n  \"&\": \"&amp;\"\n  \"<\": \"&lt;\"\n  \">\": \"&gt;\"\n  '\"': '&quot;'\n  \"'\": '&#39;'\n  \"/\": '&#x2F;'\n"},"views/context-menu.coffee":{"content":"###\nContextMenu\n\nDisplay a context menu!\n\nQuestions:\n\nShould we be able to update the options in the menu after creation?\n\n###\n\nObservable = require \"../lib/observable\"\n\nMenuView = require \"./menu\"\n\n{isDescendant} = require \"../util\"\n\nmodule.exports = ({items, classes, handlers}) ->\n  activeItem = Observable null\n  classes ?= []\n  top = Observable \"\"\n  left = Observable \"\"\n\n  contextRoot =\n    activeItem: activeItem\n    handlers: handlers\n    finish: ->\n      element.remove()\n      # Cleanup global handler on finish\n      document.removeEventListener \"mousedown\", documentHandler\n\n  self = MenuView\n    items: items\n    contextRoot: contextRoot\n    classes: -> [\"context\", \"options\"].concat(classes)\n    style: ->\n      \"top: #{top()}px; left: #{left()}px\"\n\n  element = self.element\n  element.view = self\n\n  documentHandler = (e) ->\n    unless isDescendant(e.target, element)\n      activeItem null\n      contextRoot.finish()\n\n  self.contextRoot = contextRoot\n  self.display = ({inElement, x, y}) ->\n    # This must be attached to the document body so we can de-activate when\n    # a person presses the mouse outside of our menu\n    document.addEventListener \"mousedown\", documentHandler\n\n    top(y)\n    left(x)\n\n    # The element must be added to the dom before it can be activated\n    # it must be visible before it can be focused\n    (inElement or document.body).appendChild element\n    activeItem self\n    element.focus()\n\n  element.setAttribute(\"tabindex\", \"-1\")\n  element.addEventListener \"keydown\", (e) ->\n    {key} = e\n\n    switch key\n      when \"ArrowLeft\", \"ArrowUp\", \"ArrowRight\", \"ArrowDown\"\n        e.preventDefault()\n        direction = key.replace(\"Arrow\", \"\")\n\n        currentItem = activeItem()\n\n        if currentItem\n          currentItem.cursor(direction)\n\n      when \"Escape\"\n        activeItem null\n\n  return self\n"},"views/menu-bar.coffee":{"content":"# The MenuBar is a list MenuItems arranged in a bar across the top of a page or\n# window.\n\nObservable = require \"../lib/observable\"\n\nMenuView = require \"./menu\"\n\n{isDescendant, advance} = require \"../util\"\n\nmodule.exports = ({items, handlers}) ->\n  acceleratorActive = Observable false\n  # Track active menus and item for navigation\n  activeItem = Observable null\n  previouslyFocusedElement = null\n\n  contextRoot =\n    activeItem: activeItem\n    handlers: handlers\n\n  self = MenuView\n    classes: ->\n      [\n        \"bar\"\n        \"accelerator-active\" if acceleratorActive()\n      ]\n    items: items\n    contextRoot: contextRoot\n\n  element = self.element\n\n  # Redefine cursor movement\n  self.cursor = (direction) ->\n    switch direction\n      when \"Right\"\n        self.advance(1)\n      when \"Left\"\n        self.advance(-1)\n\n  # Redefine expand to down and not right on menu items\n  self.items.forEach (item) ->\n    item.horizontal = true\n    item.cursor = (direction) ->\n      console.log \"Item\", direction\n      if direction is \"Down\"\n        item.submenu?.advance(1)\n      else if direction is \"Up\"\n        item.submenu?.advance(-1)\n      else\n        item.parent.cursor direction\n\n  deactivate = ->\n    activeItem null\n    acceleratorActive false\n    # De-activate menu and focus previously focused element\n    previouslyFocusedElement?.focus()\n\n  document.addEventListener \"mousedown\", (e) ->\n    unless isDescendant(e.target, element)\n      acceleratorActive false\n      activeItem null\n\n  document.addEventListener \"keydown\", (e) ->\n    {key} = e\n    switch key\n      when \"Enter\"\n        activeItem()?.click()\n      when \"Alt\"\n        menuIsActive = false\n        if acceleratorActive() or menuIsActive\n          deactivate()\n        else\n          # Store previously focused element\n          # Get menu ready for accelerating!\n          previouslyFocusedElement = document.activeElement\n          element.focus()\n          activeItem self unless activeItem()\n          acceleratorActive true\n\n  # Dispatch the key to the active menu element\n  accelerateIfActive = (key) ->\n    if acceleratorActive()\n      activeItem()?.accelerate(key)\n\n  # We need to be able to focus the menu to receive keyboard events on it\n  element.setAttribute(\"tabindex\", \"-1\")\n  element.addEventListener \"keydown\", (e) ->\n    {key} = e\n\n    switch key\n      when \"ArrowLeft\", \"ArrowUp\", \"ArrowRight\", \"ArrowDown\"\n        e.preventDefault()\n        direction = key.replace(\"Arrow\", \"\")\n\n        currentItem = activeItem()\n\n        if currentItem\n          currentItem.cursor(direction)\n\n      when \"Escape\"\n        deactivate()\n      else\n        # Only prevent default if we successfully accelerated?\n        accelerated = accelerateIfActive(key.toLowerCase())\n        if accelerated?\n          e.preventDefault()\n\n  return self\n"},"views/menu-item.coffee":{"content":"{advance, htmlEscape, asElement, F, S, isDescendant, accelerateItem, handle} = require \"../util\"\n\nMenuItemTemplate = require \"../templates/menu-item\"\n\n# MenuItemView\n# An item that appears in menus\nmodule.exports = ({label, MenuView, items, contextRoot, parent}) ->\n  self = {}\n\n  {activeItem, handlers} = contextRoot\n  # TODO: This gets called per menu item when the state changes\n  # Could we shift it a little to only be called for the relevant subtree?\n  active = ->\n    isDescendant activeItem()?.element, element\n\n  self.active = active\n\n  if items\n    submenu = MenuView({\n      items\n      contextRoot\n      parent: self\n    })\n    content = submenu.element\n\n  # Hook in to Action objects so we can display hotkeys\n  # and enabled/disabled statuses.\n  [labelText, actionName] = formatAction label\n  [title, accelerator] = formatLabel labelText\n  action = handlers[actionName]\n  disabled = S(action, \"disabled\", false)\n  hotkey = S(action, \"hotkey\", \"\")\n\n  click = (e) ->\n    return if disabled()\n    return if e?.defaultPrevented\n    e?.preventDefault()\n\n    if submenu\n      activeItem submenu\n      return\n\n    action?.call?(handlers)\n\n    # TODO: More cleanup than just clearing the active item, like also we\n    # should clear accelerator state, and maybe return focus to previously\n    # focused element.\n    # contextRoot.finish?\n    activeItem null\n    contextRoot.finish?()\n\n  element = MenuItemTemplate\n    class: ->\n      [\n        \"menu\" if items\n        \"active\" if active()\n      ]\n    click: click\n\n    mousemove: (e) ->\n      # Click to activate top level menus unless a menu is already active\n      # then hover to show.\n      return unless activeItem()\n\n      if !e.defaultPrevented and isDescendant(e.target, element)\n        # Note: We're using preventDefault to prevent handling the\n        # activation above the first element that handles it\n        e.preventDefault()\n\n        activeItem self\n\n    title: title\n    content: content\n    decoration: \"â–¸\" if items\n    hotkey: hotkey\n    disabled: disabled\n\n  Object.assign self,\n    accelerator: accelerator\n    accelerate: (key) ->\n      if submenu\n        submenu.accelerate key\n      else\n        parent.accelerate key\n    click: click\n    parent: parent\n    element: element\n    submenu: submenu\n    cursor: (direction) ->\n      console.log \"Item Cursor\", direction\n      if submenu and direction is \"Right\"\n        # Select the first navigable item of the submenu\n        activeItem submenu.navigableItems[0]\n      else if parent.parent and direction is \"Left\"\n        # parent is the menu,\n        # parent.parent is the item in the menu containing the parent\n        if parent.parent.horizontal\n          parent.parent.cursor(direction)\n        else\n          activeItem parent.parent\n      else\n        parent.cursor(direction)\n\n  return self\n\n# Parse out custom action symbol from entries like:\n#\n#     [F]ont... -> showFont\n#\n# Falling back to formatting the action title\nformatAction = (labelText) ->\n  [title, action] = labelText.split(\"->\").map F(\"trim\")\n\n  unless action\n    action = title.replace(/[^A-Za-z0-9]/g, \"\")\n    action = action.charAt(0).toLowerCase() + action.substring(1)\n\n  return [title, action]\n\nformatLabel = (labelText) ->\n  accelerator = undefined\n  # Parse out accelerator keys for underlining when alt is pressed\n  titleHTML = htmlEscape(labelText).replace /\\[([^\\]]+)\\]/, (match, $1) ->\n    accelerator = $1.toLowerCase()\n    \"<span class=\\\"accelerator\\\">#{$1}</span>\"\n\n  span = document.createElement \"span\"\n  span.innerHTML = titleHTML\n\n  return [span, accelerator]\n"},"views/menu-separator.coffee":{"path":"views/menu-separator.coffee","content":"MenuSeparatorTemplate = require \"../templates/menu-separator\"\n\nmodule.exports = ->\n  element: MenuSeparatorTemplate()\n  separator: true\n","mode":"100644","type":"blob"},"views/menu.coffee":{"content":"Observable = require \"../lib/observable\"\n\nassert = require \"../lib/assert\"\n\n{advance, accelerateItem, asElement, get, F, S, htmlEscape, handle, isDescendant} = require \"../util\"\n\nMenuTemplate = require \"../templates/menu\"\nMenuItemTemplate = require \"../templates/menu-item\"\n\nSeparatorView = require \"./menu-separator\"\nMenuItemView = require \"./menu-item\"\n\nparseMenu = require \"../lib/indent-parse\"\n\n# MenuView\n#\n# items is an array of item data\n# An item datum is either a string\n# or a pair of [label:string, items...]\n#\n# ex. [\n#   \"Cool\"\n#   [\"Submenu\", [\n#     \"Yo\",\n#     \"Wat\"\n#   ]]\n# ]\n#\nmodule.exports = MenuView = ({items, classes, style, contextRoot, parent}) ->\n  self = {}\n  contextRoot ?=\n    activeItem: Observable()\n    handlers: {}\n\n  classes ?= -> [\"options\"]\n\n  {activeItem} = contextRoot\n  \n  if typeof items is \"string\"\n    items = parseMenu(items)\n\n  # Converts items from the data to the element jazz\n  getItems = Observable ->\n    items.map (item) ->\n      switch\n        when typeof item is \"string\" and item.match(/^[=-]+$/)\n          SeparatorView()\n        when Array.isArray(item)\n          assert item.length is 2\n          [label, submenuItems] = item\n          MenuItemView\n            label: label\n            items: submenuItems\n            MenuView: MenuView\n            contextRoot: contextRoot\n            parent: self\n        else\n          MenuItemView\n            label: item\n            contextRoot: contextRoot\n            parent: self\n\n  navigableItems = Observable ->\n    getItems().filter (item) ->\n      !item.separator\n\n  # TODO: This gets called per menu item when the state changes\n  # Could we shift it a little to only be called for the relevant subtree?\n  # Possible solution: find the common ancestor of the new active and the previous\n  # active and only update the necessary ones\n  active = ->\n    isDescendant activeItem()?.element, self.element\n\n  Object.assign self,\n    accelerate: (key) ->\n      accelerateItem(getItems(), key)\n    cursor: (direction) ->\n      switch direction\n        when \"Up\"\n          self.advance(-1)\n        when \"Down\"\n          self.advance(1)\n        else\n          parent.parent?.cursor(direction)\n    parent: parent\n    items: getItems\n    advance: (n) ->\n      activeItem advance(navigableItems(), n)\n    navigableItems: navigableItems\n    element: MenuTemplate\n      style: style\n      class: ->\n        [\n          \"active\" if active()\n        ].concat classes()\n      click: handle (e) ->\n        activeItem self\n      items: ->\n        getItems().map asElement\n\n  return self\n"},"views/progress.coffee":{"content":"Template = require \"../templates/progress\"\n\nObservable = require \"../lib/observable\"\n\n\"\"\n\nmodule.exports = (params={}) ->\n  {value, max, message} = params\n  value = Observable value or 0\n  max = Observable max\n  message = Observable message\n\n  element = Template\n    value: value\n    max: max\n    message: message\n\n  element: element\n  value: value\n  message: message\n  max: max\n"},"views/table.coffee":{"content":"{empty} = require \"../util\"\n\nTableTemplate = require \"../templates/table\"\n\n# Focus same cell in next row\nadvanceRow = (path, prev) ->\n  [td] = path.filter (element) ->\n    element.tagName is \"TD\"\n  return unless td\n\n  tr = td.parentElement\n  cellIndex = Array::indexOf.call(tr.children, td)\n  if prev\n    nextRowElement = tr.previousSibling\n  else\n    nextRowElement = tr.nextSibling\n\n  if nextRowElement\n    input = nextRowElement.children[cellIndex].querySelector('input')\n    input?.focus()\n\n# The table view takes source data and a constructor that returns a row element\n# for each source datum\n\n# The view will have the ability to filter/sort the data.\n\nTableView = ({data, headers, RowElement}) ->\n  headers ?= Object.keys data[0]\n\n  containerElement = TableTemplate\n    headerElements: headers.map (header) ->\n      th = document.createElement 'th'\n      th.textContent = header\n      return th\n    keydown: (event) ->\n      {key, path} = event\n      switch key\n        when \"Enter\", \"ArrowDown\"\n          event.preventDefault()\n          advanceRow path\n        when \"ArrowUp\"\n          event.preventDefault()\n          advanceRow path, true\n        # TODO: Left and Right\n        # Left and Right are trickier because you may want to navigate within a text input\n        # ... actually up and down get trickier too if we imagine text areas or\n        # even fancier inputs that may have their own controls...\n\n  tableBody = containerElement.querySelector('tbody')\n\n  filterFn = (datum) ->\n    true\n\n  filterAndSort = (data, filterFn, sortFn) ->\n    filterFn ?= -> true\n    filteredData = data.filter(filterFn)\n\n    if sortFn\n      filteredData.sort(sortFn)\n    else\n      filteredData\n\n  rowElements = ->\n    filterAndSort(data, filterFn, null).map RowElement\n\n  update = ->\n    empty tableBody\n    rowElements().forEach (element) ->\n      tableBody.appendChild element\n\n  update()\n\n  element: containerElement\n  render: update\n\nmodule.exports = TableView\n"},"views/window.coffee":{"content":"WindowTemplate = require \"../templates/window\"\n\n{elementView} = require \"../util\"\n\n# We need an invisible full screen overlay to keep iframes from eating our\n# mousemove events\nframeGuard = document.createElement \"frame-guard\"\ndocument.body.appendChild frameGuard\n\ntopIndex = 0\nraiseToTop = (view) ->\n  return unless typeof view.zIndex is 'function'\n  zIndex = view.zIndex()\n  return if zIndex is topIndex\n  topIndex += 1\n\n  view.zIndex(topIndex)\n\n# Drag Handling\nactiveDrag = null\ndragStart = null\ndocument.addEventListener \"mousedown\", (e) ->\n  {target} = e\n\n  view = elementView target\n  if view\n    # TODO: only raise widows?\n    raiseToTop view\n    view.savePosition?()\n\n  if target.tagName is \"TITLE-BAR\"\n    dragStart = e\n    activeDrag = view\n\ndocument.addEventListener \"mousemove\", (e) ->\n  if activeDrag\n    frameGuard.classList.add(\"active\")\n    {clientX:prevX, clientY:prevY} = dragStart\n    {clientX:x, clientY:y} = e\n    dragStart = e\n\n    if activeDrag.maximized()\n      activeDrag.restore()\n      activeDrag.x x - activeDrag.width() / 2\n      activeDrag.y y - 30\n\n    dx = x - prevX\n    dy = y - prevY\n\n    activeDrag.x activeDrag.x() + dx\n    activeDrag.y activeDrag.y() + dy\n\n    # Hot Edges / Corners\n    leftEdge = x <= 10\n    rightEdge = x >= document.documentElement.getBoundingClientRect().width - 10\n    hotX = leftEdge or rightEdge\n\n    topEdge = y <= 10\n    bottomEdge = y >= document.documentElement.getBoundingClientRect().height - 10\n    hotY = topEdge or bottomEdge\n\n    if hotX or hotY\n      xPos = \"0%\"\n      yPos = \"0%\"\n      hotWidth = \"50%\"\n      hotHeight = \"50%\"\n\n      if !hotX\n        hotWidth = \"100%\"\n\n      if !hotY\n        hotHeight = \"100%\"\n\n      if bottomEdge\n        yPos = \"50%\"\n\n      if rightEdge\n        xPos = \"50%\"\n\n      activeDrag.saveSize()\n      activeDrag.maximized(true)\n      activeDrag.x(xPos)\n      activeDrag.y(yPos)\n      activeDrag.width(hotWidth)\n      activeDrag.height(hotHeight)\n\n# Resize Handling\nactiveResize = null\nresizeStart = null\nresizeInitial = null\ndocument.addEventListener \"mousedown\", (e) ->\n  {target} = e\n\n  if target.tagName is \"RESIZE\"\n    frameGuard.classList.add(\"active\")\n    resizeStart = e\n    activeResize = target\n    {width, height, x, y} = elementView activeResize\n    resizeInitial =\n      width: width()\n      height: height()\n      x: x()\n      y: y()\n\ndocument.addEventListener \"mousemove\", (e) ->\n  if activeResize\n    {clientX:startX, clientY:startY} = resizeStart\n    {clientX:x, clientY:y} = e\n\n    dx = x - startX\n    dy = y - startY\n\n    width = resizeInitial.width\n    height = resizeInitial.height\n\n    if activeResize.classList.contains(\"e\")\n      width += dx\n\n    if activeResize.classList.contains(\"w\")\n      width -= dx\n\n    if activeResize.classList.contains(\"s\")\n      height += dy\n\n    if activeResize.classList.contains(\"n\")\n      height -= dy\n\n    width = Math.max(width, 200)\n    height = Math.max(height, 50)\n\n    actualDeltaX = width - resizeInitial.width\n    actualDeltaY = height - resizeInitial.height\n\n    view = elementView activeResize\n    if activeResize.classList.contains(\"n\")\n      view.y resizeInitial.y - actualDeltaY\n\n    if activeResize.classList.contains(\"w\")\n      view.x resizeInitial.x - actualDeltaX\n\n    view.width width\n    view.height height\n\n    view.trigger \"resize\"\n\ndocument.addEventListener \"mouseup\", ->\n  activeDrag = null\n  activeResize = null\n  frameGuard.classList.remove(\"active\")\n\nBindable = require \"../lib/bindable\"\nObservable = require \"../lib/observable\"\n\nmodule.exports = (params) ->\n  self = Bindable()\n\n  x = Observable params.x ? 50\n  y = Observable params.y ? 50\n  width = Observable params.width ? 400\n  height = Observable params.height ? 300\n  title = Observable params.title ? \"Untitled\"\n  minimized = Observable false\n  maximized = Observable false\n  prevWidth = Observable null\n  prevHeight = Observable null\n  prevX = Observable null\n  prevY = Observable null\n  iconURL = Observable params.iconURL or \"data:image/x-icon;base64,AAABAAIAICAQAAEABADoAgAAJgAAABAQEAABAAQAKAEAAA4DAAAoAAAAIAAAAEAAAAABAAQAAAAAAIACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvwAAvwAAAL+/AL8AAAC/AL8Av78AAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAAAAAAAAAAAAAACHd3d3d3d3d3d3d3dwAAAAj///////////////cAAAAI///////////////3AAAACP///////3d///d39wAAAAj/zMzM//mZ//+Zn/cAAAAI////////l///+X/3AAAACP/MzMzM//l3d3l/9wAAAAj/////////mZmZf/cAAAAI/8zMzMzM//l/+X/3AAAACP//////////l/l/9wAAAAj/zMzMzMzM//l5f/cAAAAI////////////mX/3AAAACP/MzMzMzMzM//n/9wAAAAj///////////////cAAAAI/8zMzMzMzMzMzP/3AAAACP//////////////9wAAAAj/zMzMzMzMzMzM//cAAAAI///////////////3AAAACP8AAAAA/8zMzMz/9wAAAAj/iZD/8P////////cAAAAI/4AAAAD/zMzMzP/3AAAACP+P8Luw////////9wAAAAj/gAC7sP/MzMzM//cAAAAI/4/wu7D////////3AAAACP+P8Luw/////4AAAAAAAAj/j/AAAP////+P94AAAAAI/4/wzMD/////j3gAAAAACP+IiIiA/////4eAAAAAAAj///////////+IAAAAAAAI////////////gAAAAAAACIiIiIiIiIiIiIAAAAAA4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAP4AAAH+AAAD/gAAB/4AAA/+AAAf8oAAAAEAAAACAAAAABAAQAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvwAAvwAAAL+/AL8AAAC/AL8Av78AAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAACHd3d3d3cAAI//////9wAAj8z5//n3AACP//+ZmfcAAI/MzPn59wAAj////5n3AACPzMzM+fcAAI//////9wAAjwAPzMz3AACPmY////cAAI/Pj8zM9wAAj8+P//AAAACPiI//9/gAAI/////3gAAAiIiIiIgAAAgAMAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIAHAACADwAAgB8AAA==\"\n  iconEmoji = Observable params.iconEmoji or null\n\n  iconStyle = Observable ->\n    if iconEmoji()\n      \"\"\"\n        width: 18px;\n      \"\"\"\n    else\n      \"\"\"\n        background-image: url(#{iconURL()});\n        width: 18px;\n      \"\"\"\n\n  topIndex += 1\n  zIndex = Observable params.zIndex ? topIndex\n\n  element = WindowTemplate\n    iconStyle: iconStyle\n    iconEmoji: iconEmoji\n    title: title\n    menuBar: params.menuBar\n    content: params.content\n    class: ->\n      [\n        \"minimized\" if minimized()\n        \"maximized\" if maximized()\n      ]\n    close: ->\n      self.close()\n    minimize: ->\n      self.minimize()\n    maximize: ->\n      self.maximize()\n    restore: ->\n      self.restore()\n\n  styleBind(y, element, \"top\", \"px\")\n  styleBind(x, element, \"left\", \"px\")\n  styleBind(height, element, \"height\", \"px\")\n  styleBind(width, element, \"width\", \"px\")\n  styleBind(zIndex, element, \"zIndex\")\n\n  restore = ->\n    if prevX()?\n      x prevX()\n\n    if prevY()?\n      y prevY()\n\n    width prevWidth()\n    height prevHeight()\n\n    minimized false\n    maximized false\n\n    self.trigger \"resize\"\n\n  Object.assign self,\n    element: element\n    iconEmoji: iconEmoji\n    iconURL: iconURL\n    title: title\n    x: x\n    y: y\n    width: width\n    height: height\n    zIndex: zIndex\n    close: ->\n      # TODO: Allow prompt to cancel\n      # Maybe we count on people to override this method if they want\n      element.remove()\n      self.trigger \"close\"\n\n    savePosition: ->\n      if typeof x() is 'number'\n        prevX x()\n      if typeof y() is 'number'\n        prevY y()\n\n    saveSize: ->\n      prevWidth width()\n      prevHeight height()\n\n    maximized: maximized\n    maximize: ->\n      maximized.toggle()\n\n      if maximized()\n        self.savePosition()\n        self.saveSize()\n\n        width null\n        height null\n        x 0\n        y 0\n\n        self.trigger \"resize\"\n        self.trigger \"maximize\"\n      else\n        restore()\n\n    minimized: minimized\n    minimize: ->\n      minimized.toggle()\n\n      if minimized()\n        self.savePosition()\n        self.saveSize()\n\n        width null\n        height null\n\n        self.trigger \"resize\"\n        self.trigger \"minimize\"\n      else\n        restore()\n\n    restore: ->\n      restore()\n\n    raiseToTop: ->\n      raiseToTop self\n\n  element.view = self\n\n  return self\n\nstyleBind = (observable, element, attr, suffix=\"\") ->\n  update = (newValue) ->\n\n    if typeof newValue is \"string\"\n      element.style[attr] = newValue\n    else if newValue? and (newValue = parseInt newValue)?\n      element.style[attr] = \"#{newValue}#{suffix}\"\n    else\n      element.style[attr] = null\n\n  observable.observe update\n\n  update(observable())\n"},"data/templates/window.coffee":{"content":""},"data/templates/modal.coffee":{"content":""},"data/templates/progress.coffee":{"content":"module.exports =\n  value: 0.25\n  min: 0\n  max: 1\n"},"data/templates/table.coffee":{"content":""},"data/views/menu.coffee":{"content":"{Util} = require \"../../lib/ui/index\"\n\n{parseMenu} = Util\n\nmodule.exports =\n  items: parseMenu \"\"\"\n    Hello\n    \n  \"\"\"\n  handlers: { }\n"},"lib/jadelet.coffee":{"content":"# Testing simple Jadelet runtime\n\n# Pre-compile?\n# return a function that takes a context\n# the function can also compile meta-data like attribute-bindings etc, and warn\n# or error if they are not present\n\nObservable = require \"./observable\"\nforEach = Array::forEach\n\n# To clean up listeners we keep a map of DOM elements and what listeners are bound to them\n# when we dispose an element we must traverse its children and clean them up too\n# After we remove the listeners we must then remove the element from the map\nelementCleaners = new WeakMap\nelementRefCounts = new WeakMap\n\nretain = (element) ->\n  count = elementRefCounts.get(element) || 0\n  elementRefCounts.set(element, count + 1)\n  return\n\nrelease = (element) ->\n  count = elementRefCounts.get(element) || 0\n  count--\n\n  if count > 0\n    elementRefCounts.set(element, count)\n  else\n    elementRefCounts.delete element\n    dispose element\n  return\n\n# Disposing an element executes the cleanup for all it's children. If a child\n# element should be retained you must mark it explicitly to prevent its\n# observables from unbinding.\ndispose = (element) ->\n  # Recurse into children\n  children = element.children\n  if children?\n    forEach.call children, dispose\n\n  elementCleaners.get(element)?.forEach (cleaner) ->\n    cleaner()\n    elementCleaners.delete(element)\n    return\n  return\n\nattachCleaner = (element, cleaner) ->\n  if typeof cleaner != 'function'\n    throw new Error \"whoops\"\n\n  cleaners = elementCleaners.get(element)\n  if cleaners\n    cleaners.push cleaner\n  else\n    elementCleaners.set element, [cleaner]\n  return\n\n# Combined touch and animation events here even though it's sloppy it saves a few bytes\n# later we should put all the smarts about what is an event or not in the compiler\neventNames = /^on(touch|animation|transition)(start|iteration|move|end|cancel)$/\nisEvent = (name, element) ->\n  name.match(eventNames) or name of element\n\n# value is either a literal string or an object shaped\n# bind: stringKey\n# exceptions for id, class, and style. They are arrays of such strings\n# literals and binding objects\nobserveAttribute = (element, context, name, value) ->\n  switch name\n    when \"id\"\n      bindSplat element, context, value, (ids) ->\n        length = ids.length\n        if length\n          element.id = ids[length-1]\n        else\n          element.removeAttribute \"id\"\n        return\n    when \"class\"\n      bindSplat element, context, value, (classes) ->\n        className = classes.join(\" \")\n        if className\n          element.className = className\n        else\n          element.removeAttribute \"class\"\n        return\n    when \"style\"\n      bindSplat element, context, value, (styles) ->\n        # Remove any leftover styles\n        element.removeAttribute \"style\"\n        styles.forEach (style) ->\n          if isObject style\n            Object.assign element.style, style\n          else\n            element.setAttribute \"style\", style\n        return\n    when \"value\"\n      bindValue(element, value, context)\n    when \"checked\"\n      if value and isObject(value)\n        {bind} = value\n        element.onchange = ->\n          context[bind]? element.checked\n          return\n\n      bindObservable element, value, context, (newValue) ->\n        element.checked = newValue\n        return\n    else\n      # Handle click=@method\n      if isEvent(\"on#{name}\", element)\n        # It doesn't make sense for events to not be bound\n        bindEvent(element, name, value.bind, context)\n      else \n        bindObservable element, value, context, (newValue) ->\n          if newValue? and newValue != false\n            element.setAttribute name, newValue\n          else\n            element.removeAttribute name\n          return\n\n  return\n\n# To bind an observable precisely to the site where it is\n# and to be able to clean up we need to create a fresh\n# Observable stack. Since the observable re-computes\n# when any of its dependencies change it will refresh the update\n# with the new value. To clean up we release the dependencies of\n# our computed observable. We store the observables to clean up\n# on a map keyed by the element.\nbindObservable = (element, value, context, update) ->\n  # If the value is a simple string then simply set it and exit\n  # No point in creating an observable if it isn't a binding\n  if isString value\n    return update(value)\n  else if typeof value is 'function'\n    observable = Observable ->\n      update value.call context\n      return\n  else\n    {bind} = value\n    observable = Observable ->\n      update get context[bind], context\n      return\n\n  # return if no dependencies, no need to attach cleaners\n  if observable._observableDependencies.size is 0\n    return\n\n  # Release the observable's dependencies when this element is cleaned up\n  attachCleaner element, observable.releaseDependencies\n\n  return\n\nbindValue = (element, value, context) ->\n  # Because firing twice with the same value is idempotent just binding both\n  # oninput and onchange handles the widest range of inputs and browser\n  # inconsistencies.\n  if value and typeof value is \"object\"\n    {bind} = value\n    element.oninput = element.onchange = ->\n      context[bind]? element.value\n      return\n\n  bindObservable element, value, context, (newValue) ->\n    unless element.value is newValue\n      element.value = newValue\n    return\n\n  return\n\nbindEvent = (element, name, binding, context) ->\n  handler = context[binding]\n  if typeof handler is 'function'\n    element.addEventListener name, handler.bind(context)\n\n  return\n\nbindSplat = (element, context, sources, update) ->\n  bindObservable element, (-> splat sources, context), context, update\n\n  return\n\nobserveContent = (element, context, contentArray, namespace) ->\n  # Map the content array into into an elements array (can be more or less,\n  # essentially a flatmap) Keep track of observables, only update the proper\n  # places when observables change.\n\n  tracker = []\n  count = 0\n\n  contentArray.forEach (astNode, index) ->\n    # Track the child index this content starts on\n    tracker[index] = count\n\n    if Array.isArray(astNode)\n      element.appendChild render astNode, context, namespace\n      count++\n\n    else if isString astNode\n      element.appendChild document.createTextNode astNode\n      count++\n\n    # Content Binding\n    else if isObject(astNode)\n      # Total number of items added\n      # how many we need to remove on cleanup\n      length = previousLength = 0\n      # track element indices\n      # update and rebase index on change\n\n      bindObservable element, astNode, context, (value) ->\n        previousLength = length\n        pos = tracker[index]\n        beforeTarget = element.childNodes[pos+length]\n        toRelease = new Array(length)\n\n        # Remove previously added nodes\n        i = 0\n        while i < length\n          child = element.childNodes[pos]\n          element.removeChild child\n          toRelease[i] = child\n          i++\n\n        # Append New\n        length = append element, value, beforeTarget\n\n        # Relase after appending so if a node was re-added it won't hit zero\n        # in its refcount and be prematurely disposed\n        i = 0\n        while i < previousLength\n          child = toRelease[i]\n          release child\n          i++\n\n        # Rebase downstream indices\n        delta = length - previousLength\n        i = index+1\n        while i < tracker.length\n          tracker[i] += delta\n          i++\n\n        return\n\n      count += length\n    else\n      throw new Error \"oof\"\n    return\n\n  return\n\n# Append nodes to an element, return the total number appended\nappend = (element, item, beforeTarget) ->\n  if !item? # Skip nulls\n    return 0\n  else if Array.isArray(item)\n    return item.map (item) ->\n      append element, item, beforeTarget\n    .reduce (a, b) ->\n      a + b\n    , 0\n  else if item instanceof Node\n    retain item\n    element.insertBefore item, beforeTarget\n  else if (el = item.element) instanceof Node\n    retain el\n    element.insertBefore el, beforeTarget\n  else\n    element.insertBefore document.createTextNode(item), beforeTarget\n\n  return 1\n\nremove = (element, child) ->\n  element.removeChild(child)\n  release(child)\n\nisObject = (x) ->\n  typeof x is \"object\"\n\nisString = (x) ->\n  typeof x is \"string\"\n\nsplat = (sources, context) ->\n  sources.map (source) ->\n    if isString source\n      source\n    else\n      get context[source.bind], context\n  .reduce (a, b) ->\n    a.concat b\n  , []\n  .filter (x) -> x?\n\nget = (x, context) ->\n  if typeof x is 'function'\n    x.call(context)\n  else\n    x\n\nrender = (astNode, context={}, namespace) ->\n  [tag, attributes, children] = astNode\n\n  # This namespace is only for svg support though it may be expanded in the\n  # future. The idea is to set the namespace if the tag name is 'svg' and to\n  # pass that namespace down to all children of the tag. Other elements won't\n  # have a namespace and will render using the usual `createElement`.\n  if tag is \"svg\" and !namespace\n    namespace = \"http://www.w3.org/2000/svg\"\n\n  if namespace\n    element = document.createElementNS namespace, tag\n  else\n    element = document.createElement tag\n  # We populate the content first so that value binding for `select` tags\n  # works properly.\n  observeContent element, context, children, namespace\n  Object.keys(attributes).forEach (name) ->\n    observeAttribute element, context, name, attributes[name]\n    return\n\n  return element\n\nparser = require \"./jadelet-parser\"\n\nmodule.exports = Jadelet =\n  compile: (source, opts={}) ->\n    ast = Jadelet.parse(source)\n    runtime = opts.runtime or \"system.ui.Jadelet\"\n    exports = opts.exports or \"module.exports\"\n\n    \"\"\"\n      #{exports} = #{runtime}.exec(#{JSON.stringify(ast)});\n    \"\"\"\n  parse: parser.parse\n  parser: parser\n  exec: (ast) ->\n    if typeof ast is \"function\"\n      return ast\n\n    if typeof ast is \"string\"\n      ast = Jadelet.parse ast\n\n    return (context) ->\n      render ast, context\n  Observable: Observable\n  _elementCleaners: elementCleaners\n  dispose: dispose\n  retain: retain\n  release: release\n"},"lib/test/jadelet.coffee":{"content":"Observable = require \"../observable\"\n\nJadelet = require \"../jadelet\"\nparser = require \"../jadelet-parser\"\n\nsampleTemplate = \"\"\"\n  p\n    a(@click wat=@cool @butts)\n      @text\n      span Cool\n      @text2\n\"\"\"\n\nmakeTemplate = (src) ->\n  Jadelet.exec src\n\ndispatchEvent = (element, eventName, options={}) ->\n  element.dispatchEvent new Event eventName, options\n\n###\nAST is a tree of objects like:\n\n    [tag, attributes, children]\n\n###\n\ndescribe \"Jadelet Runtime\", ->\n  it \"should render\", ->\n    model = {\n      cool: \"radical\"\n      butts: -> \"yolo\"\n      text: Observable [\n        \"hollo world\"\n        \" \"\n        \"yo\"\n        \" \"\n        \"yo\"\n      ]\n      text2: Observable [\n        \"yo wat\"\n      ]\n    }\n    \n    ast = parser.parse sampleTemplate\n\n    p = Jadelet.exec(ast)(model)\n    assert.equal p.textContent, \"hollo world yo yoCoolyo wat\"\n\n    model.text \"yolo \"\n    assert.equal p.textContent, \"yolo Coolyo wat\"\n\n    model.text2 \"rad\"\n    assert.equal p.textContent, \"yolo Coolrad\"\n\n  it \"should compile strings\", ->\n    template = Jadelet.exec \"\"\"\n      h1 yolo\n    \"\"\"\n\n    el = template()\n    assert.equal el.textContent, \"yolo\"\n\n  it \"should return functions passed to exec\", ->\n    template = Jadelet.exec Jadelet.exec \"\"\"\n      h1 yolo\n    \"\"\"\n\n    el = template()\n    assert.equal el.textContent, \"yolo\"\n\ndescribe \"Attributes\", ->\n  it \"should bind to the property with the same name\", (done) ->\n    template = makeTemplate \"\"\"\n      button(@click) Test\n    \"\"\"\n\n    model =\n      click: ->\n        done()\n\n    button = template(model)\n    button.click()\n\n  it \"should work with multiple attributes\", ->\n    template = makeTemplate \"\"\"\n      button(before=\"low\" @type middle=\"mid\" @yolo after=\"hi\") Test\n    \"\"\"\n\n    model =\n      type: \"submit\"\n      yolo: \"Hello\"\n\n    button = template(model)\n    assert.equal button.getAttribute(\"type\"), \"submit\"\n    assert.equal button.getAttribute(\"yolo\"), \"Hello\"\n\n  it \"shoud not be present when false or undefined\", ->\n    template = makeTemplate \"\"\"\n      button(@disabled) Test\n    \"\"\"\n\n    model =\n      disabled: Observable false\n\n    button = template(model)\n    assert.equal button.getAttribute(\"disabled\"), undefined\n\n    model.disabled true\n    assert.equal button.getAttribute(\"disabled\"), \"true\"\n\ndescribe \"Checkbox\", ->\n  template = makeTemplate \"\"\"\n    input(type='checkbox' checked=@checked)\n  \"\"\"\n\n  it \"should be checked\", ->\n    model =\n      checked: true\n\n    input = template(model)\n    assert.equal input.checked, true\n\n  it \"should not be checked\", ->\n    model =\n      checked: false\n\n    input = template(model)\n    assert.equal input.checked, false\n\n  it \"should track changes in the observable\", ->\n    model =\n      checked: Observable false\n\n    input = template(model)\n\n    assert.equal input.checked, false, \"Should not be checked\"\n    model.checked true\n    assert.equal input.checked, true, \"Should be checked\"\n    model.checked false\n    assert.equal input.checked, false, \"Should not be checked again\"\n\n    input.checked = true\n    input.onchange()\n    assert.equal model.checked(), true, \"Value of observable should be checked when input changes\"\n\n    input.checked = false\n    input.onchange()\n    assert.equal model.checked(), false, \"Value of observable should be unchecked when input changes\"\n\ndescribe \"Classes\", ->\n  it \"should be bound in the context of the object\", ->\n    template = makeTemplate \"\"\"\n      .duder(class=@classes)\n    \"\"\"\n\n    model =\n      classes: ->\n        @myClass()\n      myClass: ->\n        \"hats\"\n\n    element = template(model)\n    assert element.classList.contains \"hats\"\n\n  it \"should handle observable arrays\", ->\n    template = makeTemplate \"\"\"\n      div(class=@classes)\n    \"\"\"\n\n    model =\n      classes: Observable [\"a\", \"b\"]\n\n    element = template(model)\n\n    assert element.classList.contains \"a\"\n    assert element.classList.contains \"b\"\n\n  it \"should merge with literal classes\", ->\n    template = makeTemplate \"\"\"\n      .duder(class=@classes)\n    \"\"\"\n\n    model =\n      classes: Observable [\"a\", \"b\"]\n\n    element = template(model)\n\n    assert element.classList.contains \"a\"\n    assert element.classList.contains \"b\"\n    assert element.classList.contains \"duder\"\n\n  it \"should not write `undefined` to the class\", ->\n    template = makeTemplate \"\"\"\n      .duder(class=@undefined)\n    \"\"\"\n\n    model =\n      undefined: undefined\n\n    element = template(model)\n\n    assert !element.classList.contains(\"undefined\")\n\n  it \"should not have the class attribute if no classes\", ->\n    template = makeTemplate \"\"\"\n      div(class=@undefined)\n    \"\"\"\n\n    model =\n      undefined: undefined\n\n    element = template(model)\n\n    assert !element.hasAttribute(\"class\")\n\ndescribe \"Computed\", ->\n  template = makeTemplate \"\"\"\n    div\n      h2 @name\n      input(value=@first)\n      input(value=@last)\n  \"\"\"\n\n  it \"should compute automatically with the correct scope\", ->\n    model =\n      name: ->\n        @first() + \" \" + @last()\n      first: Observable(\"Mr.\")\n      last: Observable(\"Doberman\")\n\n    element = template(model)\n\n    assert.equal element.querySelector(\"h2\").textContent, \"Mr. Doberman\"\n\n  it \"should work on special bindings\", ->\n    template = makeTemplate \"\"\"\n      input(type='checkbox' checked=@checked)\n    \"\"\"\n    model =\n      checked: ->\n        @name() is \"Duder\"\n      name: Observable \"Mang\"\n\n    element = template(model)\n\n    assert.equal element.checked, false\n    model.name \"Duder\"\n    assert.equal element.checked, true\n\ndescribe \"Events\", ->\n  it \"should bind click to the object context\", ->\n    template = makeTemplate \"\"\"\n      button(click=@click)\n    \"\"\"\n\n    result = null\n\n    model =\n      name: Observable \"Foobert\"\n      click: ->\n        result = @name()\n\n    button = template(model)\n    assert.equal result, null\n    button.click()\n    assert.equal result, \"Foobert\"\n\n  it \"should not error on non-functions when binding events\", ->\n    template = makeTemplate \"\"\"\n      button(@mouseenter @mouseleave)\n    \"\"\"\n\n    model = {}\n    button = template(model)\n\n    dispatchEvent button, \"mouseenter\"\n    dispatchEvent button, \"mouseleave\"\n\n    return\n\n  it \"doesn't late bind event functions\", ->\n    template = makeTemplate \"\"\"\n      button(@click)\n    \"\"\"\n\n    model = {}\n    button = template(model)\n    \n    called = false\n    model.click = ->\n      called = true\n\n    dispatchEvent button, \"click\"\n    assert !called\n\n  it \"should bind mouseenter and mouseleave events\", ->\n    template = makeTemplate \"\"\"\n      button(@mouseenter @mouseleave)\n    \"\"\"\n\n    result = null\n\n    model =\n      mouseenter: ->\n        result = 1\n      mouseleave: ->\n        result = 2\n\n    button = template(model)\n\n    assert.equal result, null\n    dispatchEvent button, \"mouseenter\"\n    assert.equal result, 1\n    dispatchEvent button, \"mouseleave\"\n    assert.equal result, 2\n\n  it \"shoud handle all touch events\", ->\n    template = makeTemplate \"\"\"\n      canvas(@touchstart @touchmove @touchend @touchcancel)\n    \"\"\"\n\n    called = 0\n    eventFn = ->\n      called += 1\n\n    model =\n      touchcancel: eventFn\n      touchstart: eventFn\n      touchmove: eventFn\n      touchend: eventFn\n\n    canvas = template(model)\n    assert.equal called, 0\n\n    dispatchEvent canvas, \"touchstart\"\n    assert.equal called, 1\n\n    dispatchEvent canvas, \"touchmove\"\n    assert.equal called, 2\n\n    dispatchEvent canvas, \"touchend\"\n    assert.equal called, 3\n\n    dispatchEvent canvas, \"touchcancel\"\n    assert.equal called, 4\n\n  it \"shoud handle all animation events\", ->\n    template = makeTemplate \"\"\"\n      div(@animationstart @animationiteration @animationend @transitionend)\n    \"\"\"\n\n    called = 0\n    eventFn = ->\n      called += 1\n\n    model =\n      animationstart: eventFn\n      animationend: eventFn\n      animationiteration: eventFn\n      transitionend: eventFn\n\n    canvas = template(model)\n    assert.equal called, 0\n\n    dispatchEvent canvas, \"animationstart\"\n    assert.equal called, 1\n\n    dispatchEvent canvas, \"animationiteration\"\n    assert.equal called, 2\n\n    dispatchEvent canvas, \"animationend\"\n    assert.equal called, 3\n\n    dispatchEvent canvas, \"transitionend\"\n    assert.equal called, 4\n\ndescribe \"ids\", ->\n  it \"should work with simple cases\", ->\n    template = makeTemplate \"\"\"\n      h1#rad\n    \"\"\"\n    element = template()\n\n    assert.equal element.id, \"rad\"\n\n  it \"should be ok if empty\", ->\n    # TODO: Rethink this test case\n    template = makeTemplate \"\"\"\n      h1(id)\n    \"\"\"\n    element = template()\n\n    assert.equal element.id, \"\"\n\n  it \"should use the last valid id when multiple exist\", ->\n    template = makeTemplate \"\"\"\n      h1#rad(id=\"cool\")\n    \"\"\"\n\n    element = template()\n    assert.equal element.id, \"cool\"\n\n  it \"should update the id if it's observable\", ->\n    template = makeTemplate \"\"\"\n      h1(@id)\n    \"\"\"\n\n    model =\n      id: Observable \"cool\"\n\n    element = template(model)\n    assert.equal element.id, \"cool\"\n    model.id \"wat\"\n    assert.equal element.id, \"wat\"\n\n  it \"should update the last existing id if mixing literals and observables\", ->\n    template = makeTemplate \"\"\"\n      h1#wat(@id id=@other)\n    \"\"\"\n\n    model =\n      id: Observable \"cool\"\n      other: Observable \"other\"\n\n    element = template(model)\n    assert.equal element.id, \"other\"\n    model.other null\n    assert.equal element.id, \"cool\"\n    model.id null\n    assert.equal element.id, \"wat\"\n\n  it \"should be bound in the context of the object\", ->\n    template = makeTemplate \"\"\"\n      .duder(@id)\n    \"\"\"\n\n    model =\n      id: ->\n        @myId()\n      myId: ->\n        \"hats\"\n\n    element = template(model)\n    assert.equal element.id, \"hats\"\n\ndescribe \"input\", ->\n  template = makeTemplate \"\"\"\n    input(type=\"text\" @value)\n  \"\"\"\n\n  it \"should maintain caret position\", ->\n    model =\n      value: Observable \"yolo\"\n\n    input = template(model)\n\n    input.focus()\n    input.selectionStart = 2\n\n    assert.equal input.selectionStart, 2\n\n    input.value = \"yo2lo\"\n    input.selectionStart = 3\n\n    assert.equal input.selectionStart, 3\n\n    input.onchange()\n\n    assert.equal input.selectionStart, 3\n\n    # TODO: Seems reasonable... think it through\n    model.value \"radical\"\n    assert.equal input.selectionStart, 7\n\n  it \"should send updated value\", ->\n    model =\n      value: Observable 5\n\n    input = template(model)\n\n    input.value = 50\n    input.onchange()\n\n    # Inputs only return strings as values\n    assert.equal model.value(), \"50\"\n\ndescribe \"multiple bindings\", ->\n  template = makeTemplate \"\"\"\n    div\n      input(type=\"text\" @value)\n      select(value=@value)\n        @options\n      hr\n      input(type=\"range\" @value min=\"1\" @max)\n      hr\n      progress(@value @max)\n  \"\"\"\n  model =\n    max: 10\n    value: Observable 5\n    options: ->\n      [1..@max].map (v) ->\n        o = document.createElement \"option\"\n        o.value = v\n        o.textContent = v\n\n        return o\n\n  it \"should be initialized to the right values\", ->\n    element = template(model)\n\n    select = element.querySelector(\"select\")\n\n    [\"text\", \"range\"].forEach (type) ->\n      assert.equal element.querySelector(\"input[type='#{type}']\").value, 5\n\n    assert.equal element.querySelector(\"progress\").value, 5\n    assert.equal select.value, 5\n\n    [2, 7, 3, 8].forEach (value) ->\n      model.value value\n\n      # NOTE: This is how we're simulating an onchange event\n      # TODO select element value binding\n      # select.selectedIndex = value - 1\n      # select.onchange()\n\n      assert.equal select.value, value\n\n      [\"text\", \"range\"].forEach (type) ->\n        assert.equal element.querySelector(\"input[type='#{type}']\").value, value\n\n      assert.equal element.querySelector(\"progress\").value, value\n\ndescribe \"Primitives\", ->\n  template = makeTemplate \"\"\"\n    div\n      @string\n      @boolean\n      @number\n      @array\n  \"\"\"\n\n  it \"should render correctly\", ->\n    model =\n      string: \"hey\"\n      boolean: true\n      number: 5\n      array: [1, true, \"e\"]\n\n    element = template(model)\n    assert.equal element.textContent, \"heytrue51truee\"\n\ndescribe \"Random tags\", ->\n  template = makeTemplate \"\"\"\n    div\n      duder\n      yolo(radical=\"true\")\n      sandwiches(type=@type)\n  \"\"\"\n  model =\n    type: Observable \"ham\"\n\n  it \"should be have those tags and atrtibutes\", ->\n    element = template(model)\n\n    assert element.querySelector \"duder\"\n    assert element.querySelector(\"yolo\").getAttribute(\"radical\")\n    assert.equal element.querySelector(\"sandwiches\").getAttribute(\"type\"), \"ham\"\n\n  it \"should reflect changes in observables\", ->\n    element = template(model)\n\n    assert.equal element.querySelector(\"sandwiches\").getAttribute(\"type\"), \"ham\"\n    model.type \"pastrami\"\n    assert.equal element.querySelector(\"sandwiches\").getAttribute(\"type\"), \"pastrami\"\n\ndescribe \"retain\", ->\n  it \"should keep elements bound even when reused in the DOM\", ->\n    CanvasTemplate = makeTemplate \"\"\"\n      canvas(@width @height)\n    \"\"\"\n\n    EditorTemplate = makeTemplate \"\"\"\n      editor\n        @title\n        @canvas\n    \"\"\"\n\n    canvasModel =\n      width: Observable 64\n      height: Observable 64\n\n    canvasElement = CanvasTemplate canvasModel\n    Jadelet.retain canvasElement\n\n    editorModel =\n      title: Observable \"yo\"\n      canvas: canvasElement\n\n    editorElement = EditorTemplate editorModel\n\n    assert.equal canvasElement.getAttribute('height'), 64\n\n    canvasModel.height 48\n    assert.equal canvasElement.getAttribute('height'), 48\n\n    editorModel.title \"lo\"\n\n    canvasModel.height 32\n    assert.equal canvasElement.getAttribute('height'), 32\n\n    Jadelet.release canvasElement\n\ndescribe \"Styles\", ->\n  it \"should be bound in the context of the object\", ->\n    template = makeTemplate \"\"\"\n      duder(@style)\n    \"\"\"\n\n    model =\n      style: ->\n        @myStyle()\n      myStyle: ->\n        backgroundColor: \"red\"\n\n    element = template(model)\n    assert.equal element.style.backgroundColor, \"red\"\n\n  it \"should remove styles when observables change\", ->\n    template = makeTemplate \"\"\"\n      duder(@style)\n    \"\"\"\n\n    model =\n      style: Observable\n        backgroundColor: \"red\"\n\n    element = template(model)\n    assert.equal element.style.backgroundColor, \"red\"\n\n    model.style\n      color: \"green\"\n    assert.equal element.style.backgroundColor, \"\"\n    assert.equal element.style.color, \"green\"\n\n  it \"should merge observable arrays of style mappings\", ->\n    template = makeTemplate \"\"\"\n      div(style=@styles)\n    \"\"\"\n\n    model =\n      styles: Observable [{\n        lineHeight: \"1.5em\"\n        height: \"30px\"\n        width: \"40px\"\n      }, {\n        color: \"green\"\n        lineHeight: null\n        height: undefined\n        width: \"50px\"\n      }]\n\n    element = template(model)\n\n    assert.equal element.style.color, \"green\"\n    assert.equal element.style.height, \"30px\"\n    assert.equal element.style.lineHeight, \"\"\n    assert.equal element.style.width, \"50px\"\n\n  it \"should work with plain style strings\", ->\n    template = makeTemplate \"\"\"\n      div(@style)\n    \"\"\"\n\n    model =\n      style: \"\"\"\n        background-color: orange;\n        color: blue;\n      \"\"\"\n\n    element = template(model)\n\n    assert.equal element.style.color, \"blue\"\n    assert.equal element.style.backgroundColor, \"orange\"\n\n  it \"should mix and match plain strings and objects\", ->\n    template = makeTemplate \"\"\"\n      div(style=@rekt style=@styleString style=@styleObject)\n    \"\"\"\n\n    model =\n      rekt:\n        height: \"20px\"\n        color: \"green\"\n\n      styleString:  \"\"\"\n        background-color: orange;\n        color: blue;\n      \"\"\"\n\n      styleObject: ->\n        color: \"black\"\n        width: \"50px\"\n\n    element = template(model)\n\n    assert.equal element.style.backgroundColor, \"orange\"\n    assert.equal element.style.color, \"black\"\n    assert.equal element.style.height, \"\" # Got crushed when writing the string style\n    assert.equal element.style.width, \"50px\"\n\ndescribe \"content arrays\", ->\n  it \"should render and update items\", ->\n    template = makeTemplate \"\"\"\n      div\n        @items\n    \"\"\"\n\n    model =\n      count: Observable 3\n      items: ->\n        c = @count()\n        r = []\n        i = 0\n        while i < c\n          i++\n          r.push document.createElement \"p\"\n\n        return r\n\n    element = template(model)\n\n    assert.equal element.children.length, 3\n    model.count 5\n    assert.equal element.children.length, 5\n\n  it \"should keep them in order and not re-render excessively\", ->\n    template = makeTemplate \"\"\"\n      div\n        @items\n        @otherItems\n        hr\n    \"\"\"\n\n    model =\n      count: Observable 3\n      otherCount: Observable 2\n      items: ->\n        c = @count()\n        r = []\n        i = 0\n        while i < c\n          i++\n          r.push document.createElement \"p\"\n\n        return r\n      otherItems: ->\n        c = @otherCount()\n        r = []\n        i = 0\n        while i < c\n          i++\n          r.push document.createElement \"a\"\n\n        return r\n\n    element = template(model)\n\n    assert.equal element.querySelectorAll('p').length, 3\n    assert.equal element.querySelectorAll('a').length, 2\n    firstA = element.children[3]\n\n    model.count 0\n\n    assert.equal element.querySelectorAll('p').length, 0\n    assert.equal element.querySelectorAll('a').length, 2\n\n    # Node is maintained\n    assert.equal firstA, element.children[0]\n\n    model.count 7\n\n    assert.equal element.querySelectorAll('p').length, 7\n    assert.equal element.querySelectorAll('a').length, 2\n\n    # Node is maintained\n    assert.equal firstA, element.children[7]\n\n    model.otherCount 1\n    # Node is re-created when dependency changes in this circumstance\n    # up to the model to cache\n    assert.notEqual firstA, element.children[7]\n\ndescribe \"subrender\", ->\n  describe \"rendering simple text\", ->\n    template = makeTemplate \"\"\"\n      span.count @count\n    \"\"\"\n\n    it \"should render numbers as strings\", ->\n      model =\n        count: 5\n\n      element = template(model)\n      assert.equal element.textContent, \"5\"\n\n    it \"should update when observable changes\", ->\n      model =\n        count: Observable 5\n\n      element = template(model)\n      assert.equal element.textContent, \"5\"\n      model.count 2\n      assert.equal element.textContent, \"2\"\n\n  describe \"with root node\", ->\n    template = makeTemplate \"\"\"\n      div\n        @generateItem\n    \"\"\"\n\n    it \"should render elements in-line\", ->\n      model =\n        generateItem: ->\n          document.createElement(\"li\")\n\n      element = template(model)\n      assert element.querySelector(\"li\")\n\n    it \"should render lists of nodes\", ->\n      model =\n        generateItem: ->\n          [\n            document.createElement(\"li\")\n            document.createElement(\"li\")\n            document.createElement(\"p\")\n          ]\n\n      element = template(model)\n      assert element.querySelectorAll(\"li\").length, 2\n      assert element.querySelectorAll(\"p\").length, 1\n\n    it \"should work with a node with children\", ->\n      model =\n        generateItem: ->\n          div = document.createElement \"div\"\n\n          div.innerHTML = \"<p>Yo</p><ol><li>Yolo</li><li>Broheim</li></ol>\"\n\n          div\n\n      element = template(model)\n\n      assert element.querySelectorAll(\"li\").length, 2\n      assert element.querySelectorAll(\"p\").length, 1\n      assert element.querySelectorAll(\"ol\").length, 1\n\n    it \"should work with observables\", ->\n      model =\n        name: Observable \"wat\"\n        generateItem: ->\n          item = document.createElement(\"li\")\n\n          item.textContent = @name()\n\n          item\n\n      element = template(model)\n\n      assert.equal element.querySelectorAll(\"li\").length, 1\n      assert.equal element.querySelector(\"li\").textContent, \"wat\"\n      model.name \"yo\"\n      assert.equal element.querySelector(\"li\").textContent, \"yo\"\n\n  describe \"rendering subtemplates\", ->\n    describe \"mixing and matching\", ->\n      subtemplate = makeTemplate \"\"\"\n        span Hello\n      \"\"\"\n      template = makeTemplate \"\"\"\n        div\n          a Radical\n          |\n          @subtemplate\n          |\n          @observable\n          @nullable\n      \"\"\"\n\n      it \"shouldn't lose any nodes\", ->\n        model =\n          observable: Observable \"wat\"\n          subtemplate: subtemplate\n          nullable: null\n\n        element = template(model)\n        assert.equal element.textContent, \"Radical\\nHello\\nwat\"\n        model.observable \"duder\"\n        assert.equal element.textContent, \"Radical\\nHello\\nduder\"\n\n    describe \"mapping array to subtemplates\", ->\n      template = makeTemplate \"\"\"\n        table\n          @rows\n      \"\"\"\n\n      it \"should render subtemplates\", ->\n        model =\n          rows: -> [\n            {text: \"Wat\"}\n            {text: \"is\"}\n            {text: \"up\"}\n          ].map @subtemplate\n          subtemplate: makeTemplate \"\"\"\n            tr\n              td @text\n          \"\"\"\n\n        element = template(model)\n        assert.equal element.querySelectorAll(\"tr\").length, 3\n\n      it \"should maintain observables in subtemplates\", ->\n        data = Observable [\n          {text: Observable \"Wat\"}\n          {text: Observable \"is\"}\n          {text: Observable \"up\"}\n        ]\n        model =\n          rows: ->\n            data.map @subtemplate\n          subtemplate: makeTemplate \"\"\"\n            tr\n              td @text\n          \"\"\"\n\n        element = template(model)\n        assert.equal element.querySelectorAll(\"tr\").length, 3\n        assert.equal element.querySelector(\"td\").textContent, \"Wat\"\n\n        data()[0].text \"yo\"\n\n        assert.equal element.querySelector(\"td\").textContent, \"yo\"\n\n        data.push text: Observable(\"dude\")\n\n        assert.equal element.querySelectorAll(\"tr\").length, 4\n        assert.equal element.querySelector(\"td\").textContent, \"yo\"\n\n        data()[0].text \"holla\"\n        assert.equal element.querySelector(\"td\").textContent, \"holla\"\n\ndescribe \"element properties\", ->\n  it \"should use the element property of objects rendered\", ->\n    src = \"\"\"\n      ul\n        @a\n        @b\n    \"\"\"\n    template = makeTemplate src\n\n    element = template\n      a:\n        element: document.createElement 'a'\n      b:\n        element: document.createElement 'b'\n\n    assert element.querySelector(\"a\")\n    assert element.querySelector(\"b\")\n    assert !element.querySelector(\"c\")\n\n# This test captures a bug where caching elements and appending to a list\n# caused the element Observables to be disposed because they were released\n# before being re-added and the observers were cleaned up.\ndescribe \"cached retains\", ->\n  it \"should not release elements that are consistent render to render\", ->\n    Container = makeTemplate \"\"\"\n      div\n        @elements\n    \"\"\"\n    Item = makeTemplate \"\"\"\n      input(@value)\n    \"\"\"\n\n    ItemView = (i) ->\n      view = cache.get(i)\n      if view\n        return view\n\n      item =\n        value: Observable(i)\n\n      view =\n        item: item\n        element: Item item\n\n      cache.set(i, view)\n      return view\n\n    # Cache of item Views\n    cache = new Map\n    itemViews = [0...3].map ItemView\n\n    containerView =\n      elements: Observable itemViews\n\n    element = Container containerView\n\n    assert.equal element.children.length, 3\n    containerView.elements()[0].item.value 100\n    assert.equal element.children[0].value, 100\n\n    containerView.elements.push ItemView 3\n    assert.equal element.children.length, 4\n    containerView.elements()[0].item.value 200\n    # This will fail to set if we've removed the observers\n    assert.equal element.children[0].value, 200\n\ndescribe \"text\", ->\n  it \"should preserve line breaks\", ->\n    src = \"\"\"\n      p\n        | hello I am a cool paragraph\n        | with lots of text and stuff\n        | ain't it rad?\n    \"\"\"\n    template = makeTemplate src\n\n    element = template()\n  \n    assert.equal element.textContent, \"\"\"\n      hello I am a cool paragraph\n      with lots of text and stuff\n      ain't it rad?\\n\n    \"\"\"\n\ndescribe \"svg\", ->\n  it \"should render svg\", ->\n    src = \"\"\"\n      section\n        h2 svg test\n        svg(width=100 height=100)\n          circle(cx=80 cy=80 r=30 fill=\"red\")\n        p awesome\n    \"\"\"\n\n    template = makeTemplate src\n    element = template()\n\n    assert.equal element.querySelector('svg').namespaceURI, \"http://www.w3.org/2000/svg\"\n\ndescribe \"indentation\", ->\n  it \"should work with somewhat flexible indentation for ease of use with\n    template strings in js\", ->\n      indentedTemplate1 = \"\"\"\n        p\n                a(@click) Cool\n      \"\"\"\n\n      indentedTemplate2 = indentedTemplate1.replace(/^/, \"      \")\n\n      T1 = makeTemplate indentedTemplate1\n      T2 = makeTemplate indentedTemplate2\n\n      el = T1()\n      assert.equal el.querySelector('a').textContent, \"Cool\"\n\n      el = T2()\n      assert.equal el.querySelector('a').textContent, \"Cool\"\n\ndescribe \"weird cases\", ->\n  it.skip \"should handle weird templates\", ->\n    makeTemplate '''\n      .palette\n        .primary.color\n          - style = ->\n            - c = editor.activeColor()\n            - \"background-color: #{c}\"\n          input(type=\"color\" value=@activeColor style=@activeColorStyle)\n\n        @swatchElements\n        @opacityElement\n    '''\n"},"lib/test/indent-parse.coffee":{"content":""},"lib/jadelet-parser.hera":{"content":"Template\r\n  __? Line* ->\r\n    var top = a => a[a.length-1];\r\n \r\n    function reduceLines(lines) {\r\n      var depth = 0;\r\n      var stack = [[]];\r\n      var firstIndent = 0;\r\n\r\n      lines.forEach( ([indent, line]) => {\r\n        if (firstIndent === 0 && indent > depth + 1) {\r\n          firstIndent = indent - 1;\r\n        }\r\n        indent = indent > firstIndent ? indent - firstIndent : indent;\r\n\r\n        if (Array.isArray(line)) {\r\n          line[1] = collectAttributes(line[1])\r\n        }\r\n\r\n        if (depth+1 === indent) {\r\n          // We're adding to the content of the last element in the current stack\r\n          stack.push(top(top(stack))[2])\r\n        } else if ( indent > depth) {\r\n          throw new Error(\"Indented too far\")\r\n        } else if (indent < depth) {\r\n          stack = stack.slice(0, indent + 1)\r\n        }\r\n\r\n        depth = indent\r\n        top(stack).push(line)\r\n      })\r\n  \r\n      return stack[0]\r\n    }\r\n\r\n    function collectAttributes(attributesArray) {\r\n      return attributesArray.reduce((o, [key, value]) => {\r\n        if (key === \"id\" || key === \"class\" || key === \"style\") {\r\n          var p = o[key] || (o[key] = [])\r\n          p.push(value)\r\n        } else {\r\n          o[key] = value\r\n        }\r\n        return o\r\n      }, {})\r\n    }\r\n\r\n    function pretty(lines) {\r\n      return lines.map(line =>\r\n        JSON.stringify(line)\r\n      )\r\n    }\r\n\r\n    var reduced = reduceLines($2);\r\n\r\n    if (reduced.length != 1) {\r\n      throw new Error(\"Must have exactly one root node.\");\r\n    }\r\n\r\n    return reduced[0];\r\n\r\nLine\r\n  Indent LineBody EOS -> [1, 2]\r\n\r\nLineBody\r\n  Tag DeprecatedEquals? _ RestOfLine ->\r\n    $1[2].push($4)\r\n    return $1\r\n  Tag _? -> 1\r\n  \"|\" \" \"? RestOfLine ->\r\n    return $3 + \"\\n\";\r\n  (DeprecatedEquals _)? RestOfLine -> 2\r\n\r\nRestOfLine\r\n  /[^\\n\\r]*/ ->\r\n    // TODO: Handle runs of text with bound content inside\r\n    if ($0.slice(0,1) === \"@\") {\r\n      return {\r\n        bind: $0.slice(1)\r\n      }\r\n    } else {\r\n      return $0\r\n    }\r\n\r\nDeprecatedEquals\r\n  \"=\" ->\r\n    console.warn(\"'= <content>' is deprecated, you can remove the '=' without issue.\")\r\n\r\nTag\r\n  TagName OptionalIds OptionalClasses OptionalAttributes ->\r\n    return [\r\n      $1,\r\n      $2.concat($3, $4),\r\n      [],\r\n    ]\r\n  Ids OptionalClasses OptionalAttributes ->\r\n    return [\r\n      \"div\",\r\n      $1.concat($2, $3),\r\n      [],\r\n    ]\r\n  Classes OptionalAttributes ->\r\n    return [\r\n      \"div\",\r\n      $1.concat($2),\r\n      [],\r\n    ]\r\n\r\nOptionalClasses\r\n  Classes\r\n  \"\" ->\r\n    return []\r\n\r\nClasses\r\n  Class+\r\n\r\nClass\r\n  \".\" Identifier -> \r\n    return [\"class\", $2]\r\n  \".\" !Identifier ->\r\n    throw \"Expected a class name\"\r\n  IdError\r\n\r\nOptionalIds\r\n  Ids? ->\r\n    return $1 || []\r\n\r\nIds\r\n  Id ->\r\n    return [ $1 ]\r\n\r\nId\r\n  \"#\" Identifier ->\r\n    return [\"id\", $2]\r\n  \"#\" !Identifier ->\r\n    throw \"Expected an id name\"\r\n\r\nIdError\r\n  \"#\" ->\r\n    throw \"Ids must appear before classes and attributes. Elements can only have one id.\"\r\n\r\nClassError\r\n  \".\" ->\r\n    throw \"Classes cannot appear after attributes.\"\r\n\r\nTagName\r\n  Identifier\r\n\r\nOptionalAttributes\r\n  \"(\" __? Attribute+ \")\" IdError? ClassError? ->\r\n    return $3\r\n  \"(\" ->\r\n    throw \"Invalid attributes\"\r\n  \"\" ->\r\n    return []\r\n\r\nAttribute\r\n  AtIdentifier __? ->\r\n    return [$1.bind, $1]\r\n  EqBinding __? -> 1\r\n  Identifier __? ->\r\n    return [$1, \"\"]\r\n\r\nAtIdentifier\r\n  \"@\" Identifier -> \r\n    return {\r\n      bind: $2\r\n    }\r\n\r\nEqBinding\r\n  Identifier \"=\" ( AtIdentifier / Value ) -> [1, 3]\r\n\r\nIdentifier\r\n  /[a-zA-Z][a-zA-Z0-9-]*/\r\n\r\nIndent\r\n  ( \"  \" / \"\\t\" )* ->\r\n    return $1.length\r\n\r\n_\r\n  /[ \\t]+/\r\n\r\n__\r\n  (/[ \\t]/ / EOL)+\r\n\r\nValue\r\n  \"\\\"\" DoubleStringCharacter* \"\\\"\" ->\r\n    return $2.join(\"\")\r\n  \"'\" SingleStringCharacter* \"'\" ->\r\n    return $2.join(\"\")\r\n  Number\r\n\r\nDoubleStringCharacter\r\n  !(\"\\\"\" / \"\\\\\") /./ -> 2\r\n  \"\\\\\" EscapeSequence -> 2\r\n\r\nSingleStringCharacter\r\n  !(\"'\" / \"\\\\\") /./ -> 2\r\n  \"\\\\\" EscapeSequence -> 2\r\n\r\nEscapeSequence\r\n  \"'\"\r\n  \"\\\"\"\r\n  \"\\\\\"\r\n  /./  ->\r\n    return \"\\\\\" + $0\r\n\r\nNumber\r\n  /-?[0-9]+\\.[0-9]+/\r\n  /-?[0-9]+/\r\n\r\nEOS\r\n  (_? EOL)+ _ EOF\r\n  (_? EOL)+\r\n  EOF\r\n\r\nEOL\r\n  \"\\r\\n\"\r\n  \"\\n\"\r\n  \"\\r\"\r\n\r\nEOF\r\n  !/[\\s\\S]/\r\n"},"data/templates/samples/test-form.jadelet.coffee":{"content":""},"lib/test/assert.coffee":{"content":""},"templates/cancel-button.jadelet":{"content":"button(click=@cancel) Cancel\n"},"lib/observable.coffee":{"content":"###\r\nObservable\r\n==========\r\n\r\n`Observable` allows for observing arrays, functions, and objects.\r\n\r\nFunction dependencies are automagically observed.\r\n\r\nStandard array methods are proxied through to the underlying array.\r\n\r\n###\r\n\r\n\"use strict\"\r\n\r\nmodule.exports = Observable = (value, context) ->\r\n\r\n  # Return the object if it is already an observable object.\r\n  return value if typeof value?.observe is \"function\"\r\n\r\n  # Maintain a set of listeners to observe changes and provide a helper to notify each observer.\r\n  listeners = []\r\n  notify = (newValue) ->\r\n    self._value = newValue\r\n    copy(listeners).forEach (listener) ->\r\n      listener(newValue)\r\n\r\n  # If `value` is a function compute dependencies and listen to observables that it depends on.\r\n  if typeof value is 'function'\r\n    fn = value\r\n\r\n    # Our return function is a function that holds only a cached value which is updated when it's dependencies change.\r\n    # The `magicDependency` call is so other functions can depend on this computed function the same way we depend on other types of observables.\r\n    self = ->\r\n      # Automagic dependency observation\r\n      magicDependency(self)\r\n\r\n      return value\r\n\r\n    # We expose releaseDependencies so that\r\n    self.releaseDependencies = ->\r\n      self._observableDependencies?.forEach (observable) ->\r\n        observable.stopObserving changed\r\n\r\n    # We need to recompute our dependencies whenever any observable value that our function depends on changes. We keep a set\r\n    # of observables (so we don't needlessly recompute the same ones multiple times). When a dependency changes we recompute\r\n    # the new set of dependencies and unsubscribe from the old set.\r\n    changed = ->\r\n      observableDependencies = new Set\r\n      global.OBSERVABLE_ROOT_HACK.push(observableDependencies)\r\n      try\r\n        value = fn.call(context)\r\n      finally\r\n        global.OBSERVABLE_ROOT_HACK.pop()\r\n\r\n      self.releaseDependencies()\r\n      self._observableDependencies = observableDependencies\r\n      observableDependencies.forEach (observable) ->\r\n        observable.observe changed\r\n\r\n      notify(value)\r\n\r\n    changed()\r\n\r\n  else\r\n    # When called with zero arguments it is treated as a getter. \r\n    # When called with one argument it is treated as a setter.\r\n    # Changes to the value will trigger notifications. \r\n    # The value is always returned.\r\n    self = (newValue) ->\r\n      if arguments.length > 0\r\n        if value != newValue\r\n          value = newValue\r\n\r\n          notify(newValue)\r\n      else\r\n        # Automagic dependency observation\r\n        magicDependency(self)\r\n\r\n      return value\r\n\r\n    # Non-computed observables have no dependencies, releasing them is a non-operation.\r\n    self.releaseDependencies = noop\r\n    self._value = value\r\n\r\n  # If the value is an array then proxy array methods and add notifications to mutation events.\r\n  if Array.isArray(value)\r\n    [\r\n      \"concat\"\r\n      \"every\"\r\n      \"filter\"\r\n      \"forEach\"\r\n      \"indexOf\"\r\n      \"join\"\r\n      \"lastIndexOf\"\r\n      \"map\"\r\n      \"reduce\"\r\n      \"reduceRight\"\r\n      \"slice\"\r\n      \"some\"\r\n    ].forEach (method) ->\r\n      self[method] = (args...) ->\r\n        magicDependency(self)\r\n        value[method](args...)\r\n\r\n    [\r\n      \"pop\"\r\n      \"push\"\r\n      \"reverse\"\r\n      \"shift\"\r\n      \"splice\"\r\n      \"sort\"\r\n      \"unshift\"\r\n    ].forEach (method) ->\r\n      self[method] = (args...) ->\r\n        returnValue = value[method](args...)\r\n        notify(value)\r\n        return returnValue\r\n\r\n    # Provide length on a best effort basis because older browsers choke\r\n    if PROXY_LENGTH\r\n      Object.defineProperty self, 'length',\r\n        get: ->\r\n          magicDependency(self)\r\n          value.length\r\n        set: (length) ->\r\n          returnValue = value.length = length\r\n          notify(value)\r\n          return returnValue\r\n\r\n    # Extra methods for array observables\r\n    Object.assign self,\r\n      # Remove an element from the array and notify observers of changes.\r\n      remove: (object) ->\r\n        index = value.indexOf(object)\r\n\r\n        if index >= 0\r\n          returnValue = value.splice(index, 1)[0]\r\n          notify(value)\r\n          return returnValue\r\n\r\n      get: (index) ->\r\n        magicDependency(self)\r\n        value[index]\r\n\r\n      first: ->\r\n        magicDependency(self)\r\n        value[0]\r\n\r\n      last: ->\r\n        magicDependency(self)\r\n        value[value.length-1]\r\n\r\n      size: ->\r\n        magicDependency(self)\r\n        value.length\r\n\r\n  Object.assign self,\r\n    listeners: listeners\r\n\r\n    observe: (listener) ->\r\n      listeners.push listener\r\n\r\n    stopObserving: (fn) ->\r\n      remove listeners, fn\r\n\r\n    toggle: ->\r\n      self !value\r\n\r\n    increment: (n=1) ->\r\n      self Number(value) + n\r\n\r\n    decrement: (n=1) ->\r\n      self Number(value) - n\r\n\r\n    toString: ->\r\n      \"Observable(#{value})\"\r\n\r\n  return self\r\n\r\n# Appendix\r\n# --------\r\n\r\n# Super hax for computing dependencies. This needs to be a shared global so that\r\n# different bundled versions of observable libraries can interoperate.\r\nglobal.OBSERVABLE_ROOT_HACK = []\r\n\r\nmagicDependency = (self) ->\r\n  observerSet = last(global.OBSERVABLE_ROOT_HACK)\r\n  if observerSet\r\n    observerSet.add self\r\n\r\nremove = (array, value) ->\r\n  index = array.indexOf(value)\r\n\r\n  if index >= 0\r\n    array.splice(index, 1)[0]\r\n\r\ncopy = (array) ->\r\n  array.concat([])\r\n\r\nlast = (array) ->\r\n  array[array.length - 1]\r\n\r\nnoop = ->\r\n\r\n# Check if we can proxy function length property.\r\ntry\r\n  Object.defineProperty (->), 'length',\r\n    get: noop\r\n    set: noop\r\n\r\n  PROXY_LENGTH = true\r\ncatch\r\n  PROXY_LENGTH = false\r\n"},"lib/test/observable.coffee":{"content":"Observable = require \"../observable\"\r\n\r\ndescribe 'Observable', ->\r\n  it 'should create an observable for an object', ->\r\n    n = 5\r\n\r\n    observable = Observable(n)\r\n\r\n    assert.equal(observable(), n)\r\n\r\n  it 'should fire events when setting', ->\r\n    string = \"yolo\"\r\n\r\n    observable = Observable(string)\r\n    observable.observe (newValue) ->\r\n      assert.equal newValue, \"4life\"\r\n\r\n    observable(\"4life\")\r\n\r\n  it \"should not fire when setting to the same value\", ->\r\n    o = Observable 5\r\n\r\n    o.observe ->\r\n      assert false\r\n\r\n    o(5)\r\n\r\n  it 'should be idempotent', ->\r\n    o = Observable(5)\r\n\r\n    assert.equal o, Observable(o)\r\n\r\n  it \"should have releaseDependencies as a noop because primitive observables don't have any dependencies\", ->\r\n    o = Observable(5)\r\n    o.releaseDependencies()\r\n\r\n  it \"should provide an updating non-observing semi-private reference to value\", ->\r\n    o = Observable(5)\r\n    assert.equal o._value, 5\r\n\r\n    o 7\r\n    assert.equal o._value, 7\r\n\r\n    o2 = Observable ->\r\n      o._value\r\n    o3 = Observable ->\r\n      o()\r\n    assert.equal o2(), 7\r\n    assert.equal o3(), 7\r\n\r\n    o 9\r\n    assert.equal o2(), 7\r\n    assert.equal o2._value, 7\r\n    assert.equal o3(), 9\r\n    assert.equal o3._value, 9\r\n    assert.equal o._value, 9\r\n\r\n  it \"should allow for stopping observation\", ->\r\n    observable = Observable(\"string\")\r\n\r\n    called = 0\r\n    fn = (newValue) ->\r\n      called += 1\r\n      assert.equal newValue, \"4life\"\r\n\r\n    observable.observe fn\r\n\r\n    observable(\"4life\")\r\n\r\n    observable.stopObserving fn\r\n\r\n    observable(\"wat\")\r\n\r\n    assert.equal called, 1\r\n\r\n  it \"should do nothing when removing a listener that's not present\", ->\r\n    observable = Observable(\"string\")\r\n    observable.stopObserving ->\r\n\r\n  it \"should increment\", ->\r\n    observable = Observable 1\r\n\r\n    observable.increment(5)\r\n    assert.equal observable(), 6\r\n\r\n    observable.increment()\r\n    assert.equal observable(), 7\r\n    \r\n    observable.increment(0.05)\r\n    assert.equal observable(), 7.05\r\n\r\n    observable.increment(0.05)\r\n    assert.equal observable(), 7.10\r\n\r\n  it \"should decremnet\", ->\r\n    observable = Observable 1\r\n\r\n    observable.decrement 5\r\n    assert.equal observable(), -4\r\n\r\n    observable.decrement()\r\n    assert.equal observable(), -5\r\n\r\n  it \"should toggle\", ->\r\n    observable = Observable false\r\n\r\n    observable.toggle()\r\n    assert.equal observable(), true\r\n\r\n    observable.toggle()\r\n    assert.equal observable(), false\r\n\r\n  it \"should trigger when toggling\", (done) ->\r\n    observable = Observable true\r\n    observable.observe (v) ->\r\n      assert.equal v, false\r\n      done()\r\n\r\n    observable.toggle()\r\n\r\n  it \"should have a nice toString\", ->\r\n    observable = Observable 5\r\n\r\n    assert.equal observable.toString(), \"Observable(5)\"\r\n\r\ndescribe \"Observable Array\", ->\r\n  it \"should proxy array methods\", ->\r\n    o = Observable [5]\r\n\r\n    o.map (n) ->\r\n      assert.equal n, 5\r\n\r\n  it \"should notify on mutation methods\", (done) ->\r\n    o = Observable []\r\n\r\n    o.observe (newValue) ->\r\n      assert.equal newValue[0], 1\r\n\r\n    o.push 1\r\n\r\n    done()\r\n\r\n  it \"#get\", ->\r\n    o = Observable [0, 1, 2, 3]\r\n\r\n    assert.equal o.get(2), 2\r\n\r\n  it \"#first\", ->\r\n    o = Observable [0, 1, 2, 3]\r\n\r\n    assert.equal o.first(), 0\r\n\r\n  it \"#last\", ->\r\n    o = Observable [0, 1, 2, 3]\r\n\r\n    assert.equal o.last(), 3\r\n\r\n  it \"#remove\", ->\r\n    o = Observable [0, 1, 2, 3]\r\n\r\n    assert.equal o.remove(2), 2\r\n    assert.equal o.length, 3\r\n    assert.equal o.remove(-5), undefined\r\n    assert.equal o.length, 3\r\n\r\n  it \"#remove non-existent element\", ->\r\n    o = Observable [1, 2, 3]\r\n\r\n    assert.equal o.remove(0), undefined\r\n\r\n  it \"should proxy the length property\", ->\r\n    o = Observable [1, 2, 3]\r\n\r\n    assert.equal o.length, 3\r\n\r\n    called = false\r\n    o.observe (value) ->\r\n      assert.equal value[0], 1\r\n      assert.equal value[1], undefined\r\n      called = true\r\n\r\n    o.length = 1\r\n    assert.equal o.length, 1\r\n    assert.equal called, true\r\n\r\n  it \"should auto detect conditionals of length as a dependency\", ->\r\n    observableArray = Observable [1, 2, 3]\r\n\r\n    o = Observable ->\r\n      if observableArray.length > 5\r\n        true\r\n      else\r\n        false\r\n\r\n    assert.equal o(), false\r\n\r\n    called = 0\r\n    o.observe ->\r\n      called += 1\r\n\r\n    observableArray.push 4, 5, 6\r\n\r\n    assert.equal called, 1\r\n\r\ndescribe \"Observable functions\", ->\r\n  it \"should compute dependencies\", (done) ->\r\n    firstName = Observable \"Duder\"\r\n    lastName = Observable \"Man\"\r\n\r\n    o = Observable ->\r\n      \"#{firstName()} #{lastName()}\"\r\n\r\n    o.observe (newValue) ->\r\n      assert.equal newValue, \"Duder Bro\"\r\n\r\n      done()\r\n\r\n    lastName \"Bro\"\r\n\r\n  it \"should compute array#get as a dependency\", ->\r\n    observableArray = Observable [0, 1, 2]\r\n\r\n    observableFn = Observable ->\r\n      observableArray.get(0)\r\n\r\n    assert.equal observableFn(), 0\r\n\r\n    observableArray([5])\r\n\r\n    assert.equal observableFn(), 5\r\n\r\n  it \"should compute array#first as a dependency\", ->\r\n    observableArray = Observable [0, 1, 2]\r\n\r\n    observableFn = Observable ->\r\n      observableArray.first() + 1\r\n\r\n    assert.equal observableFn(), 1\r\n\r\n    observableArray([5])\r\n\r\n    assert.equal observableFn(), 6\r\n\r\n  it \"should compute array#last as a dependency\", ->\r\n    observableArray = Observable [0, 1, 2]\r\n\r\n    observableFn = Observable ->\r\n      observableArray.last()\r\n\r\n    assert.equal observableFn(), 2\r\n\r\n    observableArray.pop()\r\n\r\n    assert.equal observableFn(), 1\r\n\r\n    observableArray([5])\r\n\r\n    assert.equal observableFn(), 5\r\n\r\n  it \"should compute array#size as a dependency\", ->\r\n    observableArray = Observable [0, 1, 2]\r\n\r\n    observableFn = Observable ->\r\n      observableArray.size() * 2\r\n\r\n    assert.equal observableFn(), 6\r\n\r\n    observableArray.pop()\r\n    assert.equal observableFn(), 4\r\n    observableArray.shift()\r\n    assert.equal observableFn(), 2\r\n\r\n  it \"should allow double nesting\", (done) ->\r\n    bottom = Observable \"rad\"\r\n    middle = Observable ->\r\n      bottom()\r\n    top = Observable ->\r\n      middle()\r\n\r\n    top.observe (newValue) ->\r\n      assert.equal newValue, \"wat\"\r\n      assert.equal top(), newValue\r\n      assert.equal middle(), newValue\r\n\r\n      done()\r\n\r\n    bottom(\"wat\")\r\n\r\n  it \"should work with dynamic dependencies\", ->\r\n    observableArray = Observable []\r\n\r\n    dynamicObservable = Observable ->\r\n      observableArray.filter (item) ->\r\n        item.age() > 3\r\n\r\n    assert.equal dynamicObservable().length, 0\r\n\r\n    observableArray.push\r\n      age: Observable 1\r\n\r\n    observableArray()[0].age 5\r\n    assert.equal dynamicObservable().length, 1\r\n\r\n  it \"should work with context\", ->\r\n    model =\r\n      a: Observable \"Hello\"\r\n      b: Observable \"there\"\r\n\r\n    model.c = Observable ->\r\n      \"#{@a()} #{@b()}\"\r\n    , model\r\n\r\n    assert.equal model.c(), \"Hello there\"\r\n\r\n    model.b \"world\"\r\n\r\n    assert.equal model.c(), \"Hello world\"\r\n\r\n  it \"should be ok even if the function throws an exception\", ->\r\n    assert.throws ->\r\n      t = Observable ->\r\n        throw \"wat\"\r\n\r\n    # TODO: Should be able to find a test case that is affected by this rather than\r\n    # checking it directly\r\n    assert.equal global.OBSERVABLE_ROOT_HACK.length, 0\r\n\r\n  it \"should work on an array dependency\", ->\r\n    oA = Observable [1, 2, 3]\r\n\r\n    o = Observable ->\r\n      oA()[0]\r\n\r\n    last = Observable ->\r\n      oA()[oA().length-1]\r\n\r\n    assert.equal o(), 1\r\n\r\n    oA.unshift 0\r\n\r\n    assert.equal o(), 0\r\n\r\n    oA.push 4\r\n\r\n    assert.equal last(), 4, \"Last should be 4\"\r\n\r\n  it \"should work with multiple dependencies\", ->\r\n    letter = Observable \"A\"\r\n    checked = ->\r\n      l = letter()\r\n      @name().indexOf(l) is 0\r\n\r\n    first = {name: Observable(\"Andrew\")}\r\n    first.checked = Observable checked, first\r\n\r\n    second = {name: Observable(\"Benjamin\")}\r\n    second.checked = Observable checked, second\r\n\r\n    assert.equal first.checked(), true\r\n    assert.equal second.checked(), false\r\n\r\n    assert.equal letter.listeners.length, 2\r\n\r\n    letter \"B\"\r\n\r\n    assert.equal first.checked(), false\r\n    assert.equal second.checked(), true\r\n\r\n  it \"shouldn't double count dependencies\", ->\r\n    dep = Observable \"yo\"\r\n\r\n    o = Observable ->\r\n      dep()\r\n      dep()\r\n      dep()\r\n\r\n    count = 0\r\n    o.observe ->\r\n      count += 1\r\n\r\n    dep('heyy')\r\n\r\n    assert.equal count, 1\r\n\r\n  it \"should recompute the correct number of times\", ->\r\n    joiner = Observable \",\"\r\n\r\n    items = Observable [\r\n      \"A\"\r\n      \"B\"\r\n      \"C\"\r\n    ]\r\n\r\n    called = 0\r\n    fn = Observable ->\r\n      called += 1\r\n      items.join joiner()\r\n\r\n    assert.equal fn(), \"A,B,C\"\r\n    assert.equal called, 1\r\n\r\n    items.push \"D\"\r\n    assert.equal fn(), \"A,B,C,D\"\r\n    assert.equal called, 2\r\n\r\n    joiner \".\"\r\n    assert.equal fn(), \"A.B.C.D\"\r\n    assert.equal called, 3\r\n\r\n    items.push \"E\"\r\n    assert.equal fn(), \"A.B.C.D.E\"\r\n    assert.equal called, 4\r\n\r\n  it \"should work with nested observable construction\", ->\r\n    gen = Observable ->\r\n      Observable \"Duder\"\r\n\r\n    o = gen()\r\n    o2 = gen()\r\n    assert.equal o, o2\r\n\r\n    assert.equal o(), \"Duder\"\r\n\r\n    o(\"wat\")\r\n\r\n    assert.equal o(), \"wat\"\r\n\r\n  it \"should be scoped to optional context\", (done) ->\r\n    model =\r\n      firstName: Observable \"Duder\"\r\n      lastName: Observable \"Man\"\r\n\r\n    model.name = Observable ->\r\n      \"#{@firstName()} #{@lastName()}\"\r\n    , model\r\n\r\n    model.name.observe (newValue) ->\r\n      assert.equal newValue, \"Duder Bro\"\r\n\r\n      done()\r\n\r\n    model.lastName \"Bro\"\r\n  "},"style.styl":{"content":"@font-face\n  font-family: 'Fira Sans'\n  font-style: normal\n  font-weight: 400\n  src: local('Fira Sans Regular'), local('FiraSans-Regular'), url(\"https://danielx.net/fonts/FiraSans-v10-Regular.woff2\") format('woff2')\n  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD\n\n@font-face\n  font-family: 'Fira Sans'\n  font-style: italic\n  font-weight: 400\n  src: local('Fira Sans Italic'), local('FiraSans-Italic'), url(\"https://danielx.net/fonts/FiraSans-v10-Italic.woff2\") format('woff2')\n  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD\n\n@font-face\n  font-family: 'Fira Sans'\n  font-style: normal\n  font-weight: 700\n  src: local('Fira Sans Bold'), local('FiraSans-Bold'), url(\"https://danielx.net/fonts/FiraSans-v10-Bold.woff2\") format('woff2')\n  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD\n\n/*\nInspiration\nhttps://lospec.com/palette-list/hyperchill-10\n#ffb845\n#fb7974\n#f97698\n#ce5f9f\n#a348a6\n#8549ad\n#674ab3\n#556dc8\n#6783db\n#7998ee\n*/\n\n// Theme variables\n:root\n  // Neutral border and shadow styles\n  --neutral-light: rgba(255, 255, 255, 0.5)\n  --neutral-faintest: #efefef\n  --neutral-faint: rgba(0, 0, 0, 0.25)\n  --neutral-dark: rgba(0, 0, 0, 0.5)\n  --neutral-darker: rgba(0, 0, 0, 0.875)\n\n  // shadow heights\n  --shadow-low: 1px 2px 0\n  --shadow-medium: 4px 4px 0\n\n  // borders\n  --border-radius: 0\n\n  // colors\n  --background-color: #ffffff\n  --background-neutral: gainsboro\n  --dark-subdued-color: #000080\n  --error-color: #800\n  --highlight-color: #ffb845\n  --hover-color: #d2d9ef\n  --primary-color: #8549ad\n  --text-color: rgba(0, 0, 0, 0.9375)\n  --text-primary-color: #ffffff\n\n*\n  box-sizing: border-box\n\n// Helpers\nno-select()\n  user-select: none\n  -webkit-user-select: none // safari\n  -ms-user-select: none // ie\n\nhtml\n  color: var(--text-color)\n  font-family: 'Fira Sans', Sans-Serif\n  font-size: 16px\n  line-height: 1.5\n\nbody, html\n  height: 100%\n\nbody\n  // TODO: This is pretty aggressive and specific to appending a single 'app'\n  // element to the body.\n  display: flex\n  flex-direction: column\n\n  margin: 0\n\n// resets\n\nh1, h2, h3, h4, h5, h6\n  margin: 0\n\niframe\n  border: none\n\np\n  margin: 0 0 1rem\n\nul\n  list-style: none\n  margin: 0\n  padding: 0\n\ninput, textarea, keygen, select, button\n  color: inherit\n  font: inherit\n  line-height: inherit\n\n// Base styles\n\n:focus-visible\n  outline: 2px solid var(--text-color)\n\n::-webkit-scrollbar\n  border: 1px solid var(--neutral-darker)\n  background-color: var(--background-neutral)\n  border-radius: var(--border-radius)\n\n::-webkit-scrollbar-thumb\n  background-color: var(--background-color)\n  border: 1px solid var(--neutral-darker)\n  border-radius: var(--border-radius)\n\n  &:hover\n    background-color: var(--neutral-faintest)\n\nbutton, a.button, input[type=\"file\"]::file-selector-button\n  background-color: var(--background-color)\n  border: 1px solid var(--neutral-darker)\n  border-radius: var(--border-radius)\n  box-shadow: var(--shadow-low) var(--neutral-dark)\n  cursor: pointer\n  display: inline-block\n  padding: 0.125em 0.375em\n\nbutton, a.button\n  &:hover\n    background-color: var(--neutral-faintest)\n\n  &:active, &.active\n    background-color: var(--neutral-faintest)\n    box-shadow: var(--shadow-low) var(--neutral-dark) inset\n\n// This needs the :: selector after :hover and :active\ninput[type=\"file\"]\n  &:hover\n    &::file-selector-button\n      background-color: var(--neutral-faintest)\n  &:active, &.active\n    &::file-selector-button\n      background-color: var(--neutral-faintest)\n      box-shadow: var(--shadow-low) var(--neutral-dark) inset\n\ninput, textarea\n  // background-color: var(--neutral-faintest)\n  border: 1px solid var(--neutral-darker)\n  border-radius: var(--border-radius)\n  box-shadow: var(--shadow-low) var(--neutral-dark) inset\n\n  padding: 0.125em 0.25em\n\n  &::placeholder\n    font-style: italic\n\ninput[type=\"file\"]\n  border-width: 0\n  box-shadow: none\n  padding: 3px 0\n\nlabel\n  > input, > textarea, > select\n    width: 100%\n\n// Loader\nloader\n  display: block\n  padding: 1em\n\n  > p:empty\n    margin: 0\n\n  > progress\n    display: block\n\n// Menus\nmenu\n  no-select()\n\n  background-color: var(--background-neutral)\n  border-bottom: 1px solid var(--neutral-dark)\n  line-height: 1.25\n  margin: 0\n  z-index: 1\n\n  &:focus\n    outline: none\n\nmenu.context\n  z-index: 2000\n\nmenu-item\n  display: block\n  list-style-type: none\n\n  &.active\n    background-color: var(--dark-subdued-color)\n    color: var(--text-primary-color)\n\n  > label\n    display: flex\n    padding: 0 0.25rem\n    white-space: nowrap\n\n    > *\n      flex: 1 1 auto\n\n    > span.hotkey\n      margin-left: 1rem\n\n      &:empty\n        margin-left: 0\n\n    > .decoration\n      align-self: center\n      flex: 0 1 auto\n      text-align: right\n      margin-left: 0.5rem\n\n      &:empty\n        margin-left: 0\n\n  &[disabled]\n    color: gray\n\n    &.active\n      background-color: rgba(0, 0, 0, 0.125)\n\nmenu.options\n  border-top: 1px solid var(--neutral-light)\n  border-left: 1px solid var(--neutral-light)\n  border-right: 1px solid var(--neutral-dark)\n\n  box-shadow: var(--shadow-low) var(--neutral-dark)\n\n  display: none\n\n  padding: 2px\n  padding-bottom: 3px\n  position: absolute\n\n  &.active\n    display: block\n\n  // Submenu\n  > menu-item.menu\n    position: relative\n\n    > menu\n      position: absolute\n      left: 100%\n      top: -3px\n      margin-left: 1px\n\nmenu-item.menu.active\n  > menu\n    background-color: var(--background-neutral)\n    color: var(--text-color)\n    display: block\n\nmenu.bar\n  display: block\n  flex: 0 0 auto\n  margin: 0\n  padding: 0\n  position: initial\n  white-space: nowrap\n  overflow: hidden\n\n  > menu-item\n    display: inline-block\n    > label > .decoration\n      display: none\n\n  &.accelerator-active\n    span.accelerator\n      text-decoration: underline\n\n// For context menus starting from the bottom of the screen\nmenu.options.bottoms-up menu-item.menu > menu\n  top: initial\n  bottom: -4px\n\n#modal\n  align-items: center\n  background-color: var(--neutral-faint)\n  display: none\n  justify-content: center\n  position: absolute\n  z-index: 10000\n  top: 0\n  width: 100%\n  height: 100%\n\n  &.active\n    display: flex\n\n  > *\n    background-color: var(--background-color)\n    border: 1px solid var(--neutral-dark)\n    border-radius: var(--border-radius)\n    box-shadow: var(--shadow-medium) var(--neutral-dark)\n    max-width: 90%\n    max-height: 90%\n    position: relative\n    z-index: 1\n\n  > form\n    display: block\n    padding: 1rem\n\n    > h1, > h2\n      font-size: 1.5rem\n      line-height: 1.5rem\n      margin-bottom: 0.5rem\n\n    > input, > textarea\n      display: block\n      margin-bottom: 1rem\n      width: 100%\n\n    > button\n      margin-right: 1rem\n      &:last-child\n        margin-right: 0\n\n// login form\n#modal > section.ws-login\n  padding: 2rem\n  position: relative\n\n  > form\n    margin-right: 0\n    width: 400px\n\n    > h1\n      margin-top: 0\n    \n    > section > button.top-left\n      position: absolute\n      top: 0.5rem\n      left: 0.5rem\n\n// Fuzzy List\nform.fuzzy-list\n  #modal > &\n    display: flex\n    flex-direction: column\n    width: 66.6%\n    height: 66.6%\n\n  > input\n    width: 100%\n\n  > ul\n    flex: 1 1 auto\n    overflow: auto\n\n    > li\n      cursor: pointer\n\n      &:nth-child(even)\n        background-color: var(--neutral-faintest)\n\n      &:hover\n        background-color: var(--hover-color)\n\n      &.active\n        background-color: var(--highlight-color)\n\n@media only screen and (max-width: 768px)\n  form.fuzzy-list\n    #modal > &\n      width: 90%\n      height: 90%\n\n// Table\ncontainer\n  display: block\n  height: 100%\n  overflow: auto\n  width: 100%\n\ntable\n  border-collapse: collapse\n  width: 100%\n\nth\n  text-align: left\n\nthead\n  border-bottom: 1px solid var(--neutral-darker)\n\ntd > input\n  border: none\n  box-shadow: none\n  background-color: transparent\n  padding: 0\n  width: 100%\n\ntr:nth-child(even)\n  background-color: var(--neutral-faintest)\n\nwindow\n  no-select()\n\n  background-color: var(--background-neutral)\n  border: 4px double var(--neutral-darker)\n  border-radius: var(--border-radius)\n  box-shadow: var(--shadow-low) var(--neutral-dark)\n  display: flex\n  flex-direction: column\n  position: absolute\n\n  > header\n    background-color: var(--dark-subdued-color)\n    border-bottom: 1px solid var(--neutral-darker)\n    cursor: default\n    display: flex\n    flex: 0 0 auto\n    line-height: 18px\n\n    > icon\n      background-position: 50%\n      background-repeat: no-repeat\n      background-size: 16px\n      color: var(--text-primary-color)\n      display: inline-block\n      flex: 0 0 auto\n      text-align: center\n      width: 0\n\n    > control\n      align-items: center\n      background-color: var(--background-neutral)\n      border-left: 1px solid var(--neutral-darker)\n      color: var(--text-primary-color)\n      cursor: pointer\n      display: inline-flex\n      flex: 0 0 auto\n      font-family: 'Fira Code', monospace\n      justify-content: center\n      overflow: hidden\n      text-shadow: 1px 0px 0px #000, -1px 0px 0px #000, 0px -1px 0px #000, 0px 1px 0px #000, 1px 1px 0px #808080\n      width: 18px\n\n      &:first-child\n        border-left: none\n\n      &.close\n        &::before\n          content: \"X\"\n\n      &.maximize\n        &::before\n          content: \"+\"\n\n      &.minimize\n        &::before\n          content: \"-\"\n\n      &.restore\n        display: none\n        &::before\n          content: \"-\"\n\n    > title-bar\n      color: var(--text-primary-color)\n      display: inline-block\n      flex: 1 1 auto\n      overflow: hidden\n      padding: 0 1rem 0 6px\n      text-overflow: ellipsis\n      white-space: nowrap\n\n  > viewport\n    background-color: white\n    display: flex\n    height: 100%\n    overflow: auto\n    position: relative\n    z-index: 0\n\n    > *\n      margin: auto\n\n    > textarea\n      border: none\n      font-family: monospace\n      height: 100%\n      padding: 2px 4px\n      resize: none\n      width: 100%\n\n    > section.ace_editor\n      width: 100%\n      height: 100%\n\n    > iframe\n      border: none\n      height: 100%\n      width: 100%\n      position: absolute\n\n  > resize\n    border-color: var(--neutral-darker)\n    display: block\n    position: absolute\n\n    &.e, &.w\n      cursor: ew-resize\n\n    &.n, &.s\n      cursor: ns-resize\n\n    &.h\n      height: 4px\n      width: 100%\n\n    &.v\n      height: 100%\n      width: 4px\n\n    &.w\n      left: -4px\n    &.e\n      right: -4px\n    &.n\n      top: -4px\n    &.s\n      bottom: -4px\n\n    &.n.w\n      cursor: nw-resize\n\n    &.n.e\n      cursor: ne-resize\n\n    &.s.e\n      cursor: se-resize\n\n    &.s.w\n      cursor: sw-resize\n\n    &.n.v\n      border-bottom: 1px solid\n      height: 23px\n\n    &.s.v\n      border-top: 1px solid\n      height: 23px\n\n    &.e.h\n      border-left: 1px solid\n      width: 22px\n\n    &.w.h\n      border-right: 1px solid\n      width: 22px\n\n  &.minimized\n    > header\n      border-bottom: none\n\n      > control\n        display: none\n\n        &.minimize\n          border-right: none\n          display: inline-flex\n          &::before\n            content: \"+\"\n\n    > menu, > resize, > viewport\n      display: none\n\n  &.maximized\n    border: none\n    border-radius: 0\n    height: 100%\n    width: 100%\n\n    > resize\n      display: none\n\n    > header\n      position: absolute\n      right: 0\n      z-index: 2\n      > control\n        display: none\n\n        &.restore, &.close\n          display: inline-flex\n\nframe-guard\n  display: block\n  height: 100%\n  left: 0\n  pointer-events: none\n  position: fixed\n  top: 0\n  width: 100%\n  z-index: 100000\n\n  &.active\n    pointer-events: auto\n"},"docs/Bindable.md":{"content":"Bindable\n========\n\nAdd event binding to objects.\n\n    bindable = Bindable()\n    handler = ->\n      console.log \"yo!\"\n\n    # Add handler\n    bindable.on \"greet\", handler\n    bindable.trigger \"greet\"\n    # => \"yo!\" is printed to log\n    \n    # Remove handler\n    bindable.off \"greet\", handler\n    bindable.trigger \"greet\"\n    # => Nothing is printed to the log\n    \n\n## Use as a mixin.\n\n    self.include Bindable\n\n## Add Event Listener\n\nThis will call `coolEventHandler` after `yourObject.trigger \"someCustomEvent\"`\nis called.\n\n    yourObject.on \"someCustomEvent\", coolEventHandler\n\n## Remove Event Listener\n\nRemoves the handler coolEventHandler from the event `\"someCustomEvent\"` while\nleaving the other events intact.\n\n    yourObject.off \"someCustomEvent\", coolEventHandler\n\nRemoves all handlers attached to `\"anotherCustomEvent\"`\n\n    yourObject.off \"anotherCustomEvent\"\n\n## Trigger Event Listener\n\nCalls all listeners attached to the specified event.\n\n    # calls each event handler bound to \"someCustomEvent\"\n    yourObject.trigger \"someCustomEvent\"\n\nAdditional parameters can be passed to the handlers.\n\n    yourObject.trigger \"someEvent\", \"hello\", \"anotherParameter\"\n"},"lib/bindable.coffee":{"content":"# TODO: Remove unused `I` argument\nmodule.exports = (I={}, self={}) ->\n  eventCallbacks = {}\n\n  Object.assign self,\n    on: (event, callback) ->\n      eventCallbacks[event] ||= []\n      eventCallbacks[event].push(callback)\n\n      return self\n\n    off: (event, callback) ->\n      if event\n        eventCallbacks[event] ||= []\n\n        if callback\n          remove eventCallbacks[event], callback\n        else\n          eventCallbacks[event] = []\n\n      return self\n\n    trigger: (event, parameters...) ->\n      (eventCallbacks[\"*\"] or []).forEach (callback) ->\n        callback.apply(self, [event].concat(parameters))\n\n      unless event is \"*\"\n        (eventCallbacks[event] or []).forEach (callback) ->\n          callback.apply(self, parameters)\n\n      return self\n\n  return self\n\nremove = (array, value) ->\n  index = array.indexOf(value)\n\n  if index >= 0\n    array.splice(index, 1)[0]\n"},"lib/test/bindable.coffee":{"content":"test = it\nok = assert\nequal = assert.equal\n\nBindable = require \"../bindable\"\n\ndescribe \"Bindable\", ->\n\n  test \"#on and #trigger\", ->\n    o = Bindable()\n\n    o.on(\"test\", -> ok true)\n\n    o.trigger(\"test\")\n\n  test \"Multiple bindings\", ->\n    o = Bindable()\n\n    o.on(\"test\", -> ok true)\n    o.on(\"test\", -> ok true)\n\n    o.trigger(\"test\")\n\n  test \"#trigger arguments\", ->\n    o = Bindable()\n\n    param1 = \"the message\"\n    param2 = 3\n\n    o.on \"test\", (p1, p2) ->\n      equal(p1, param1)\n      equal(p2, param2)\n\n    o.trigger \"test\", param1, param2\n\n  test \"#off\", ->\n    o = Bindable()\n\n    callback = ->\n      ok false\n\n    o.on \"test\", callback\n    # Unbind specific event\n    o.off \"test\", callback\n    o.trigger \"test\"\n\n    o.on \"test\", callback\n    # Unbind all events\n    o.off \"test\"\n    o.trigger \"test\"\n\n  test \"* events\", ->\n    o = Bindable()\n\n    called = 0\n    o.on \"*\", (event, rest...) ->\n      called += 1\n\n      if called is 1\n        assert.equal event, \"edit\"\n        assert.equal rest[0], \"cool\"\n        assert.equal rest[1], 5\n\n    o.trigger \"edit\", \"cool\", 5\n\n    assert.equal called, 1\n"},"lib/extensions.coffee":{"content":"{deprecationWarning} = require \"./util/index\"\n\n# Add some utility readers to the Blob API\npromiseReader = (file, method) ->\n  new Promise (resolve, reject) ->\n    reader = new FileReader\n    reader.onload = ->\n      resolve reader.result\n    reader.onerror = reject\n    reader[method](file)\n\nreadAsText = ->\n  promiseReader(this, \"readAsText\")\n\nreadAsArrayBuffer = ->\n  promiseReader(this, \"readAsArrayBuffer\")\n\nreadAsDataURL = ->\n  promiseReader(this, \"readAsDataURL\")\n\nreadAsJSON = ->\n  @text()\n  .then JSON.parse\n\nObject.assign Blob::,\n  readAsText: deprecationWarning \"blob.readAsText -> blob.text\", readAsText\n\n  readAsArrayBuffer: deprecationWarning \"blob.readAsArrayBuffer -> blob.arrayBuffer\", \n    readAsArrayBuffer\n\n  readAsDataURL: deprecationWarning \"blob.readAsDataURL -> blob.dataURL\", readAsDataURL\n\n  readAsJSON: deprecationWarning \"blob.readAsJSON -> blob.json\", readAsJSON\n\nBlob::arrayBuffer ?= readAsArrayBuffer\nBlob::dataURL ?= readAsDataURL\nBlob::json ?= readAsJSON\nBlob::text ?= readAsText\n\nBlob::download = (path) ->\n  url = URL.createObjectURL(this)\n  a = document.createElement(\"a\")\n  a.href = url\n  a.style.display = \"none\"\n  a.download = path\n  document.body.appendChild a # FF requires element to be attached to DOM\n  a.click()\n  a.remove()\n  URL.revokeObjectURL(url)\n\n# Load an image from a blob returning a promise that is fulfilled with the\n# loaded image or rejected with an error\nImage.fromBlob = (blob) ->\n  url = URL.createObjectURL(blob)\n\n  new Promise (resolve, reject) ->\n    img = new Image\n    img.onload = ->\n      URL.revokeObjectURL url\n      resolve img\n    img.onerror = (e) -> \n      URL.revokeObjectURL url\n      reject e\n\n    img.src = url\n\n# Extend JSON with toBlob method\nJSON.toBlob ?= (object, mime=\"application/json\") ->\n  new Blob [JSON.stringify(object)], type: \"#{mime}; charset=utf-8\"\n\n# HTML Extensions\nHTMLCollection::forEach ?= Array::forEach\nFileList::forEach ?= Array::forEach\n"},"data/templates/menu.coffee":{"content":"module.exports =\n  items: [\n    \"yolo\"\n  ]\n"},"setup.coffee":{"content":"# Use Jadelet lib if system is not already required\n#\n# This is so Prometheus can show the View demos for this package since we don't\n# depend on ourselves for `!system`\n# This file can go away if we set .jadelet compiler to use\n# 'require(\"/lib/jadelet\")' rather than system.ui.Jadelet\n#\n# TODO: Re-examine how we set template deps in Prometheus\nrequire \"./lib/polyfill\"\n\nglobal.system ?= {}\nglobal.system.ui ?= {}\nglobal.system.ui.Jadelet ?= require(\"./lib/jadelet\")\n"},"data/views/context-menu.coffee":{"content":"{Util} = require \"../../lib/ui/index\"\n\n{parseMenu} = Util\n\nmodule.exports =\n  items: parseMenu \"\"\"\n    Hello\n  \"\"\"\n  handlers: {}\n"},"lib/test/extensions.coffee":{"content":"require \"../extensions\"\n\ndescribe \"extensions\", ->\n  describe \"Blob\", ->\n    it \"should have promise convenience methods\", ->\n      b = new Blob([\"{}\"])\n\n      b.arrayBuffer()\n      .then ->\n        b.json()\n      .then ->\n        b.text()\n      .then ->\n        b.dataURL()\n\n    it \"should have download method\", ->\n      assert Blob::download\n\n  it \"should extend native APIs with extensions\", ->\n    assert FileList::forEach\n    assert HTMLCollection::forEach\n\n    assert Image.fromBlob\n\n    assert JSON.toBlob\n"},"data/templates/input.coffee":{"content":""},"data/views/window.coffee":{"content":""},"data/templates/modal/prompt.coffee":{"content":""},"data/views/menu-bar.coffee":{"content":"module.exports =\n  items: \"\"\"\n    Hello\n      Yo\n  \"\"\"\n  handlers:\n    yo: ->\n      alert \"yo\"\n"},"data/views/menu-item.coffee":{"content":"module.exports =\n  label: \"yo23\"\n  contextRoot:\n    handlers: {}\n    activeItem: ->\n"},"data/views/table.coffee":{"content":"module.exports = {}\n"},"data/views/progress.coffee":{"content":"Observable = require \"../../lib/observable\"\n\nmodule.exports = model =\n  max: 1\n  value: Observable 0.25\n\nsetInterval ->\n  model.value.increment(0.01)\n, 100\n"},"plugin/prometheus-preview.coffee":{"content":"# This hooks into the Prometheus preview for views and templates\n# maybe there's more cool stuff we can do here, but currently just\n# requiring setup to provide system.client.Jadelet2 since we can't easily\n# have this library as the !system dependency of itself.\nrequire \"../setup\"\n"},"data/views/menu-separator.coffee":{"content":"module.exports = {}\n"},"lib/fs/mount.coffee":{"content":"Bindable = require \"../bindable\"\n\n{Ergonomics} = require \"./util\"\n\nmodule.exports = () ->\n  mounts = {}\n  mountPaths = []\n\n  longestToShortest = (a, b) ->\n    b.length - a.length\n\n  findMountPathsFor = (path) ->\n    mountPaths.filter (p) ->\n      path.startsWith p\n\n  proxyToMount = (method) ->\n    (path, params...) ->\n      mountPaths = findMountPathsFor path\n\n      unless mountPaths.length\n        throw new Error \"No mounted filesystem for #{path}\"\n\n      [mountPath] = mountPaths\n      mount = mounts[mountPath].subsystem\n\n      subsystemPath = path.replace(mountPath, \"/\")\n\n      if method is \"list\"\n        # Remap paths when retrieving entries\n        mount[method](subsystemPath, params...)\n        .then (entries) ->\n          entries.map (entry) ->\n            Object.assign {}, entry, \n              path: entry.path.replace(\"/\", mountPath)\n      else if method is \"read\"\n        mount[method](subsystemPath, params...)\n        .then (blob) ->\n          if blob\n            blob.path = path\n\n            return blob\n      else\n        mount[method](subsystemPath, params...)\n\n  self =\n    read: proxyToMount \"read\"\n    write: proxyToMount \"write\"\n    delete: proxyToMount \"delete\"\n    list: proxyToMount \"list\"\n\n    # S3FS has a local cache, other local systems don't because they are\n    # already local. This will call clear cache on any subsystem if it exists.\n    clearCache: ->\n      Object.keys(mounts).forEach (key) ->\n        mounts[key].subsystem.clearCache?()\n\n    mount: (folderPath, subsystem) ->\n      # Pass all subsystem events through, rewriting the path\n      handler = (eventName, path) ->\n        self.trigger eventName, path.replace(\"/\", folderPath)\n\n      # Remove previous subsystem handler if present\n      if mounts[folderPath]\n        {subsystem: s, handler: h} = mounts[folderPath]\n        s.off \"*\", h\n\n      subsystem.on \"*\", handler\n\n      mounts[folderPath] = { subsystem, handler }\n      mountPaths.push folderPath\n      mountPaths.sort longestToShortest\n\n      return self\n\n  Bindable(undefined, self)\n  Ergonomics(self)\n\n  return self\n"},"lib/test/fs/mount.coffee":{"content":"require \"/setup\"\n\nBindable = require \"/lib/bindable\"\nMountFS = require \"/lib/fs/mount\"\nPkgFS = require \"/lib/fs/pkg\"\n\ntestPkg =\n  source:\n    \"hello.coffee\":\n      content: \"alert hello\"\n    \"test/wat.js\":\n      content: \"assert(wat);\"\n\ntestPkg2 =\n  source:\n    \"yo.coffee\":\n      content: \"alert 'ayyy'\"\n\ndescribe \"Mount FS\", ->\n  it \"should mount a filesystem\", ->\n    fs = MountFS()\n\n    fs.mount(\"/pkg/\", PkgFS(testPkg))\n\n    fs.read(\"/pkg/hello.coffee\")\n    .then (blob) ->\n      blob.text()\n    .then (src) ->\n      assert.equal src, \"alert hello\"\n\n  it \"should mount on top of previous path\", ->\n    fs = MountFS()\n\n    fs.mount(\"/pkg/\", PkgFS(testPkg))\n    fs.mount(\"/pkg/\", PkgFS(testPkg2))\n\n    fs.read(\"/pkg/yo.coffee\")\n    .then (blob) ->\n      blob.text()\n    .then (src) ->\n      assert.equal src, \"alert 'ayyy'\"\n\n      fs.list('/pkg/')\n      .then (files) ->\n        assert.equal files.length, 1\n        assert.equal files[0].path, \"/pkg/yo.coffee\"\n\n        fs.mount(\"/pkg/\", PkgFS(testPkg))\n        fs.mount(\"/pkg/\", PkgFS(testPkg))\n\n        fs.list('/pkg/')\n        .then (files) ->\n          assert.equal files.length, 2\n          assert.equal files[1].path, \"/pkg/hello.coffee\"\n\n  it \"should accept text strings in write method and save them with the proper media type passing options through\", ->\n    fs = MountFS()\n\n    file = undefined\n    opt = undefined\n    fs.mount \"/pkg/\",\n      write: (path, blob, options) ->\n        file = blob\n        opt = options\n        Promise.resolve()\n      read: (path) ->\n        Promise.resolve file\n      on: ->\n\n    fs.write \"/pkg/hey.js\", \"alert('hey');\", cacheControl: 86400\n    .then ->\n      fs.read(\"/pkg/hey.js\")\n    .then (blob) ->\n      assert.equal blob.type, \"text/javascript; charset=utf-8\"\n      assert.equal opt.cacheControl, 86400\n\n  it \"should pass through calls to `clearCache`\", ->\n    fs = MountFS()\n\n    called = false\n    mock =\n      clearCache: ->\n        called = true\n\n    Bindable null, mock\n\n    fs.mount \"/\", mock\n\n    fs.clearCache()\n    assert called\n\n  it.skip \"should list contents of mounted subfolders\", ->\n    fs = MountFS()\n\n    mock =\n      list: ->\n        Promise.resolve [{\n          path: \"a.txt\"\n        }, {\n          path: \"b.txt\"\n        }]\n\n    Bindable null, mock\n\n    fs.mount \"/game/\", mock\n    fs.mount \"/\", mock\n\n    fs.list \"/\"\n    .then (results) ->\n      assert.equal results.length, 4\n"},"lib/fs/s3.coffee":{"content":"Bindable = require \"../bindable\"\n\n{deprecationWarning, promiseChoke} = require \"../util/index\"\n\npinvoke = (object, method, params...) ->\n  new Promise (resolve, reject) ->\n    object[method] params..., (err, result) ->\n      if err\n        reject err\n        return\n\n      resolve result\n\ndelimiter = \"/\"\n\nmodule.exports = (id, bucket, refreshCredentials) ->\n  refreshCredentials ?= -> Promise.reject new Error \"No method given to refresh credentials automatically\"\n  refreshCredentialsPromise = Promise.resolve()\n\n  do (oldPromiseInvoke=pinvoke) ->\n    pinvoke = (args...) ->\n      # Guard for expired credentials\n      refreshCredentialsPromise.then ->\n        oldPromiseInvoke.apply(null, args)\n      .catch (e) ->\n        if e.code is \"CredentialsError\"\n          console.info \"Refreshing credentials after CredentialsError\", e\n          refreshCredentialsPromise = refreshCredentials()\n\n          refreshCredentialsPromise.then ->\n            # Retry calls after refreshing expired credentials\n            oldPromiseInvoke.apply(null, args)\n        else\n          throw e\n\n  localCache = {}\n  metaCache = {}\n\n  uploadToS3 = (bucket, key, file, options={}) ->\n    {cacheControl} = options\n\n    cacheControl ?= 0\n\n    # Optimistically Cache\n    localCache[key] = file\n    metaCache[key] =\n      ContentType: file.type\n      LastModified: new Date\n\n    pinvoke bucket, \"putObject\",\n      Key: key\n      ContentType: file.type\n      Body: file\n      CacheControl: \"max-age=#{cacheControl}\"\n\n  getRemote = (bucket, key) ->\n    cachedItem = localCache[key]\n\n    if cachedItem\n      if cachedItem instanceof Blob\n        return Promise.resolve(cachedItem)\n      else\n        return Promise.reject(cachedItem)\n\n    pinvoke bucket, \"getObject\",\n      Key: key\n    .then (data) ->\n      {Body, ContentType} = data\n\n      new Blob [Body],\n        type: ContentType\n    .then (data) ->\n      localCache[key] = data\n    .catch (e) ->\n      # Cache Not Founds too, since that's often what is slow\n      localCache[key] = e\n      throw e\n\n  deleteFromS3 = (bucket, key) ->\n    localCache[key] = new Error \"Not Found\"\n    delete metaCache[key]\n\n    pinvoke bucket, \"deleteObject\",\n      Key: key\n\n  list = promiseChoke (dir) ->\n    prefix = \"#{id}#{dir}\"\n\n    pinvoke bucket, \"listObjects\",\n      Prefix: prefix\n      Delimiter: delimiter\n    .then (result) ->\n      results = result.CommonPrefixes.map (p) ->\n        FolderEntry p.Prefix, id, prefix\n      .concat result.Contents.map (o) ->\n        FileEntry o, id, prefix, bucket\n      .map (entry) ->\n        fetchMeta(entry, bucket)\n\n      Promise.all results\n\n  fetchFileMeta = (key, bucket) ->\n    cachedItem = metaCache[key]\n\n    if cachedItem\n      return Promise.resolve(cachedItem)\n\n    pinvoke bucket, \"headObject\",\n      Key: key\n    .then (result) ->\n      metaCache[key] = result\n\n      return result\n\n  fetchMeta = (entry, bucket) ->\n    Promise.resolve()\n    .then ->\n      return entry if entry.folder\n\n      fetchFileMeta(entry.remotePath, bucket)\n      .then (meta) ->\n        entry.type = meta.ContentType\n        entry.updatedAt = new Date(meta.LastModified)\n\n        return entry\n\n  notify = (eventType, path) ->\n    (result) ->\n      self.trigger eventType, path\n      return result\n\n  FolderEntry = (path, id, prefix) ->\n    folder: true\n    path: path.replace(id, \"\")\n    relativePath: path.replace(prefix, \"\")\n    remotePath: path\n\n  FileEntry = (object, id, prefix, bucket) ->\n    path = object.Key\n\n    entry =\n      path: path.replace(id, \"\")\n      relativePath: path.replace(prefix, \"\")\n      remotePath: path\n      size: object.Size\n\n    return entry\n\n  self = Object.assign Bindable(),\n    clearCache: ->\n      localCache = {}\n      metaCache = {}\n\n    read: (path) ->\n      unless path.startsWith delimiter\n        path = delimiter + path\n\n      key = \"#{id}#{path}\"\n\n      getRemote(bucket, key)\n      .then notify \"read\", path\n\n    write: (path, blob, options) ->\n      unless path.startsWith delimiter\n        path = delimiter + path\n\n      key = \"#{id}#{path}\"\n\n      uploadToS3 bucket, key, blob, options\n      .then notify \"write\", path\n\n    delete: (path) ->\n      unless path.startsWith delimiter\n        path = delimiter + path\n\n      key = \"#{id}#{path}\"\n\n      deleteFromS3 bucket, key\n      .then notify \"delete\", path\n\n    list: (dir=\"/\") ->\n      unless dir.startsWith delimiter\n        dir = \"#{delimiter}#{dir}\"\n\n      unless dir.endsWith delimiter\n        dir = \"#{dir}#{delimiter}\"\n\n      list dir\n      .then notify \"list\", dir\n"},"lib/test/fs/s3.coffee":{"content":"S3FS = require \"/lib/fs/s3\"\n\n# mock bucket interface\nbucket =\n  getObject: (data, cb) ->\n    cb(null)\n  headObject: (data, cb) ->\n    cb(null, {\n      ContentType: \"text/plain\"\n      LastModified: \"2021-05-05T01:00:46.000Z\"\n    })\n  putObject: (data, cb) ->\n    cb(null)\n  listObjects: (data, cb) ->\n    cb(null, {\n      CommonPrefixes: []\n      Contents: [{\n        Key: \"yo\"\n        Size: 3\n      }]\n    })\n\ndescribe \"S3FS\", ->\n  it \"Should cache the proper date when writing then listing\", ->\n    id = \"wat\"\n    \n    refreshCredentials = ->\n\n    fs = S3FS(id, bucket, refreshCredentials)\n\n    fs.write \"yo\", new Blob ['hey']\n    .then ->\n      fs.list()\n    .then (entries) ->\n      assert.notEqual entries[0].updatedAt.toString(), \"Invalid Date\"\n"},"lib/fs/dexie.coffee":{"content":"Bindable = require \"../bindable\"\n\nFolderEntry = (path, prefix) ->\n  folder: true\n  path: prefix + path\n  relativePath: path\n\n# DexieDB Containing our FS\nDexieFSDB = (dbName='fs') ->\n  db = new Dexie dbName\n\n  db.version(1).stores\n  \tfiles: 'path, blob, size, type, createdAt, updatedAt'\n\n  return db\n\n# FS Wrapper to Dexie database\nmodule.exports = (dbName='fs') ->\n  db = DexieFSDB(dbName)\n\n  Files = db.files\n\n  notify = (eventType, path) ->\n    (result) ->\n      self.trigger eventType, path\n      return result\n\n  self =\n    # Read a blob from a path\n    read: (path) ->\n      Files.get(path)\n      .then (result) ->\n        result?.blob\n      .then notify \"read\", path\n\n    # Write a blob to a path\n    write: (path, blob) ->\n      throw new Error \"Can only write blobs to the file system\" unless blob instanceof Blob\n      now = +new Date\n\n      Files.put\n        path: path\n        blob: blob\n        size: blob.size\n        type: blob.type\n        createdAt: now\n        updatedAt: now\n      .then notify \"write\", path\n\n    # Delete a file at a path\n    delete: (path) ->\n      Files.delete(path)\n      .then notify \"delete\", path\n\n    # List files and folders in a directory\n    list: (dir) ->\n      Files.where(\"path\").startsWith(dir).toArray()\n      .then (files) ->\n        folderPaths = {}\n\n        files = files.filter (file) ->\n          file.relativePath = file.path.replace(dir, \"\")\n\n          if file.relativePath.match /\\// # folder\n            folderPath = file.relativePath.replace /\\/.*$/, \"/\"\n            folderPaths[folderPath] = true\n            return\n          else\n            return file\n\n        folders = Object.keys(folderPaths).map (folderPath) ->\n          FolderEntry folderPath, dir\n\n        return folders.concat(files)\n\n  Bindable(undefined, self)\n"},"lib/polyfill.coffee":{"content":"startsWith = (search, rawPos) ->\n  if rawPos > 0\n    pos = rawPos|0\n  else\n    pos = 0\n\n  @substring(pos, pos + search.length) is search\n\nendsWith = (search, l) ->\n  length = @length\n  if l is undefined or l > length\n    l = length\n\n  @substring(l - search.length, l) is search\n\nString::endsWith ?= endsWith\nString::startsWith ?= startsWith\n\n# Export for testing\nmodule.exports =\n  startsWith: startsWith\n  endsWith: endsWith\n"},"lib/test/polyfill.coffee":{"content":"{\n  startsWith\n  endsWith\n} = require \"../polyfill\"\n\ndescribe \"Polyfill\", ->\n  describe \"String\", ->\n    it \"startsWith\", ->\n      assert \"\".startsWith\n\n      assert.equal startsWith.call(\"abcd\", \"ab\"), true\n      assert.equal startsWith.call(\"abcd\", \"ab\", -1), true\n      assert.equal startsWith.call(\"abcd\", \"ab\", 0), true\n      assert.equal startsWith.call(\"abcd\", \"ab\", 1), false\n      assert.equal startsWith.call(\"abcd\", \"b\", 1), true\n\n    it \"endsWith\", ->\n      assert \"\".endsWith\n\n      assert.equal endsWith.call(\"abcd\", \"cd\"), true\n      assert.equal endsWith.call(\"raddad\", \"rad\", 3), true\n"},"lib/fs/pkg.coffee":{"content":"Bindable = require \"../bindable\"\n\n# FS Wrapper to a pixie package\n# source is mounted as the root\n#\n# opts.persist receive the package object and return a promise that\n# is fulfilled when the package is persisted\n#\n# opts.compile receives a blob and returns a promise with a string of the\n# compiled output\nmodule.exports = (pkg, opts={}) ->\n  notify = (eventType, path) ->\n    (result) ->\n      self.trigger eventType, path\n      return result\n\n  persist = opts.persist or noop\n  compile = opts.compile or -> Promise.resolve()\n\n  compileAndWrite = (path, blob) ->\n    writeSource = blob.text()\n    .then (text) ->\n      srcPath = sourcePath(path)\n      pkg.source[srcPath] =\n        content: text\n        type: blob.type or \"\"\n        path: srcPath\n\n    # Compilers expect blob to be annotated with the path\n    blob.path = path\n\n    writeCompiled = compile(blob)\n    .then (compiledSource) ->\n      if typeof compiledSource is \"string\"\n        pkg.distribution[withoutAllExtensions(sourcePath(path))] =\n          content: compiledSource\n      else\n        console.warn \"Can't package files like #{path} yet\", compiledSource\n\n    Promise.all [writeSource, writeCompiled]\n    .then persist\n\n  self =\n    # Read a blob from a path\n    read: (path) ->\n      entry = pkg.source[sourcePath(path)]\n      throw new Error \"File not found at: #{path}\" unless entry\n\n      {content, type} = entry\n      type ?= \"\"\n\n      blob = new Blob [content],\n        type: type\n\n      Promise.resolve blob\n      .then notify \"read\", path\n\n    # Write a blob to a path\n    write: (path, blob) ->\n      compileAndWrite(path, blob)\n      .then notify \"write\", path\n\n    # Delete a file at a path\n    delete: (path) ->\n      Promise.resolve()\n      .then ->\n        delete pkg.source[sourcePath(path)]\n      .then notify \"delete\", path\n\n    # List files and folders in a directory\n    list: (dir) ->\n      sourceDir = sourcePath(dir)\n\n      Promise.resolve()\n      .then ->\n        Object.keys(pkg.source).filter (path) ->\n          path.indexOf(sourceDir) is 0\n        .map (path) ->\n          path: \"/\" + path\n          relativePath: path.replace(sourceDir, \"\")\n          type: pkg.source[path].type or \"\"\n      .then (files) ->\n        folderPaths = {}\n\n        files = files.filter (file) ->\n          if file.relativePath.match /\\// # folder\n            folderPath = file.relativePath.replace /\\/.*$/, \"/\"\n            folderPaths[folderPath] = true\n            return\n          else\n            return file\n\n        folders = Object.keys(folderPaths).map (folderPath) ->\n          FolderEntry folderPath, dir\n\n        return folders.concat(files)\n      .then notify \"list\", dir\n\n  Bindable undefined, self\n\n# Utils\n\nFolderEntry = (path, prefix) ->\n  folder: true\n  path: prefix + path\n  relativePath: path\n\n# Keys in the package's source object don't begin with slashes\nsourcePath = (path) ->\n  path.replace(/^\\//, \"\")\n\n# Strip out extension suffixes\nwithoutAllExtensions = (path) ->\n  path.replace(/\\.[^\\/]*$/,\"\")\n\nnoop = ->\n"},"lib/test/fs/dexie.coffee":{"content":"DexieFS = require \"/lib/fs/dexie\"\n\n# TODO: Can't test IndexedDB in this sandbox\ndescribe.skip \"DexieFS\", ->\n  it \"Should use indexeddb as a file system\", ->\n    dfs = DexieFS(\"test\")\n\n    dfs.write \"/test.txt\", new Blob [\"heyy\"]\n    .then ->\n      dfs.read(\"/test.txt\")\n"},"lib/test/fs/pkg.coffee":{"content":"PkgFS = require \"/lib/fs/pkg\"\n\nrequire \"/lib/extensions\"\n\ntestPkg =\n  source:\n    \"hello.coffee\":\n      content: \"alert hello\"\n    \"test/wat.js\":\n      content: \"assert(wat);\"\n  distribution: {}\n\noldPersist = (pkg) ->\n  # Persist entire pkg\n  system.writeFile persistencePath, JSON.toBlob(pkg)\n\n# old compile was system.compileFile\n\ndescribe \"Package FS\", ->\n  it \"should read files\", ->\n    pfs = PkgFS testPkg\n\n    pfs.read(\"hello.coffee\")\n    .then (blob) ->\n      blob.text()\n    .then (src) ->\n      assert.equal src, \"alert hello\"\n\n  it \"should write files\", ->\n    persistCalled = false\n    persist = -> persistCalled = true\n    compileCalled = false\n    compile = (blob) -> \n      compileCalled = true\n      blob.text()\n\n    pfs = PkgFS testPkg,\n      persist: persist\n      compile: compile\n\n    content = \"alert('hey');\"\n    pfs.write \"/yolo.js\", new Blob([content])\n    .then ->\n      assert compileCalled\n      assert persistCalled\n\n      assert.equal testPkg.source[\"yolo.js\"].content, content\n      assert.equal testPkg.distribution[\"yolo\"].content, content\n"},"lib/fs/index.coffee":{"content":"MountFS = require \"./mount\"\nDexieFS = require \"./dexie\"\nPkgFS = require \"./pkg\"\nS3FS = require \"./s3\"\n\nmodule.exports = Object.assign\n  Dexie: DexieFS\n  Mount: MountFS\n  Package: PkgFS\n  S3: S3FS\n, require \"./util\"\n"},"lib/test/fs/index.coffee":{"content":""},"lib/aws/cognito.coffee":{"content":"###\nCognito info:\n\nJS SDK: https://github.com/aws/amazon-cognito-identity-js\nPricing: https://aws.amazon.com/cognito/pricing/\nAdding Social Identity Providers: http://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-social.html\n\nhttps://whimsy.auth.us-east-1.amazoncognito.com/oauth2/idpresponse\n###\n\n_LL = require \"./_lazy\"\n\nmodule.exports = ({identityPoolId, poolData}) ->\n  userPool = null\n\n  # Creating user pool and setting region must happen after lazy loading\n  _init = ->\n    userPool ?= new AWSCognito.CognitoIdentityServiceProvider.CognitoUserPool(poolData)\n    # Region needs to be set if not already set previously elsewhere.\n    AWS.config.region ?= 'us-east-1'\n\n  # Wrap lazy loader function to call _init logic\n  LL = (fn) ->\n    _LL (args...) ->\n      _init()\n      fn.apply(this, args)\n\n  configureAWSFor = (session, resolve, reject) ->\n    token = session.getIdToken().getJwtToken()\n\n    loginKey = \"cognito-idp.us-east-1.amazonaws.com/#{poolData.UserPoolId}\"\n    loginsConfig = {}\n    loginsConfig[loginKey] = token\n\n    AWS.config.credentials = new AWS.CognitoIdentityCredentials\n      IdentityPoolId: identityPoolId\n      Logins: loginsConfig\n\n    # refreshes credentials\n    AWS.config.credentials.refresh (error) ->\n      if error\n        reject error\n      else\n        # TODO: AWS is global :(\n        # Probably doesn't matter because ZineOS is single user\n        resolve AWS\n\n      return\n    return\n\n  mapAttributes = (attributes) ->\n    return unless attributes\n\n    Object.keys(attributes).map (name) ->\n      value = attributes[name]\n\n      new AWSCognito.CognitoIdentityServiceProvider.CognitoUserAttribute\n        Name: name\n        Value: value\n\n  self =\n    signUp: LL (username, password, attributes) ->\n      attributeList = mapAttributes(attributes)\n\n      new Promise (resolve, reject) ->\n        userPool.signUp username, password, attributeList, null, (err, result) ->\n          if err\n            return reject(err)\n\n          cognitoUser = result.user\n\n          # User will need to confirm email address\n          resolve cognitoUser\n\n    authenticate: LL (username, password) ->\n      authenticationData =\n        Username : username\n        Password : password\n\n      authenticationDetails = new AWSCognito.CognitoIdentityServiceProvider.AuthenticationDetails(authenticationData)\n\n      userData =\n        Username : username\n        Pool : userPool\n\n      cognitoUser = new AWSCognito.CognitoIdentityServiceProvider.CognitoUser(userData)\n\n      new Promise (resolve, reject) ->\n        cognitoUser.authenticateUser authenticationDetails,\n          onSuccess: (session) ->\n            configureAWSFor session, resolve, reject\n          onFailure: reject\n\n    cachedUser: LL ->\n      new Promise (resolve, reject) ->\n        cognitoUser = userPool.getCurrentUser()\n\n        if cognitoUser\n          cognitoUser.getSession (err, session) ->\n            if err\n              reject err\n              return\n\n            configureAWSFor(session, resolve, reject)\n        else\n          setTimeout ->\n            reject new Error \"No cached user\"\n\n    logout: ->\n      # Clear global AWS credentials if present\n      delete AWS?.config.credentials\n\n      try # return if we can't access local storage\n        localStorage\n      catch\n        return\n\n      Object.keys(localStorage).filter (key) ->\n        key.match /^CognitoIdentityServiceProvider/\n      .forEach (key) ->\n        delete localStorage[key]\n      return\n"},"lib/test/aws/cognito.coffee":{"content":"Cognito = require \"/lib/aws/cognito\"\n\n{cognito:config} = PACKAGE.config\ncognito = Cognito(config)\n\nS3FS = require \"/lib/fs/s3\"\n\nmocha.setup\n  globals: ['AWSCognito', 'AmazonCognitoIdentity', 'AWS']\n\n# Skipped for performance\ndescribe \"Cognito\", ->\n  describe.skip \"Remote calls\", ->\n    it \"should authenticate\", ->\n      @timeout 5000\n      # Sign up creates a user account and sends an email to the given address\n      # Test creation by uncommenting this line:\n      #\n      # Cognito().signUp(\"daniel+test@danielx.net\", \"yo yo yo\")\n  \n      # The user will need to confirm their address before logging in\n      console.log config\n      cognito.authenticate(\"daniel+test@danielx.net\", \"yo yo yo\")\n  \n    it \"should reject with invalid password\", (done) ->\n      cognito.authenticate(\"daniel+test@danielx.net\", \"not the password\")\n      .catch (e) ->\n        assert.equal e.code, \"NotAuthorizedException\"\n        assert.equal e.statusCode, 400\n        done()\n  \n      return\n\n  it \"shouldn't throw an error on logout even when sandboxed\", ->\n    cognito.logout()\n\n# Skipped for performance\ndescribe.skip \"S3FS\", ->\n  it \"should auth with cognito and gate api requests to the same path\", ->\n    @timeout 5000\n\n    cognito.authenticate(\"daniel+test@danielx.net\", \"yo yo yo\")\n    .then ->\n      id = AWS.config.credentials.identityId\n\n      bucket = new AWS.S3\n        params:\n          Bucket: \"whimsy-fs\"\n  \n      refreshCredentials = ->\n        # This has the side effect of updating the global AWS object's credentials\n        cognito.cachedUser()\n        .then (AWS) ->\n          # Copy the updated credentials to the bucket\n          bucket.config.credentials = AWS.config.credentials\n        .catch console.debug\n  \n      fs = S3FS(id, bucket, refreshCredentials)\n\n      # View in network tab that only one request is in flight per dir\n      fs.list(\"/\")\n      fs.list(\"/\")\n      fs.list(\"/\")\n      fs.list(\"/\")\n      fs.list(\"/\")\n      fs.list(\"/\")\n      fs.list(\"/\")\n      fs.list(\"/\")\n      fs.list(\"/\")\n      fs.list(\"/\")\n      fs.list(\"/\")\n\n      fs.list(\"/public\")\n      fs.list(\"/public\")\n      fs.list(\"/public\")\n"},"workspaces/size.coffee":{"content":"fmt = (size) ->\n  size.toString().padStart(10)\n\ntotal = 0\n\nitems = Object.keys(PACKAGE.source).map (name) ->\n  [name, PACKAGE.source[name].content.length]\n.sort (a, b) ->\n  b[1] - a[1]\n.map ([name, size]) ->\n  total += size\n\n  fmt(size) + \" \" + name\n.join(\"\\n\")\n\npre = document.createElement \"pre\"\npre.textContent = \"\"\"\n#{items}\n------------------------------\n#{fmt(total)} Source Total\n\n#{fmt(JSON.stringify(PACKAGE).length)} Package Total\n\"\"\"\npre.style.overflow = \"auto\"\n\ndocument.body.appendChild pre\n"},"data/views/size.coffee":{"content":""},"docs/getting-started.md":{"content":"Getting Started\n===\n\nIncluding this as a dependency named `!system` in `pixie.cson` hooks it into the\nauto-launching capabilities of ZineOS and Prometheus.\n\nIt provides `system` and `application` as global variables after taking care of\nregistering communication with the host if present.\n\n`system`\n---\n\n`system` provides tools that many apps use.\n\n\n### fs\n\n`system.fs`\n\nFilesystem components that let you read, write, list, and delete files. It\nalso provides a `MountFS` that lets you mount systems at specific paths.\n\n### ui\n\n`system.ui`\n\nUser interface components, windows, lists, trees, and more!\n\n### util\n\n`system.util`\n\n`style`\n\n`extensions`\n\n`application`\n---\n\n\n\nInternals\n----\n\nApps launched from Prometheus and ZineOS use the special dependency `!system` to\nwrap the launcher code for the package.\n\n```javascript\nrequire(\"!system\").launch(function() {\n  #{code}\n});\n```\n\nThe `!system` dependency provides a `launch` method that takes a function of the\ncode to run when the system is ready. It takes care of connecting to the host,\nif present, setting up Postmaster for communication, adding an unload/error\nlisteners, and configuring the environment for the app.\n\nIn theory there could be any number of compatible `!system` packages as long as\nthey wire up the communications and adhere to the `launch` interface. Currently\nthere is only [danielx.net/system](https://danielx.net/system/docs/README.html)\nand the communication protocol is still an evolving area.\n\n"},"lib/postmaster.coffee":{"content":"###\r\n\r\nPostmaster wraps the `postMessage` API with promises.\r\n\r\n###\r\n\r\ndefaultReceiver = self\r\nackTimeout = 1000\r\npmId = 0\r\n\r\nmodule.exports = Postmaster = (self={}) ->\r\n  name = \"#{defaultReceiver.name}-#{++pmId}\"\r\n\r\n  info = ->\r\n    self.logger.info(name, arguments...)\r\n\r\n  debug = ->\r\n    self.logger.debug(name, arguments...)\r\n\r\n  dominant = Postmaster.dominant()\r\n  self.remoteTarget ?= -> dominant\r\n  self.receiver ?= -> defaultReceiver\r\n  self.ackTimeout ?= -> ackTimeout\r\n  self.delegate ?= self\r\n  self.logger ?=\r\n    info: ->\r\n    debug: ->\r\n  self.targetOrigin ?= \"*\"\r\n  self.token ?= Math.random()\r\n\r\n  send = (data) ->\r\n    target = self.remoteTarget()\r\n    if self.token\r\n      data.token = self.token\r\n\r\n    data.from = name\r\n\r\n    if !target\r\n      throw new Error \"No remote target\"\r\n\r\n    info(\"->\", data)\r\n\r\n    if !Worker? or target instanceof Worker\r\n      target.postMessage data\r\n    else\r\n      target.postMessage data, self.targetOrigin\r\n\r\n    return\r\n\r\n  listener = (event) ->\r\n    {data, source} = event\r\n    target = self.remoteTarget()\r\n\r\n    # Only listening to messages from `opener`\r\n    # event.source becomes undefined during the `onunload` event\r\n    # We can track a token and match to allow the final message in this case\r\n    if source is target or (source is undefined and data.token is self.token)\r\n      event.stopImmediatePropagation() # \r\n      info \"<-\", data\r\n      {type, method, params, id} = data\r\n\r\n      switch type\r\n        when \"ack\"\r\n          pendingResponses[id]?.ack = true\r\n        when \"response\"\r\n          pendingResponses[id].resolve data.result\r\n        when \"error\"\r\n          pendingResponses[id].reject data.error\r\n        when \"message\"\r\n          Promise.resolve()\r\n          .then ->\r\n            if source\r\n              send\r\n                type: \"ack\"\r\n                id: id\r\n\r\n            if typeof self.delegate[method] is \"function\"\r\n              self.delegate[method](params...)\r\n            else\r\n              throw new Error \"`#{method}` is not a function\"\r\n          .then (result) ->\r\n            if source\r\n              send\r\n                type: \"response\"\r\n                id: id\r\n                result: result\r\n          .catch (error) ->\r\n            if typeof error is \"string\"\r\n              message = error\r\n            else\r\n              message = error.message\r\n\r\n            if source\r\n              send\r\n                type: \"error\"\r\n                id: id\r\n                error:\r\n                  message: message\r\n                  stack: error.stack\r\n    else\r\n      debug \"DROP message\", event, \"source #{JSON.stringify(data.from)} does not match target\"\r\n\r\n  receiver = self.receiver()\r\n  receiver.addEventListener \"message\", listener\r\n  self.dispose = ->\r\n    receiver.removeEventListener \"message\", listener\r\n    info \"DISPOSE\"\r\n\r\n  pendingResponses = {}\r\n  msgId = 0\r\n\r\n  clear = (id) ->\r\n    debug \"CLEAR PENDING\", id\r\n    clearTimeout pendingResponses[id].timeout\r\n    delete pendingResponses[id]\r\n\r\n  self.send = (method, params...) ->\r\n    new Promise (resolve, reject) ->\r\n      id = ++msgId\r\n\r\n      ackWait = self.ackTimeout()\r\n      timeout = setTimeout ->\r\n        unless resp.ack\r\n          info \"TIMEOUT\", resp\r\n          resp.reject new Error \"No ack received within #{ackWait}\"\r\n      , ackWait\r\n\r\n      debug \"STORE PENDING\", id\r\n      pendingResponses[id] = resp =\r\n        timeout: timeout\r\n        resolve: (result) ->\r\n          debug \"RESOLVE\", id, result\r\n          resolve(result)\r\n          clear(id)\r\n        reject: (error) ->\r\n          debug \"REJECT\", id, error\r\n          reject(error)\r\n          clear(id)\r\n\r\n      try\r\n        send\r\n          type: \"message\"\r\n          method: method\r\n          params: params\r\n          id: id\r\n      catch e\r\n        setTimeout ->\r\n          reject(e)\r\n        , 0\r\n\r\n      return\r\n\r\n  self.invokeRemote = ->\r\n    console.warn \"Postmaster#invokeRemote is deprecated. Use #send instead.\"\r\n    self.send(arguments...)\r\n\r\n  info \"INITIALIZE\"\r\n\r\n  return self\r\n\r\nPostmaster.dominant = ->\r\n  if window? # iframe or child window context\r\n    opener or ((parent != window) and parent) or undefined\r\n  else # Web Worker Context\r\n    self\r\n"},"lib/test/postmaster.coffee":{"content":"# NOTE: It is important to call dispose at the end of each test because\r\n# Postmaster attaches a global event listener and needs to clean up.\r\nPostmaster = require \"/lib/postmaster\"\r\n\r\nrandId = ->\r\n  Math.random().toString(36).substr(2)\r\n\r\nscriptContent = ->\r\n  # This function is toString'd to be inserted into the sub-frames.\r\n  fn = ->\r\n    pm = Postmaster\r\n      delegate:\r\n        echo: (value) ->\r\n          return value\r\n        throws: ->\r\n          throw new Error(\"This always throws\")\r\n        promiseFail: ->\r\n          Promise.reject new Error \"This is a failed promise\"\r\n        send: ->\r\n          pm.send(arguments...)\r\n\r\n  \"\"\"\r\n    (function() {\r\n    var module = {};\r\n    (function() {\r\n    #{PACKAGE.distribution[\"lib/postmaster\"].content};\r\n    })();\r\n    var Postmaster = module.exports;\r\n    (#{fn.toString()})();\r\n    })();\r\n  \"\"\"\r\n\r\nhtmlContent = -> \"\"\"\r\n<html>\r\n  <body>\r\n    <script>#{scriptContent()}<\\/script>\r\n  </body>\r\n</html>\r\n\"\"\"\r\n\r\nsrcUrl = ->\r\n  URL.createObjectURL new Blob [htmlContent()],\r\n    type: \"text/html; charset=utf-8\"\r\n\r\ndataUrl = -> \"data:text/html;base64,#{btoa(htmlContent())}\"\r\n\r\ntestFrame = (fn) ->\r\n  iframe = document.createElement('iframe')\r\n  iframe.name = \"iframe-#{randId()}\"\r\n  iframe.src = srcUrl()\r\n  document.body.appendChild(iframe)\r\n\r\n  postmaster = Postmaster\r\n    remoteTarget: ->\r\n      iframe.contentWindow\r\n\r\n  iframe.addEventListener \"load\", ->\r\n    fn(postmaster)\r\n    .finally ->\r\n      iframe.remove()\r\n      postmaster.dispose()\r\n\r\n  return\r\n\r\ndescribe \"Postmaster\", ->\r\n  # Can't open child windows from within sandboxed iframes?\r\n  it.skip \"should work with openened windows\", (done) ->\r\n    childWindow = window.open(srcUrl(), \"child-#{randId()}\", \"width=200,height=200\")\r\n\r\n    postmaster = Postmaster\r\n      remoteTarget: -> childWindow\r\n\r\n    childWindow.addEventListener \"load\", ->\r\n      postmaster.send \"echo\", 5\r\n      .then (result) ->\r\n        assert.equal result, 5\r\n      .then ->\r\n        done()\r\n      , (error) ->\r\n        done(error)\r\n      .then ->\r\n        childWindow.close()\r\n        postmaster.dispose()\r\n\r\n    return\r\n\r\n  it \"should work with iframes\", (done) ->\r\n    testFrame (postmaster) ->\r\n      postmaster.send \"echo\", 17\r\n      .then (result) ->\r\n        assert.equal result, 17\r\n      .then done, done\r\n\r\n    return\r\n\r\n  it \"should handle the remote call throwing errors\", (done) ->\r\n    testFrame (postmaster) ->\r\n      postmaster.send \"throws\"\r\n      .then ->\r\n        done new Error \"Expected an error\"\r\n      , (error) ->\r\n        done()\r\n\r\n    return\r\n\r\n  it \"should throwing a useful error when the remote doesn't define the function\", (done) ->\r\n    testFrame (postmaster) ->\r\n      postmaster.send \"undefinedFn\"\r\n      .then ->\r\n        done new Error \"Expected an error\"\r\n      , (error) ->\r\n        done()\r\n\r\n    return\r\n\r\n  it \"should handle the remote call returning failed promises\", (done) ->\r\n    testFrame (postmaster) ->\r\n      postmaster.send \"promiseFail\"\r\n      .then ->\r\n        done new Error \"Expected an error\"\r\n      , (error) ->\r\n        done()\r\n\r\n    return\r\n\r\n  it \"should be able to go around the world\", (done) ->\r\n    testFrame (postmaster) ->\r\n      postmaster.yolo = (txt) ->\r\n        \"heyy #{txt}\"\r\n      postmaster.send \"send\", \"yolo\", \"cool\"\r\n      .then (result) ->\r\n        assert.equal result, \"heyy cool\"\r\n      .then ->\r\n        done()\r\n      , (error) ->\r\n        done(error)\r\n\r\n    return\r\n\r\n  it.skip \"should work with web workers\", (done) ->\r\n    blob = new Blob [scriptContent()], type: \"application/javascript\"\r\n    jsUrl = URL.createObjectURL(blob)\r\n\r\n    worker = new Worker(jsUrl)\r\n\r\n    postmaster = Postmaster\r\n      remoteTarget: -> worker\r\n      receiver: -> worker\r\n\r\n    setTimeout ->\r\n      postmaster.send \"echo\", 17\r\n      .then (result) ->\r\n        assert.equal result, 17\r\n      .then ->\r\n        done()\r\n      , (error) ->\r\n        done(error)\r\n      .finally ->\r\n        worker.terminate()\r\n    , 100\r\n\r\n    return\r\n\r\n  it \"should fail quickly when contacting a window that doesn't support Postmaster\", (done) ->\r\n    iframe = document.createElement('iframe')\r\n    document.body.appendChild(iframe)\r\n\r\n    childWindow = iframe.contentWindow\r\n    postmaster = Postmaster\r\n      remoteTarget: -> childWindow\r\n      ackTimeout: -> 30\r\n\r\n    postmaster.send \"echo\", 5\r\n    .catch (e) ->\r\n      if e.message.match /no ack/i\r\n        done()\r\n      else\r\n        done(1)\r\n    .finally ->\r\n      iframe.remove()\r\n      postmaster.dispose()\r\n\r\n    return\r\n\r\n  it \"should return a rejected promise when unable to send to the target\", (done) ->\r\n    postmaster = Postmaster\r\n      remoteTarget: -> null\r\n    \r\n    postmaster.send \"yo\"\r\n    .then ->\r\n      done throw new Error \"Expected an error\"\r\n    , (e) ->\r\n      assert.equal e.message, \"No remote target\"\r\n      done()\r\n    .catch done\r\n    .finally ->\r\n      postmaster.dispose()\r\n\r\n    return\r\n\r\n  it \"should log\", ->\r\n    called = false\r\n\r\n    postmaster = Postmaster\r\n      logger:\r\n        info: ->\r\n          called = true\r\n\r\n    assert called\r\n    postmaster.dispose()\r\n"},"lib/test/ui.coffee":{"content":"{AceEditor} = ui = require \"../ui/index\"\n\ndescribe \"ui\", ->\n  it \"should provide an ace editor view\", ->\n    {initSession, modeFor} = AceEditor\n    assert initSession\n    assert modeFor\n\n    assert.equal modeFor(\"file.js\"), \"javascript\"\n"},"templates/reader-input.coffee":{"content":"module.exports = (options={}) ->\n  input = document.createElement('input')\n  input.type = \"file\"\n  input.setAttribute \"accept\", options.accept\n\n  input.onchange = (e) ->\n    options.select? input.files[0]\n\n  return input\n"},"lib/mousetrap.js":{"content":"/* mousetrap v1.6.3 craig.is/killing/mice */\r\n(function(q,u,c){function v(a,b,g){a.addEventListener?a.addEventListener(b,g,!1):a.attachEvent(\"on\"+b,g)}function z(a){if(\"keypress\"==a.type){var b=String.fromCharCode(a.which);a.shiftKey||(b=b.toLowerCase());return b}return n[a.which]?n[a.which]:r[a.which]?r[a.which]:String.fromCharCode(a.which).toLowerCase()}function F(a){var b=[];a.shiftKey&&b.push(\"shift\");a.altKey&&b.push(\"alt\");a.ctrlKey&&b.push(\"ctrl\");a.metaKey&&b.push(\"meta\");return b}function w(a){return\"shift\"==a||\"ctrl\"==a||\"alt\"==a||\r\n\"meta\"==a}function A(a,b){var g,d=[];var e=a;\"+\"===e?e=[\"+\"]:(e=e.replace(/\\+{2}/g,\"+plus\"),e=e.split(\"+\"));for(g=0;g<e.length;++g){var m=e[g];B[m]&&(m=B[m]);b&&\"keypress\"!=b&&C[m]&&(m=C[m],d.push(\"shift\"));w(m)&&d.push(m)}e=m;g=b;if(!g){if(!p){p={};for(var c in n)95<c&&112>c||n.hasOwnProperty(c)&&(p[n[c]]=c)}g=p[e]?\"keydown\":\"keypress\"}\"keypress\"==g&&d.length&&(g=\"keydown\");return{key:m,modifiers:d,action:g}}function D(a,b){return null===a||a===u?!1:a===b?!0:D(a.parentNode,b)}function d(a){function b(a){a=\r\na||{};var b=!1,l;for(l in p)a[l]?b=!0:p[l]=0;b||(x=!1)}function g(a,b,t,f,g,d){var l,E=[],h=t.type;if(!k._callbacks[a])return[];\"keyup\"==h&&w(a)&&(b=[a]);for(l=0;l<k._callbacks[a].length;++l){var c=k._callbacks[a][l];if((f||!c.seq||p[c.seq]==c.level)&&h==c.action){var e;(e=\"keypress\"==h&&!t.metaKey&&!t.ctrlKey)||(e=c.modifiers,e=b.sort().join(\",\")===e.sort().join(\",\"));e&&(e=f&&c.seq==f&&c.level==d,(!f&&c.combo==g||e)&&k._callbacks[a].splice(l,1),E.push(c))}}return E}function c(a,b,c,f){k.stopCallback(b,\r\nb.target||b.srcElement,c,f)||!1!==a(b,c)||(b.preventDefault?b.preventDefault():b.returnValue=!1,b.stopPropagation?b.stopPropagation():b.cancelBubble=!0)}function e(a){\"number\"!==typeof a.which&&(a.which=a.keyCode);var b=z(a);b&&(\"keyup\"==a.type&&y===b?y=!1:k.handleKey(b,F(a),a))}function m(a,g,t,f){function h(c){return function(){x=c;++p[a];clearTimeout(q);q=setTimeout(b,1E3)}}function l(g){c(t,g,a);\"keyup\"!==f&&(y=z(g));setTimeout(b,10)}for(var d=p[a]=0;d<g.length;++d){var e=d+1===g.length?l:h(f||\r\nA(g[d+1]).action);n(g[d],e,f,a,d)}}function n(a,b,c,f,d){k._directMap[a+\":\"+c]=b;a=a.replace(/\\s+/g,\" \");var e=a.split(\" \");1<e.length?m(a,e,b,c):(c=A(a,c),k._callbacks[c.key]=k._callbacks[c.key]||[],g(c.key,c.modifiers,{type:c.action},f,a,d),k._callbacks[c.key][f?\"unshift\":\"push\"]({callback:b,modifiers:c.modifiers,action:c.action,seq:f,level:d,combo:a}))}var k=this;a=a||u;if(!(k instanceof d))return new d(a);k.target=a;k._callbacks={};k._directMap={};var p={},q,y=!1,r=!1,x=!1;k._handleKey=function(a,\r\nd,e){var f=g(a,d,e),h;d={};var k=0,l=!1;for(h=0;h<f.length;++h)f[h].seq&&(k=Math.max(k,f[h].level));for(h=0;h<f.length;++h)f[h].seq?f[h].level==k&&(l=!0,d[f[h].seq]=1,c(f[h].callback,e,f[h].combo,f[h].seq)):l||c(f[h].callback,e,f[h].combo);f=\"keypress\"==e.type&&r;e.type!=x||w(a)||f||b(d);r=l&&\"keydown\"==e.type};k._bindMultiple=function(a,b,c){for(var d=0;d<a.length;++d)n(a[d],b,c)};v(a,\"keypress\",e);v(a,\"keydown\",e);v(a,\"keyup\",e)}if(q){var n={8:\"backspace\",9:\"tab\",13:\"enter\",16:\"shift\",17:\"ctrl\",\r\n18:\"alt\",20:\"capslock\",27:\"esc\",32:\"space\",33:\"pageup\",34:\"pagedown\",35:\"end\",36:\"home\",37:\"left\",38:\"up\",39:\"right\",40:\"down\",45:\"ins\",46:\"del\",91:\"meta\",93:\"meta\",224:\"meta\"},r={106:\"*\",107:\"+\",109:\"-\",110:\".\",111:\"/\",186:\";\",187:\"=\",188:\",\",189:\"-\",190:\".\",191:\"/\",192:\"`\",219:\"[\",220:\"\\\\\",221:\"]\",222:\"'\"},C={\"~\":\"`\",\"!\":\"1\",\"@\":\"2\",\"#\":\"3\",$:\"4\",\"%\":\"5\",\"^\":\"6\",\"&\":\"7\",\"*\":\"8\",\"(\":\"9\",\")\":\"0\",_:\"-\",\"+\":\"=\",\":\":\";\",'\"':\"'\",\"<\":\",\",\">\":\".\",\"?\":\"/\",\"|\":\"\\\\\"},B={option:\"alt\",command:\"meta\",\"return\":\"enter\",\r\nescape:\"esc\",plus:\"+\",mod:/Mac|iPod|iPhone|iPad/.test(navigator.platform)?\"meta\":\"ctrl\"},p;for(c=1;20>c;++c)n[111+c]=\"f\"+c;for(c=0;9>=c;++c)n[c+96]=c.toString();d.prototype.bind=function(a,b,c){a=a instanceof Array?a:[a];this._bindMultiple.call(this,a,b,c);return this};d.prototype.unbind=function(a,b){return this.bind.call(this,a,function(){},b)};d.prototype.trigger=function(a,b){if(this._directMap[a+\":\"+b])this._directMap[a+\":\"+b]({},a);return this};d.prototype.reset=function(){this._callbacks={};\r\nthis._directMap={};return this};d.prototype.stopCallback=function(a,b){if(-1<(\" \"+b.className+\" \").indexOf(\" mousetrap \")||D(b,this.target))return!1;if(\"composedPath\"in a&&\"function\"===typeof a.composedPath){var c=a.composedPath()[0];c!==a.target&&(b=c)}return\"INPUT\"==b.tagName||\"SELECT\"==b.tagName||\"TEXTAREA\"==b.tagName||b.isContentEditable};d.prototype.handleKey=function(){return this._handleKey.apply(this,arguments)};d.addKeycodes=function(a){for(var b in a)a.hasOwnProperty(b)&&(n[b]=a[b]);p=null};\r\nd.init=function(){var a=d(u),b;for(b in a)\"_\"!==b.charAt(0)&&(d[b]=function(b){return function(){return a[b].apply(a,arguments)}}(b))};d.init();\"undefined\"!==typeof module&&module.exports&&(module.exports=d);\"function\"===typeof define&&define.amd&&define(function(){return d})}})(\"undefined\"!==typeof window?window:null,\"undefined\"!==typeof window?document:null);\r\n"},"lib/test/mousetrap.js":{"content":""},"docs/app.md":{"content":"App\n===\n\nThe system runtime provides an app base with many useful methods:\n\n- `confirmUnsaved`\n- `currentPath` Observable string\n- `drop` handler that receives an array of Files on a drop event.\n- `exit`\n- `extend`\n- `hotkey`\n- `new`\n- `open`\n- `save`\n- `saved` Observable bool representing the state of the app, saved or not.\n- `saveAs`\n- `paste` handler that receives an array of Files on a paste event.\n\nYour app must provide these to make use of the paste/drop/fileIO interfaces.\n\n- `loadFile`\n- `newFile`\n- `saveData`\n\nOne can optionally provide a `menu` property:\n\n```\nmenu: \"\"\"\n  File\n    New\n    Open\n    Save\n    Save As\n    ---\n    Exit\n  Edit\n    Undo\n    Redo\n    Resize -> doResize\n  Example\n    Item One\n    Item Two\n    Submenu\n      Sub Item One\n      Sub Item Two\n\"\"\"\n```\n\nThis menu micro-format defines a menubar for your app. The menu items have the\nname given delegating to the method of the same name except non-alphanumeric\ncharacters are removed and the initial character is downcased, i.e. `Save As` ->\n`saveAs`.\n\nOther app methods that you can optionally define:\n\n- `title`\n\nTitle will be observed and piped to the \"host application\" if it is a function with\nobservable dependencies.\n\nThe main idea is to combine all the common behaviors into one comprehensive\nfocal point.\n\nGlossary\n--------\n\n### Observables\n\nObservable properties are functions that store a value when called\nwith one argument and return that value when called with zero arguments. They\nhave an `observe` method.\n\nObservable functions will automatically re-execute if they depend on observable\nproperties. They may be composed of any number of observable properties or\nfunctions.\n\n### Host\n\nCommunication channel to the host environment.\n\n```\nhost.writeFile(path, blob)\n```\n\nThe host environment is ZineOS or none if standalone. There may be other possible\nhost environments, it could be the host OS if running in Electron.\n\n### Host Application\n\nThe ZineOS application object running inside the ZineOS frame. This holds info\nabout saved status, the title, a handle to the iframe or app element, and the\nactual window element in ZineOS.\n\nIn standalone the host application is a thin wrapper over the browser chrome.\n\nIn summary the host application is the host environment's representation of this\napplication.\n"},"lib/runtime.coffee":{"content":"# runtime is what prepares the environment for user apps\n# we hook up the postmaster and proxy messages to the OS\n\n{version} = require \"../pixie\"\n\nPostmaster = require \"./postmaster\"\n{applyStyle, Observable, Style} = require \"../lib/ui/index\"\n\nRuntime = (system, opts={}) ->\n  if opts.applyStyle\n    applyStyle(Style.all, 'system')\n\n  opts.logger ?=\n    info: ->\n    debug: ->\n\n  externalObservables = {}\n\n  # Queue up messages until a delegate is assigned\n  heldApplicationMessages = []\n\n  postmaster = Postmaster\n    logger: opts.logger\n    # For receiving messages from the system\n    delegate:\n      application: (method, args...) ->\n        if applicationTarget.delegate\n          applicationTarget.delegate[method](args...)\n        else\n          # This promise should keep the channel unresolved until the future\n          new Promise (resolve, reject) ->\n            heldApplicationMessages.push (delegate) ->\n              try\n                resolve delegate[method](args...)\n              catch e\n                reject e\n  \n      updateSignal: (name, newValue) ->\n        externalObservables[name](newValue)\n  \n      fn: (handlerId, args) ->\n        # TODO: `this` is null but should be `system` here for bound events.\n        eventListeners[handlerId].apply(null, args)\n\n  remoteExists = postmaster.remoteTarget()\n\n  applicationTarget =\n    observeSignal: (name, handler) ->\n      observable = Observable()\n      externalObservables[name] = observable\n\n      observable.observe handler\n\n      # Invoke the handler with the initial value\n      postmaster.send \"application\", \"observeSignal\", name\n      .then handler\n\n  # For sending messages to ZineOS application side\n  applicationProxy = new Proxy applicationTarget,\n    get: (target, property, receiver) ->\n      target[property] or\n      ->\n        return unless remoteExists\n        postmaster.send \"application\", property, arguments...\n    set: (target, property, value, receiver) ->\n      if property is \"delegate\"\n        heldApplicationMessages.forEach (fn)->\n          fn(value)\n\n        heldApplicationMessages = []\n\n      target[property] = value\n\n      return target[property]\n\n  lastEventListenerId = 0\n  eventListeners = {}\n  readyPromise = null\n  hostTarget =\n    ready: ->\n      return readyPromise if readyPromise\n\n      if remoteExists\n        readyPromise = postmaster.send \"ready\",\n          ZineOSClient: version\n          token: postmaster.token\n        .then (hostConfig) ->\n          appData = hostConfig?.ZineOS\n\n          if appData\n            initializeOnZineOS(appData)\n\n          return hostConfig\n      else \n        # Quick resolve when there is no parent window to connect to\n        polyfillForStandalone()\n\n        readyPromise = Promise.resolve\n          standalone: true\n\n    # Bind listeners to system events, sending an id in place of a local function\n    # reference\n    on: (eventName, handler) ->\n      lastEventListenerId += 1\n\n      eventListeners[lastEventListenerId] = handler\n      postmaster.send \"system\", \"on\", eventName, lastEventListenerId\n\n    off: (eventName, handler) ->\n      [handlerId] = Object.keys(eventListeners).filter (id) ->\n        eventListeners[id] is handler\n\n      delete eventListeners[handlerId]\n      postmaster.send \"system\", \"off\", eventName, handlerId\n\n  hostTarget.target = hostTarget\n\n  # Unattached, standalone page. Use a systemTarget for that environment\n  # Currently mapping system.readFile to fetch\n  polyfillForStandalone = ->\n    Object.assign hostTarget,\n      readFile: (path) ->\n        fetch(path)\n        .then (response) ->\n          if 200 <= response.status < 300\n            response.blob()\n          else\n            throw new Error(response.statusText)\n      writeFile: (path, blob) ->\n        blob.download(path)\n\n  # Proxy to the host environment\n  # Host methods can be overridden by writing to the host target\n  # this allows us to polyfill for standalone environments (with no host)\n  # and provides bindings for event channels and others things (experimental).\n  host = new Proxy hostTarget,\n    get: (target, property, receiver) ->\n      if Object::hasOwnProperty.call(target, property)\n        target[property]\n      else\n        ->\n          postmaster.send \"system\", property, arguments...\n\n  # TODO: Also interesting would be to proxy observable arguments where we\n  # create the receiver on the opposite end of the membrane and pass messages\n  # back and forth like magic\n\n  initializeOnZineOS = ({id}) ->\n    applicationTarget.id = id\n\n    document.addEventListener \"mousedown\", ->\n      applicationProxy.raiseToTop()\n      .catch console.warn\n\n  BaseApp = require(\"./app/index\")(host, applicationProxy)\n\n  client =\n    # `postmaster` makes sense here since it is the client's postmaster instance\n    postmaster: postmaster\n\n  Object.assign system,\n    # Launch stuff\n    app:\n      Base: BaseApp\n    client: client\n    config: {} # Host config gets merged into here\n    host: host\n\n    # Backwards compatible host proxy methods\n    # TODO: deprecate?\n    readFile: ->\n      host.readFile arguments...\n    readTree: ->\n      host.readTree arguments...\n    writeFile: ->\n      host.writeFile arguments...\n\n  # Only return {system, application}\n  # Client utilities can be found in system.client\n  # TODO: Remove global `application`\n  application: applicationProxy\n  system: system\n\nmodule.exports = Runtime\n"},"lib/test/runtime.coffee":{"content":"mocha.globals(['OBSERVABLE_ROOT_HACK', \"application\"])\n\nsystemG = require \"/lib/exports\"\nSystemClient = require \"../runtime\"\n\nnullLogger =\n  info: ->\n  debug: ->\n\ndescribe \"Runtime\", ->\n  it \"should return system and application proxies\", ->\n    {system, application} = SystemClient(systemG)\n\n    assert system\n    assert application\n    \n    # Actual API\n    app = system.app.Base()\n    assert.equal app.currentPath(), \"\"\n    assert.equal app.saved(), true\n\n    # Cleanup\n    system.client.postmaster.dispose()\n\n  it \"should queue up messages until a delegate is assigned\", ->\n    new Promise (resolve, reject) ->\n      {system, application} = SystemClient(systemG)\n\n      {postmaster} = system.client\n\n      postmaster.delegate.application \"test1\", \"yo\"\n      .then (c) ->\n        assert.equal c, \"wat\"\n\n      postmaster.delegate.application \"test2\", \"yo2\"\n      .then (d) ->\n        assert.equal d, \"heyy\"\n        resolve()\n\n      application.delegate =\n        test1: (a) ->\n          assert.equal a, \"yo\"\n\n          return \"wat\"\n\n        test2: (b) ->\n          assert.equal b, \"yo2\"\n          return \"heyy\"\n\n      # Cleanup\n      system.client.postmaster.dispose()\n\n  it \"should connect when ready is called\", (done) ->\n    {system, application} = SystemClient(systemG, {\n      # logger: console\n    })\n\n    system.host.ready()\n    .then ->\n      done()\n      system.client.postmaster.dispose()\n\n    return\n\n  # This was madness to test, the earlier clients had their own postmasters \n  # listening!! Make sure to dispose shared resources!\n  it \"should launch with config\", ->\n    systemG.launch {\n      # logger: console\n    } , (config) ->\n      # Cleanup\n      system.client.postmaster.dispose()\n"},"lib/app/index.coffee":{"content":"# Handle basic file saving/loading/picking, displaying modals/ui. This maps\n# common UI patterns to the `host`'s `readFile` and `writeFile` methods.\n\n# Caller must provide `self` object with the following methods:\n#   `loadFile` Take a blob and path and load it as the application state.\n#   `saveData` Return a promise that will be fulfilled with a blob of the\n#     current application state.\n#   `newFile` Initialize the application to an empty state.\n\n# This extends the `self` object with:\n# `currentPath`\n# `drop`\n# `exit`\n# `new`\n# `open`\n# `save`\n# `saved`\n# `saveAs`\n\n# It is expected that there is only one FileIO per page,\n# additional apps spawn in iframes or separate windows for isolation.\n# We add a global drop listener here.\n\n## Events\n#\n# `boot`\n# `dispose`\n#\n# Thought: Would it be better to call these `start` and `finish`?\n\n{applyStyle, Drop, Jadelet, MenuBar, Modal, Observable, Style} = require \"../ui/index\"\n\n# TODO: This is expanding a bit beyond FileIO and into general IO of the\n# app in its environment. We should pass the application proxy in here too and\n# wire it up. The application proxy should also handle the interface to\n# standalone mode things like window.title onbeforeunload behavior, etc.\n\n# Some more thoughts on `application` here... it's not really the right place\n# it needs to be bound to the app after boot when it can listen to the app's\n# observable properties and bind them to window.title, etc.\n\nBindable = require \"../bindable\"\n\n{crudeRequire} = require \"../pkg/index\"\n\nTemplateLoader = require \"./template-loader\"\nHotkeys = require \"./hotkeys\"\n\n# host is used for readFile and writeFile\n# application is used for syncing with the OS App state:\n# - exit\n# - icon\n# - saved\n# - title\n#\n# and setting the delegate on boot to receive messages sent from the host.\n\nmodule.exports = (host, application) ->\n  (app={}) ->\n    app.saved ?= Observable true\n    app.currentPath ?= Observable \"\"\n    app.config ?= {}\n\n    # Includes\n    Bindable null, app\n    Hotkeys app\n\n    Object.assign app,\n      confirmUnsaved: ->\n        return Promise.resolve() if app.saved()\n  \n        new Promise (resolve, reject) ->\n          Modal.confirm \"You will lose unsaved progress, continue?\"\n          .then (result) ->\n            if result\n              resolve()\n            else\n              reject()\n\n      exit: ->\n        application.exit()\n\n      extend: Object.assign.bind(null, app)\n\n      # Accepts an array of dropped files\n      # returns true if we handled the event\n      # apps can override this to customize their behavior\n      drop: (files) ->\n        file = files[0]\n        app.loadFile file, file.name\n        return true\n\n      # Accepts an array of pasted files\n      # returns true if we handled the event\n      # apps can override this to customize their behavior\n      paste: (files) ->\n        file = files[0]\n        app.loadFile file, file.name\n        return true\n\n      new: ->\n        if app.saved()\n          app.currentPath \"\"\n          app.newFile()\n        else\n          app.confirmUnsaved()\n          .then ->\n            app.saved true\n            app.newFile()\n\n      open: ->\n        app.confirmUnsaved()\n        .then  ->\n          # TODO: File browser\n          # TODO: Delegate to specific strategies\n          Modal.prompt \"File Path\", app.currentPath()\n          .then (newPath) ->\n            if newPath\n              app.currentPath newPath\n            else\n              throw new Error \"No path given\"\n          .then (path) ->\n            host.readFile path, true\n            .then (file) ->\n              app.loadFile file, path\n        .catch (e) ->\n          throw e if e\n\n      reloadStyle: (cssText) ->\n        applyStyle cssText, \"app\"\n\n      save: ->\n        path = app.currentPath()\n        if path\n          Promise.resolve()\n          .then ->\n            app.saveData()\n          .then (blob) ->\n            # TODO: Delegate to specific save strategy\n            # zineOS, standalone, electron, ...\n            # maybe application.writeFile?\n            host.writeFile path, blob, true\n          .then ->\n            app.saved true\n            return path\n        else\n          app.saveAs()\n\n      saveAs: ->\n        Modal.prompt \"File Path\", app.currentPath()\n        .then (path) ->\n          if path\n            app.currentPath path\n            app.save()\n\n    # Detecting standalone config flag and provide alternative open and save\n    # methods\n    if system.config?.standalone\n      ReaderInput = require \"../../templates/reader-input\"\n\n      # Override chooser to use local PC\n      app.open = ->\n        Modal.show ReaderInput\n          accept: app.accept?()\n          select: (file) ->\n            Modal.hide()\n            app.loadFile file\n    \n      # Override save to present download\n      app.save = ->\n        Modal.prompt \"File name\", \"newfile.txt\"\n        .then (name) ->\n          app.saveData()\n        .then (blob) ->\n          blob.download()\n\n    # Provide drop event\n    # TODO: Remove drop handlers on dispose\n    Drop document, (e) ->\n      return if e.defaultPrevented\n\n      files = e.dataTransfer.files\n\n      if files.length\n        e.preventDefault() if app.drop files\n\n    # Provide paste event\n    # TODO: Remove paste handlers on dispose\n    document.addEventListener \"paste\", (e) ->\n      return if e.defaultPrevented\n      \n      {clipboardData} = e\n      \n      files = clipboardData.files\n\n      if files.length\n        if app.paste files\n          return e.preventDefault()\n\n      files = Array::map.call e.clipboardData.items, (item) ->\n        item.getAsFile()\n      .filter (file) -> file\n\n      if files.length\n        e.preventDefault() if app.paste files\n\n    try\n      app.T ?= {}\n      TemplateLoader app.pkg, app.T\n\n    try\n      app.version = crudeRequire(app.pkg.distribution.pixie.content).version\n\n    # `boot` triggers\n    app.on \"boot\", ->\n      # Auto-apply base and app styles\n      unless app.config.baseStyle is false\n        applyStyle Style.all, \"base\"\n      if @style\n        applyStyle @style, \"app\"\n      else\n        try\n          applyStyle crudeRequire(app.pkg.distribution.style.content), \"app\"\n\n      # Auto-menu from menu string\n      if @menu\n        menuBar = MenuBar\n          items: @menu\n          handlers: @\n\n        document.body.appendChild menuBar.element\n        app.on \"dispose\", ->\n          menuBar.element.remove()\n          Jadelet.dispose menuBar.element\n\n      if @element\n        document.body.appendChild @element\n      else if @template\n        @element = Jadelet.exec(@template)(this)\n        document.body.appendChild @element\n      else if @T.App\n        @element = @T.App this\n        document.body.appendChild @element\n\n      # Bind host application pieces\n      application.delegate = @\n      # auto-bind application title\n      # Pipes title changes to os application window, etc.\n      if @title?\n        Observable -> application.title getProp app, \"title\"\n\n      if @icon?\n        Observable ->\n          application.icon getProp app, \"icon\"\n\n      # Pipe saved state to os app state\n      if @saved?\n        Observable -> application.saved getProp app, \"saved\"\n\n      # TODO: onbeforeunload?\n\n    app.on \"dispose\", ->\n      if @element\n        @element.remove()\n        Jadelet.dispose @element\n\n    return app\n\ngetProp = (context, prop) ->\n  if typeof context[prop] is 'function'\n    context[prop]()\n  else\n    context[prop]\n"},"lib/test/app/index.coffee":{"content":"{Observable} = require \"/lib/ui/index\"\n\nAppGen = require \"/lib/app/index\"\n\nappProxyMock = {}\n\nBaseApp = AppGen({}, appProxyMock)\n\ndescribe \"App\", ->\n  it \"should provide a base app constructor\", ->\n    assert BaseApp()\n\n  it \"should work standalone\", ->\n    do (oldSystem=system) ->\n      global.system =\n        config:\n          standalone: true\n\n      assert BaseApp()\n\n      global.system = oldSystem\n\n  it \"should add a hotkey\", ->\n    app = BaseApp()\n\n    called = 0\n    app.hotkey \"a\", (e) ->\n      called++\n\n    e = new KeyboardEvent('keypress', {keyCode: 97})\n    document.dispatchEvent e\n\n    assert.equal called, 1\n\n  it \"should extend\", ->\n    app = BaseApp()\n\n    app.extend\n      cool: \"duder\"\n\n    assert.equal app.cool, \"duder\"\n\n  it \"should include bindable\", ->\n    app = BaseApp()\n\n    assert app.on\n    assert app.off\n    assert app.trigger\n\n  it \"should set title and icon\", ->\n    saved = icon = title = null\n\n    appProxyMock.title = (_title) ->\n      title = _title\n    appProxyMock.icon = (_icon) ->\n      icon = _icon\n    appProxyMock.saved = (_saved) ->\n      saved = _saved\n\n    app = BaseApp\n      title: \"yolo\"\n      icon: \"R\"\n      saved: false\n\n    app.trigger 'boot'\n    \n    assert.equal icon, \"R\"\n    assert.equal title, \"yolo\"\n    assert.equal saved, false\n\n  it \"should pass on observable title changes\", ->\n    title = null\n\n    appProxyMock.title = (_title) ->\n      title = _title\n\n    app = BaseApp\n      title: Observable \"wat\"\n\n    app.trigger 'boot'\n    assert.equal title, \"wat\"\n\n    app.title \"cool\"\n    assert.equal title, \"cool\"\n\n  it \"should apply app template by default on boot and remove on dispose\", ->\n    app = BaseApp\n      T:\n        App: system.ui.Jadelet.exec \"app Hello\"\n      menu: \"\"\"\n        Hello\n          Wat\n      \"\"\"\n\n    app.trigger 'boot'\n    assert document.querySelector 'app'\n    app.trigger 'dispose'\n    assert !document.querySelector('app')\n"},"lib/app/template-loader.coffee":{"content":"{crudeRequire} = require \"../pkg/index\"\n\nmodule.exports = (pkg, templates={}) ->\n  Object.keys(pkg.distribution).forEach (key) ->\n    if key.startsWith 'templates/'\n      templateName = key\n        .replace(/^templates\\//, \"\")\n        .replace(/^([a-z])|[_-]([a-z])/g, (m, a, b) ->\n          (a or b).toUpperCase()\n        )\n\n      try\n        templates[templateName] = crudeRequire pkg.distribution[key].content\n      catch e\n        console.warn e\n\n  return templates\n"},"lib/test/app/template-loader.coffee":{"content":"require \"/setup\"\nTemplateLoader = require \"/lib/app/template-loader\"\n\ndescribe \"template loader\", ->\n  it \"should load templates\", ->\n    tl = TemplateLoader(PACKAGE)\n\n    assert tl.Progress\n"},"lib/aws/index.coffee":{"content":"###\nInterface to all our AWS madness.\n\n###\n\n{urlSafeSHA256} = require \"../util/index\"\n\nLL = require \"./_lazy\"\n\nmodule.exports =\n  Cognito: require \"./cognito\"\n\n  # requires that the user has been authorized with Cognito\n  # TODO: catch and refresh credentials\n  api: LL (path, params={}) ->\n    url = new URL \"https://api.whimsy.space/#{path}\"\n    url.searchParams.append \"idpjwt\", Object.values(AWS.config.credentials.params.Logins)[0]\n\n    if params.body?\n      params.body = JSON.stringify params.body\n\n    fetch url, params\n\n  # Requires that the user has been authorized with Cognito\n  cdn: LL (blob) ->\n    S3 = new AWS.S3\n      params:\n        Bucket: \"whimsy-fs\"\n\n    S3.config.credentials = AWS.config.credentials\n    id = AWS.config.credentials.identityId\n\n    queryExisting = (sha) ->\n      fetch \"https://whimsy.space/cdn/#{sha}\",\n        method: 'HEAD'\n      .then (response) ->\n        response.status is 200\n\n    # Compute urlsafe sha256\n    urlSafeSHA256(blob)\n    .then (sha) ->\n      queryExisting(sha)\n      .then (found) ->\n        return sha if found\n\n        # Post to whimsy-fs/incoming/user-id/sha\n        S3.putObject\n          Key: \"incoming/#{id}/#{sha}\"\n          ContentType: blob.type\n          Body: blob\n        .promise()\n        .then ->\n          # Gently poll whimsy.space/cdn/sha\n          # reslove when available\n          new Promise (resolve, reject) ->\n            timeout = 1000\n            n = 0\n\n            check = ->\n              n += 1\n\n              if n <= 10\n                queryExisting(sha)\n                .then (found) ->\n                  if found\n                    resolve(sha)\n                  else\n                    setTimeout ->\n                      check()\n                    , timeout\n              else\n                reject()\n\n            check()\n\n  # Open an authenticated websocket connection to the whimsy.space server\n  ws: ->\n    url = new URL \"wss://ws.whimsy.space/\"\n    url.searchParams.append \"idpjwt\", Object.values(AWS.config.credentials.params.Logins)[0]\n\n    new WebSocket url\n\n  # Resolve with true if lazy loading succeeded\n  ready: LL ->\n    AWS\n"},"lib/test/aws/index.coffee":{"content":"require \"/lib/extensions\"\n\n{api, cdn, ready} = require \"/lib/aws/index\"\n\nCognito = require \"/lib/aws/cognito\"\n\n{cognito:config} = PACKAGE.config\ncognito = Cognito(config)\n\nmocha.setup\n  globals: ['AWSCognito', 'AmazonCognitoIdentity', 'AWS']\n\n# skipped for test performance, dependence on remote resources\ndescribe.skip \"AWS\", ->\n  it \"cdn\", ->\n    @timeout 30000\n    blob = new Blob [\"heyy234\"], type: \"text/plain\"\n\n    cognito.authenticate(\"daniel+test@danielx.net\", \"yo yo yo\")\n    .then ->\n      cdn blob\n\n  it \"api\", ->\n    @timeout 5000\n\n    cognito.authenticate(\"daniel+test@danielx.net\", \"yo yo yo\")\n    .then ->\n      api(\"\")\n\n  it \"ready\", ->\n    ready()\n"},"lib/util/index.coffee":{"content":"# Load scripts sequentially, prevents failures if there is a dependency\n# order\nloadScripts = (urls) ->\n  urls.reduce (p, url) ->\n    p.then ->\n      # Resolve if present\n      if document.querySelector \"script[src=#{JSON.stringify(url)}]\"\n        return Promise.resolve()\n\n      script = document.createElement \"script\"\n      script.src = url\n      document.body.appendChild script\n\n      return new Promise (resolve, reject) ->\n        script.onload = resolve\n        script.onerror = reject\n  , Promise.resolve()\n\n\n###\nCopy a string to user's OS (win,mac,linux) clipboard.\n###\ncopyToClipboard = (str) ->\n  el = document.createElement 'textarea'\n  el.value = str\n  el.setAttribute 'readonly', ''\n  el.style.position = 'absolute'                 \n  el.style.left = '-9999px'\n  document.body.appendChild el\n\n  el.select()\n  document.execCommand('copy')\n\n  document.body.removeChild(el)\n\nbufferToBase64 = (buffer) ->\n  window.btoa String.fromCharCode.apply null, new Uint8Array buffer\n\nbase64URLEncode = (base64String) ->\n  base64String.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\")\n\ndigest = (data) ->\n  crypto.subtle.digest(\"SHA-256\", data)\n\nescapeRegex = (string) ->\n  string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n\n# Match is an array of regex match results\n# unmatched runs of characters followed by single character matches, alternating\n# [\"\", \"a\", \" cool \", \"d\", \"og\"]\n# returns a score, higher is better\nscoreMatch = (match) ->\n  return unless match\n\n  # -1 so that if first char is matched it gets consecutive bonus\n  lastMatch = -1\n  pos = 0\n  match.slice(1).reduce (score, s, i) ->\n    if s.length is 0\n      value = 0\n    else\n      # Unmatched run\n      if i % 2 is 0\n        value = -s.length\n      else # Matched char\n        # Consecutive\n        if pos is 1 + lastMatch\n          lastMatch = pos\n          value = 8\n        else\n          value =  2\n\n    # console.log \"Score: #{score}, s: '#{s}', v: #{value}\"\n    pos += s.length\n    return score + value\n  , 0\n\nmodule.exports =\n  copyToClipboard: copyToClipboard\n  deprecationWarning: (msg, fn) ->\n    if typeof msg is \"function\"\n      fn = msg\n      msg = \"DEPRECATED\"\n\n    ->\n      console.warn msg\n      fn.apply(this, arguments)\n\n  escapeRegex: escapeRegex\n\n  fuzzyMatch: (term, items, asString=String) ->\n    re = RegExp(\"^\" +term.split(\"\").map (c) ->\n      \"([^#{escapeRegex c}]*)(#{escapeRegex c})\"\n    .join('') + '(.*)$', \"i\")\n\n    items.map (item) ->\n      if match = asString(item).match re\n        [item, scoreMatch match]\n    .filter (result) -> result?\n    .sort (a, b) ->\n      b[1] - a[1]\n    .map (result) ->\n      result[0]\n\n  groupBy: (array, fn) ->\n    array.reduce (result, item) ->\n      (result[fn(item)] ?= []).push item\n\n      return result\n    , {}\n\n  loadScripts: loadScripts\n\n  # Takes an array of urls, returns a decorator that checks the deps have resolved\n  # before invoking the given function\n  lazyLoader: (urls) ->\n    # Load the dependencies keeping a promise to limit to only one request\n    # clearing the limit on failure\n    # caching on success\n    loadingDeps = null\n    _load = ->\n      if loadingDeps\n        return loadingDeps\n\n      loadingDeps = loadScripts(urls).catch (e) ->\n        console.error e\n        loadingDeps = null\n        throw e\n\n    # Decorator to ensure initialized\n    return (fn) ->\n      (args...) ->\n        context = this\n        _load().then ->\n          fn.apply context, args\n\n  Postmaster: require \"../postmaster\"\n\n  # Limit promise requests with the same key to only one in flight\n  promiseChoke: (fn) ->\n    cache = {}\n  \n    (key) ->\n      cached = cache[key]\n      if cached\n        return cached\n  \n      cache[key] = fn(key).finally ->\n        delete cache[key]\n\n  throttle: (wait, func) ->\n    context = args = result = undefined\n    timeout = null\n    previous = 0\n\n    later = ->\n      previous = Date.now()\n      timeout = null\n      result = func.apply(context, args)\n      if !timeout\n        context = args = null\n\n    return ->\n      now = Date.now()\n      remaining = wait - (now - previous)\n      context = this\n      args = arguments\n      if remaining <= 0 || remaining > wait\n        if timeout\n          clearTimeout(timeout)\n          timeout = null\n\n        previous = now\n        result = func.apply(context, args)\n        if (!timeout)\n          context = args = null\n      else if !timeout\n        timeout = setTimeout(later, remaining)\n\n      return result\n\n  urlSafeSHA256: (blob) ->\n    blob.arrayBuffer()\n    .then digest\n    .then bufferToBase64\n    .then base64URLEncode\n"},"lib/test/util/index.coffee":{"content":"require \"/lib/extensions\"\n{\n  copyToClipboard\n  deprecationWarning\n  fuzzyMatch\n  groupBy\n  lazyLoader\n  promiseChoke\n  throttle\n  urlSafeSHA256\n} = require \"/lib/util/index\"\n\ndescribe \"util\", ->\n  describe \"copyToClipboard\", ->\n    it \"should copy a string to system clipboard\", ->\n      copyToClipboard \"yolo\"\n\n  describe \"deprecationWarning\", ->\n    it \"should display an error when calling a deprecated function\", ->\n      yolo = (x, y) ->\n        x + y\n\n      yolo = deprecationWarning \"util.yolo is deprecated use based.swag instead\", yolo\n\n      # Mock console\n      do (warn=console.warn) ->\n        called = false\n        console.warn = (msg) ->\n          called = true\n          assert.equal msg, \"util.yolo is deprecated use based.swag instead\"\n        assert.equal yolo(5, 3), 8\n        console.warn = warn\n        assert called\n\n  describe \"fuzzyMatch\", ->\n    it \"should match fuzzily\", ->\n      assert fuzzyMatch \"\", [\"\"]\n      assert fuzzyMatch \"\", [\"a\"]\n      assert fuzzyMatch \"a\", [\"a\"]\n\n      result = fuzzyMatch(\"acd\", [\n        \"a gcac\"\n        \"a cool dog\"\n        \"achieved\"\n        \"yoro\"\n        \"what act duder\"\n      ])\n\n      assert.equal result.length, 3\n\n\n  describe \"groupBy\", ->\n    it \"should group arrays by fn\", ->\n      a = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n      result = groupBy a, (n) ->\n        n % 3\n\n      assert.deepEqual result[0], [3, 6, 9]\n      assert.deepEqual result[1], [1, 4, 7]\n      assert.deepEqual result[2], [2, 5, 8]\n\n  describe \"lazyLoader\", ->\n    it \"should lazy load\", ->\n      LL = lazyLoader([])\n  \n      a = (x) -> x\n      b = LL a\n  \n      b(0).then (x) ->\n        assert.equal x, 0\n\n  describe \"promiseChoke\", ->\n    it \"should limit promise returning function execution to one at a time\", ->\n      called = 0\n      fn = promiseChoke ->\n        called++\n        new Promise (resolve) ->\n          setTimeout resolve\n\n      fn()\n      fn()\n      fn().then ->\n        assert.equal called, 1\n\n    it \"should reset on error\", ->\n      called = 0\n      fn = promiseChoke ->\n        called++\n        new Promise (resolve, reject) ->\n          setTimeout reject\n\n      fn()\n      fn()\n      fn().catch ->\n        assert.equal called, 1\n        fn().catch ->\n          assert.equal called, 2\n\n    it \"should key off of first argument\", ->\n      called = 0\n      fn = promiseChoke (x) ->\n        called++\n        new Promise (resolve) ->\n          setTimeout ->\n            resolve x\n\n      fn(1)\n      fn(2)\n      fn(5).then (v) ->\n        assert.equal v, 5\n        assert.equal called, 3\n\n  describe \"throttle\", ->\n    it \"should be called no more than once per time block\", (done) ->\n\n      called = 0\n\n      f = throttle 15, -> called += 1\n\n      f()\n      f()\n      f()\n\n      setTimeout ->\n        f()\n\n      setTimeout ->\n        f()\n      , 5\n\n      setTimeout ->\n        f()\n      , 10\n\n      setTimeout ->\n        if called != 2\n          done new Error \"Should have been called twice\"\n        else\n          done()\n      , 20\n\n  describe \"urlSafeSHA256\", ->\n    it \"should create a URL safe SHA256 for the blob\", ->\n      urlSafeSHA256(new Blob [\"yolo\"])\n      .then (str) ->\n        assert.equal str, \"MR_j_u0Wuc2N8PixUXvly4YEhwffSIm6jcN9TWiGbQI\"\n"},"lib/pkg/index.coffee":{"content":"###\n`pkg` holds utilities for bundling and launching packages as standalone blobs or\nin iframes.\n\n###\n\nhtmlToBlob = (htmlString) ->\n  new Blob [htmlString], type: \"text/html; charset=utf-8\"\n\nmetaTag = (name, content) ->\n  \"<meta name=#{JSON.stringify(name)} content=#{JSON.stringify(content)}>\"\n\nlinkTag = (rel, href) ->\n  \"<link rel=#{JSON.stringify(rel)} href=#{JSON.stringify(href)}>\"\n\n{lazyLoader} = require \"../util/index\"\n\nuglifyLoaded = lazyLoader [\"https://danielx.net/cdn/uglify/3.0.0.min.js\"]\n\nlatestRequire = require \"./require\"\n\n###\nConstruct an HTML file for the package.\n\nThe default behavior is to load the package's entry point but\nthat can be modified enter from any file in the package.\n\nIt also adds remote dependencies to the HTML head and wraps with\nthe system launch if present.\n\nThis is designed to be simple and general, any magic binding should happen in\nthe `!system` layer. Here we are only concerned with html tags and setting up\nthe package with `require`.\n\n`opts`\nadditionalDependencies: array of additional dependency scripts to include in\nthe html source. Useful for things like testing libraries, doc formatting, etc.\ncode: The code snippet to run, defaults to requiring the default package\nentry point.\nstylesheets: array of urls to add as stylesheet link tags\nsystemConfig: configuration parameters for the system runtime.\n###\nhtmlForPackage = (pkg, opts={}) ->\n  metas = [\n    '<meta charset=\"utf-8\">'\n    '<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">'\n  ]\n\n  {config, progenitor} = pkg\n  config ?= {}\n\n  {code, systemConfig} = opts\n\n  # by default launch from the packages entry point or main file.\n  code ?= \"\"\"\n    require('./#{pkg.entryPoint or \"main\"}');\n  \"\"\"\n  code = systemWrap(pkg, code, systemConfig)\n\n  {title, description, lang, iconURL, manifest} = config\n\n  if lang\n    langFragment =  \" lang=#{JSON.stringify(lang)}\"\n  else\n    langFragment = \"\"\n\n  if title\n    metas.push \"<title>#{title}</title>\"\n\n  if description\n    metas.push metaTag \"description\", description.replace(\"\\n\", \" \")\n\n  if iconURL\n    metas.push linkTag \"shortcut icon\", iconURL\n\n  if manifest\n    metas.push linkTag \"manifest\", \"./manifest.webmanifest\"\n\n  # Progenitor link can be used to for a built-in \"Edit this!\" feature\n  # TODO: Should url be href?\n  url = pkg.progenitor?.url\n  if url\n    metas.push linkTag \"progenitor\", url\n\n  (pkg.stylesheets || []).concat(opts.stylesheets || []).forEach (href) ->\n    metas.push linkTag \"stylesheet\", href\n\n  htmlToBlob \"\"\"\n    <!DOCTYPE html>\n    <html#{langFragment}>\n      <head>\n        #{metas.join(\"\\n    \")}\n        #{dependencyScripts(opts.additionalDependencies, pkg.remoteDependencies)}\n      </head>\n      <body>\n        <script>\n          #{latestRequire.packageWrapper(pkg, code)}\n        <\\/script>\n      </body>\n    </html>\n  \"\"\"\n\ndependencyScripts = (additionalDependencies=[], remoteDependencies=[]) ->\n  additionalDependencies.concat(remoteDependencies).map (src) ->\n    \"<script src=#{JSON.stringify(src)}><\\/script>\"\n  .join(\"\\n\")\n\nsystemWrap = (pkg, code, opts={}) ->\n  # The !system package self launches if detected\n  # the `config` param is the host's config, which is returned from `ready`\n  # on the host.\n  if pkg.dependencies?[\"!system\"]\n    \"\"\"\n      require(\"!system\").launch(#{JSON.stringify(opts)}, function(config) {\n        #{code}\n      });\n    \"\"\"\n  else\n    code\n\n###\nExecute a source code program within an environment.\n###\nexec = (program, env={}, context) ->\n  args = Object.keys(env)\n  values = args.map (name) -> env[name]\n\n  return Function(args..., program).apply(context, values)\n\n###\nExecute a single source program with no dependencies and return what it exports.\n###\ncrudeRequire = (program) ->\n  env =\n    module:\n      exports: {}\n\n  exec(program, env, env.module)\n\n  return env.module.exports\n\nminifyPackage = uglifyLoaded (pkg, logger) ->\n  initialSize = JSON.stringify(pkg).length\n\n  # Shallow Copy\n  pkg = Object.assign {}, pkg\n\n  # Remove source files\n  delete pkg.source\n\n  dist = pkg.distribution = Object.assign {}, pkg.distribution\n  Object.keys(dist).forEach (name) ->\n    # Remove test files from distribution\n    if name.match /^test\\/|\\/test\\//\n      delete dist[name]\n    # Remove empty files\n    file = dist[name]\n    if !file or !file.content\n      delete dist[name]\n      return\n\n    # Minify distribution files\n    {code} = UglifyJS.minify file.content,\n      toplevel: true\n    if code\n      dist[name] =\n        content: code\n    else\n      delete dist[name]\n\n  # Minify dependencies\n  Promise.all Object.keys(pkg.dependencies or {}).map (name) ->\n    minifyPackage(pkg.dependencies[name], logger).then (m) ->\n      pkg.dependencies[name] = m\n  .then ->\n    minSize = JSON.stringify(pkg).length\n    logger?.log \"Minified #{pkg.config.name}: #{initialSize} -> #{minSize} (#{((1 - minSize / initialSize)*100).toFixed(1)}% reduction)\" \n\n    return pkg\n\nmodule.exports = Object.assign {}, require(\"./compilers\"),\n  crudeRequire: crudeRequire\n  exec: exec\n  htmlForPackage: htmlForPackage\n  Require: require \"./require\"\n  jsForPackage: (pkg, globalName, customCode) ->\n    globalName ?= pkg.config.name\n    customCode ?= \"#{globalName} = require('./main')\"\n    require.packageWrapper(pkg, customCode)\n  minify: minifyPackage\n  ModLoader: require \"./mod-loader\"\n\n# TODO: This was extracted from the old editor, we can use it to split up\n# published docs and html files to require a shared remote package rather\n# than bundling inline of every published artifact.\n# TODO: preload package json as=\"fetch\" when exploring this again.\n# https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content\nremotePackageLauncher = (pkg, url) ->\n  \"\"\"\n    xhr = new XMLHttpRequest;\n    url = #{JSON.stringify(url)};\n    xhr.open(\"GET\", url, true);\n    xhr.responseType = \"json\";\n    xhr.onload = function() {\n      (function(PACKAGE) {\n        var src = #{JSON.stringify(PACKAGE.dependencies.require.distribution.main.content)};\n        var Require = new Function(\"PACKAGE\", \"return \" + src)({distribution: {main: {content: src}}});\n        var require = Require.generateFor(PACKAGE);\n        require('./' + PACKAGE.entryPoint);\n      })(xhr.response)\n    };\n    xhr.send();\n  \"\"\"\n"},"lib/test/pkg/index.coffee":{"content":"{\n  compile\n  crudeRequire\n  exec\n  htmlForPackage\n  jsForPackage\n  minify\n  ModLoader\n  registerCompiler\n  Require\n} = require \"/lib/pkg/index\"\n\nmocha.setup\n  globals: [\n    'CoffeeScript'\n    'marked'\n    'stylus'\n    'UglifyJS'\n  ]\n\ntestPkg = \n  distribution:\n    main:\n      content: \"alert('heyy');\"\n  dependencies:\n    \"!system\": PACKAGE\n  config:\n    description: \"Yolo\"\n\ndescribe \"pkg\", -> \n  describe \"htmlForPackage\", ->\n    it \"should blob up html\", ->\n      blob = htmlForPackage testPkg\n\n      assert blob instanceof Blob\n\n  describe \"compile\", ->\n    it \"should compile CoffeeScript by lazy loading compiler\", ->\n      compile(\"hello.coffee\", \"alert 'hello'\")\n\n    it \"should 'compile' JavaScript\", ->\n      src = \"alert('hello');\"\n      compile(\"hello.js\", src)\n      .then (program) ->\n        assert.equal program, src\n\n    it \"should compile markdown after lazy loading compiler\", ->\n      compile \"TODO.md\", \"\"\"\n        - [x] Lazy Load compilers\n      \"\"\"\n\n    it \"should compile stylus after lazy loading compiler\", ->\n      compile \"yo.styl\", \"\"\"\n        body\n          background-color: green\n      \"\"\"\n\n    it \"should fail if no known compiler\", ->\n      compile \"wat.doot\", \"\"\n      .catch (e) ->\n        assert.equal e.message, \"Couldn't compile 'wat.doot'. No compiler for '.doot'\"\n\n    it \"should register compilers\", ->\n      registerCompiler \"doot\", -> \"doot\"\n\n      compile \"wat.doot\", \"\"\n\n  describe \"exec\", ->\n    it \"should bind this\", ->\n      x = {}\n      y = exec(\"return this\", null, x)\n  \n      assert.equal x, y\n  \n    it \"env is optional\", ->\n      r = exec(\"return 5\")\n  \n      assert.equal r, 5\n\n    it \"should bind env values\", ->\n      r = exec(\"return a + this\", {a: 2}, 3)\n\n      assert.equal r, 5\n\n  describe \"crudeRequire\", ->\n    it \"should return what is exported\", ->\n      result = crudeRequire \"\"\"\n        module.exports = \"cool\";\n      \"\"\"\n\n      assert.equal result, \"cool\"\n\n  describe \"Require\", ->\n    it \"should be exported\", ->\n      assert Require\n\n  describe \"jsForPackge\", ->\n    it \"should generate a string of js\", ->\n      js = jsForPackage(PACKAGE)\n      assert typeof js is 'string'\n\n  describe.skip \"minify\", ->\n    it \"makes packages smaller\", ->\n      minify(PACKAGE, console)\n      .then console.log\n\n  describe \"Mod Loader\", ->\n    it \"should load remote modules\", ->\n      ModLoader\n"},"views/ace-editor.coffee":{"content":"###\nAn element containing an ace editor.\n\nDepends on ace and language tools extension being available in the environment.\n###\n\n{extensionFor} = require \"/lib/fs/index\"\n{deprecationWarning, loadScripts} = require \"/lib/util/index\"\n\ndefaultSessionOptions =\n  readOnly: false\n  focus: true\n\n# Commands to remove from Ace\nremoveCommands = \"\"\"\n  jumptomatching\n  modeSelect\n  modifyNumberDown\n  modifyNumberUp\n  movelinesdown\n  movelinesup\n\"\"\".split(/\\r?\\n/)\n\n# No way to safely check local storage without try/catch\ntry\n  defaultTheme = localStorage.getItem(\"ace/theme\")\ncatch\n  defaultTheme = \"dracula\"\n\nmodule.exports = AceEditor = ->\n  ace.require(\"ace/ext/language_tools\")\n  # Remove previous ace style if it exists\n  document.querySelector(\"style#ace_searchbox\")?.remove()\n  ace.require(\"ace/lib/dom\").importCssString(searchStyleCSS, \"ace_searchbox\")\n\n  element = document.createElement \"section\"\n\n  editor = ace.edit element\n  editor.$blockScrolling = Infinity\n  editor.setOptions\n    fontFamily: \"'Fira Code', 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace\"\n    fontSize: \"16px\"\n    enableBasicAutocompletion: true\n    enableLiveAutocompletion: true\n    highlightActiveLine: true\n    newLineMode: \"unix\"\n    theme: \"ace/theme/#{defaultTheme}\"\n\n  removeCommands.forEach (command) ->\n    editor.commands.removeCommand command\n\n  self =\n    # deprecated aceEditor -> editor\n    aceEditor: editor\n\n    editor: editor\n    element: element\n\n    hidden: (b) ->\n      if b\n        element.classList.add(\"hidden\")\n      else\n        element.classList.remove(\"hidden\")\n\n    goto: (line=0, selection) ->\n      editor.moveCursorTo(line, 0)\n\n      editor.clearSelection()\n\n      if selection\n        session = editor.getSession()\n        start = session.doc.indexToPosition(selection.start)\n        end = session.doc.indexToPosition(selection.end)\n        editor.selection.setSelectionRange({start, end})\n\n      editor.scrollToLine(line, true, false, ->)\n\n      return\n\n    setSession: (session, opts=defaultSessionOptions) ->\n      {readOnly, focus} = opts\n\n      editor.setSession(session)\n      editor.setReadOnly(readOnly)\n      if focus\n        editor.focus()\n\n      return\n\n    theme: (name) ->\n      editor.setTheme(\"ace/theme/#{name}\")\n      try\n        localStorage.setItem \"ace/theme\", name\n\n  return self\n\n###\nInitialize a session to track an observable\n###\ninitSession = (initialContent, contentObservable, mode=\"coffee\") ->\n  return unless contentObservable\n  session = ace.createEditSession(initialContent)\n\n  # Remove janky CSSLint rules\n  session.on \"changeMode\", ->\n    if session.$mode.$id is \"ace/mode/css\"\n      session.$worker.call 'setDisabledRules',\n        [\"ids|order-alphabetical|universal-selector|regex-selectors\"]\n\n  session.setUseWorker(false)\n\n  session.setMode(\"ace/mode/#{mode}\")\n  session.setUseSoftTabs true\n  session.setTabSize 2\n\n  updating = 0\n  contentObservable.observe (newContent) ->\n    return if updating\n    updating++\n    session.setValue newContent\n    updating--\n\n  # Bind session and file content\n  session.on \"change\", ->\n    return if updating\n    updating++\n    contentObservable session.getValue()\n    updating--\n\n  return session\n\nmodes =\n  cson: \"coffee\"\n  jadelet: \"jade\"\n  js: \"javascript\"\n  md: \"markdown\"\n  styl: \"stylus\"\n  txt: \"text\"\n\nObject.assign AceEditor,\n  initAceSession: deprecationWarning \"initAceSession -> initSession\", initSession\n  initSession: initSession\n\n  modeFor: (path) ->\n    extension = extensionFor(path)\n    return modes[extension] or extension\n\n  preload: ->\n    loadScripts [\"https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.7/ace.js\"]\n\nsearchStyleCSS = \"\"\"\n.ace_search {\n  background-color: var(--background-neutral);\n  color: var(--text-color);\n  border: 1px solid var(--neutral-dark);\n  border-top: 0;\n  margin: 0;\n  padding: 0.5em;\n  position: absolute;\n  top: 0;\n  z-index: 99;\n}\n.ace_search.right {\n  border-radius: 0px 0px 0px var(--border-radius);\n  border-right: 0;\n  right: -5px;\n}\n.ace_search.left {\n  border-left: 0 none;\n  border-radius: 0 0 var(--border-radius) 0;\n  left: -5px;\n}\n.ace_search > * {\n  margin-bottom: 0.5em;\n}\n.ace_search > *:last-child {\n  margin-bottom: 0;\n}\n.ace_searchbtn_close {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAcCAYAAABRVo5BAAAAZ0lEQVR42u2SUQrAMAhDvazn8OjZBilCkYVVxiis8H4CT0VrAJb4WHT3C5xU2a2IQZXJjiQIRMdkEoJ5Q2yMqpfDIo+XY4k6h+YXOyKqTIj5REaxloNAd0xiKmAtsTHqW8sR2W5f7gCu5nWFUpVjZwAAAABJRU5ErkJggg==) no-repeat 50% 0;\n  border-radius: var(--border-radius);\n  border: 0;\n  cursor: pointer;\n  padding: 0;\n  height: 14px;\n  width: 14px;\n  top: 9px;\n  right: 0.75em;\n  position: absolute;\n}\n.ace_searchbtn_close:hover {\n  background-color: #656565;\n  background-position: 50% 100%;\n}\n.ace_search_form,\n.ace_replace_form {\n  display: flex;\n  justify-content: start;\n  margin-right: 1.75em;\n}\n.ace_replace_form {\n  margin-right: 0;\n}\n.ace_search_field {\n  z-index: 1;\n}\n.ace_search_form.ace_nomatch > .ace_search_field {\n  border-color: var(--error-color);\n  outline: 2px solid var(--error-color);\n}\n.ace_searchbtn,\n.ace_button {\n  background-color: var(--background-color);\n  border: 1px solid var(--neutral-darker);\n  border-radius: var(--border-radius);\n  box-shadow: var(--shadow-low) var(--neutral-dark);\n  cursor: pointer;\n  display: inline-block;\n  padding: 0.125em 0.375em;\n}\n.ace_searchbtn:hover,\n.ace_button:hover {\n  background-color: var(--neutral-faintest);\n}\n.ace_searchbtn:active,\n.ace_button:active,\n.ace_searchbtn.active,\n.ace_button.active,\n.ace_searchbtn.checked,\n.ace_button.checked {\n  background-color: var(--neutral-faintest);\n  box-shadow: var(--shadow-low) var(--neutral-dark) inset;\n}\n.ace_searchbtn:last-child {\n  border-radius: 0 var(--border-radius) var(--border-radius) 0;\n}\n.ace_searchbtn.prev,\n.ace_searchbtn.next {\n  display: flex;\n  align-items: center;\n}\n.ace_searchbtn.prev:after,\n.ace_searchbtn.next:after {\n  content: \"\";\n  border: solid 0 var(--text-color);\n  width: 0.5em;\n  height: 0.5em;\n  border-width: 1px 0 0 1px;\n  display: inline-block;\n  transform: rotate(-45deg);\n}\n.ace_searchbtn.next:after {\n  border-width: 0 1px 1px 0;\n}\n.ace_search_options {\n  display: flex;\n  align-items: center;\n}\nuser-select: none {\n  clear: both;\n}\n.ace_search_counter {\n  padding: 0 0.5em;\n  margin-right: auto;\n}\n\"\"\""},"lib/test/core.coffee":{"content":"Model = require \"../core\"\n\ndescribe 'Model', ->\n  # Association Testing model\n  Person = (I) ->\n    person = Model(I)\n\n    person.attrObservable(\n      'firstName'\n      'lastName'\n      'suffix'\n    )\n\n    person.fullName = ->\n      \"#{@firstName()} #{@lastName()} #{@suffix()}\"\n\n    return person\n\n  it \"#extend\", ->\n    o = Model()\n\n    o.extend\n      test: \"jawsome\"\n\n    assert.equal o.test, \"jawsome\"\n\n  it \"#include\", ->\n    o = Model\n      test: \"my_val\"\n\n    M = (I, self) ->\n      self.attrObservable \"test\"\n\n      self.extend\n        test2: \"cool\"\n\n    ret = o.include M\n\n    assert.equal ret, o, \"Should return self\"\n\n    assert.equal o.test(), \"my_val\"\n    assert.equal o.test2, \"cool\"\n\n  it \"#include multiple\", ->\n    o = Model\n      test: \"my_val\"\n\n    M = (I, self) ->\n      self.extend\n        test2: \"cool\"\n\n    M2 = (I, self) ->\n      self.extend\n        test2: \"coolio\"\n\n    o.include M, M2\n\n    assert.equal o.test2, \"coolio\"\n\n  describe \"#attrData\", ->\n    pointProto =\n      add: ({x, y}) ->\n        @x += x\n        @y += y\n\n    Point = ({x, y}) ->\n      Object.create pointProto,\n        x:\n          value: x\n        y:\n          value: y\n\n    it \"should expose a property mapping to the instance data\", ->\n      model = Model\n        position:\n          x: 5\n          y: 5\n\n      model.attrData \"position\", Point\n\n      assert model.position.add\n\n      model.position.x = 12\n      assert.equal model.position.x, model.I.position.x\n\n      model.position =\n        x: 9\n        y: 6\n\n      assert.equal model.position.y, 6\n      assert.equal model.I.position.x, 9\n\n  describe \"#attrObservable\", ->\n    it 'should allow for observing of attributes', ->\n      model = Model\n        name: \"Duder\"\n\n      model.attrObservable \"name\"\n\n      model.name(\"Dudeman\")\n\n      assert.equal model.name(), \"Dudeman\"\n\n    it 'should bind properties to observable attributes', ->\n      model = Model\n        name: \"Duder\"\n\n      model.attrObservable \"name\"\n\n      model.name(\"Dudeman\")\n\n      assert.equal model.name(), \"Dudeman\"\n      assert.equal model.name(), model.I.name\n\n  describe \"#attrModel\", ->\n    it \"should be a model instance\", ->\n      model = Model\n        person:\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n\n      model.attrModel(\"person\", Person)\n\n      assert.equal model.person().fullName(), \"Duder Mannington Jr.\"\n\n    it \"should allow setting the associated model\", ->\n      model = Model\n        person:\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n\n      model.attrModel(\"person\", Person)\n\n      otherPerson = Person\n        firstName: \"Mr.\"\n        lastName: \"Man\"\n\n      model.person(otherPerson)\n\n      assert.equal model.person().firstName(), \"Mr.\"\n\n    it \"shouldn't update the instance properties after it's been replaced\", ->\n      model = Model\n        person:\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n\n      model.attrModel(\"person\", Person)\n\n      duder = model.person()\n\n      otherPerson = Person\n        firstName: \"Mr.\"\n        lastName: \"Man\"\n\n      model.person(otherPerson)\n\n      duder.firstName(\"Joe\")\n\n      assert.equal duder.I.firstName, \"Joe\"\n      assert.equal model.I.person.firstName, \"Mr.\"\n\n  describe \"#attrModels\", ->\n    it \"should have an array of model instances\", ->\n      model = Model\n        people: [{\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n        }, {\n          firstName: \"Mr.\"\n          lastName: \"Mannington\"\n          suffix: \"Sr.\"\n        }]\n\n      model.attrModels(\"people\", Person)\n\n      assert.equal model.people()[0].fullName(), \"Duder Mannington Jr.\"\n\n    it \"should track pushes\", ->\n      model = Model\n        people: [{\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n        }, {\n          firstName: \"Mr.\"\n          lastName: \"Mannington\"\n          suffix: \"Sr.\"\n        }]\n\n      model.attrModels(\"people\", Person)\n\n      model.people.push Person\n        firstName: \"JoJo\"\n        lastName: \"Loco\"\n\n      assert.equal model.people().length, 3\n      assert.equal model.I.people.length, 3\n\n    it \"should track pops\", ->\n      model = Model\n        people: [{\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n        }, {\n          firstName: \"Mr.\"\n          lastName: \"Mannington\"\n          suffix: \"Sr.\"\n        }]\n\n      model.attrModels(\"people\", Person)\n\n      model.people.pop()\n\n      assert.equal model.people().length, 1\n      assert.equal model.I.people.length, 1\n\n  describe \"#delegate\", ->\n    it \"should delegate to another method\", ->\n      model = Model\n        position:\n          x: 1\n          y: 2\n          z: 3\n\n      model.attrObservable \"position\"\n\n      model.delegate \"x\", \"y\", \"z\", to: \"position\"\n\n      assert.equal model.x, 1\n      assert.equal model.y, 2\n      assert.equal model.z, 3\n\n      model.x = 5\n\n      assert.equal model.position().x, 5\n      assert.equal model.I.position.x, 5\n\n    it \"should delegate to another property\", ->\n      model = Model\n        position:\n          x: 1\n          y: 2\n          z: 3\n\n      model.position = model.I.position\n\n      model.delegate \"x\", \"y\", \"z\", to: \"position\"\n\n      assert.equal model.x, 1\n      assert.equal model.y, 2\n      assert.equal model.z, 3\n\n      model.x = 5\n\n      assert.equal model.position.x, 5\n      assert.equal model.I.position.x, 5\n\n    it \"should delegate to methods just fine\", ->\n      model = Model\n        size:\n          width: 10\n          height: 20\n\n      model.attrData \"size\", ({width, height}) ->\n        width: -> width\n        height: -> height\n\n      model.delegate \"width\", \"height\", to: \"size\"\n\n      assert.equal model.width(), 10\n      assert.equal model.height(), 20\n\n  describe \"#toJSON\", ->\n    it \"should return an object appropriate for JSON serialization\", ->\n      model = Model\n        test: true\n\n      assert model.toJSON().test\n\n  describe \"#observeAll\", ->\n    it \"should observe all attributes of a simple model\"\n    ->  # TODO\n      model = Model\n        test: true\n        yolo: \"4life\"\n\n      model.observeAll()\n\n      assert model.test()\n      assert.equal model.yolo(), \"4life\"\n\n    it \"should camel case underscored names\"\n\n  describe \".defaults\", ->\n    it \"should expose defaults method\", ->\n      assert Model.defaults\n\n  describe \".extend\", ->\n    it \"should expose extend method\", ->\n      assert Model.extend\n"},"lib/exp/core-state.coffee":{"content":"###\nNOTE: This is experimenting with passing a single `self` reference rather than\n`I`, `self` as parameters. I don't think it is better, but it was worth\ncomparing.\n\nCore\n====\n\n`Core` provides helper methods to compose nested data models. It handles\ndata persistence and state binding. It provides common helpers and extensions\nto expand an object with modules.\n\nBy providing a common way to bind state and compose data we can use Core as a\ncommon building block for many types of objects.\n\n###\n\nObservable = require \"../observable\"\n\nmodule.exports = Model = (self={}) ->\n  defaults self,\n    __state: {}\n\n  extend self,\n    ###\n    Extends this object with methods from the passed in object. A shortcut for Object.extend(self, methods)\n    \n    >     I =\n    >       x: 30\n    >       y: 40\n    >       maxSpeed: 5\n    >\n    >     # we are using extend to give player\n    >     # additional methods that Model doesn't have\n    >     player = Model(I).extend\n    >       increaseSpeed: ->\n    >         I.maxSpeed += 1\n    >\n    >     player.increaseSpeed()\n    \n    ###\n    extend: (objects...) ->\n      extend self, objects...\n\n    ###\n    Includes a module in this object. A module is a constructor that takes one \n    parameter `self`. It extends the object with any additional behavior.\n    \n    >     myObject = Model()\n    >     myObject.include(Bindable)\n    \n    >     # now you can bind handlers to functions\n    >     myObject.bind \"someEvent\", ->\n    >       alert(\"wow. that was easy.\")\n    ###\n    include: (modules...) ->\n      for Module in modules\n        Module(self)\n\n      return self\n\n    ###\n    Bind a data model getter/setter to an attribute. The data model is bound directly to\n    the attribute and must be directly convertible to and from JSON.\n    ###\n    attrData: (name, DataModel) ->\n      self.__state[name] = DataModel(self.__state[name])\n\n      Object.defineProperty self, name,\n        get: ->\n          self.__state[name]\n        set: (value) ->\n          self.__state[name] = DataModel(value)\n\n    ###\n    Observe any number of attributes as observables. For each attribute name passed in we expose a public getter/setter method and listen to changes when the value is set.\n    ###\n    attrObservable: (names...) ->\n      names.forEach (name) ->\n        self[name] = Observable(self.__state[name])\n\n        self[name].observe (newValue) ->\n          self.__state[name] = newValue\n\n      return self\n\n    ###\n    Observe an attribute as a model. Treats the attribute given as an Observable\n    model instance exposing a getter/setter method of the same name. The Model\n    constructor must be passed explicitly.\n    ###\n    attrModel: (name, Model) ->\n      model = Model\n        __state: self.__state[name]\n\n      self[name] = Observable(model)\n\n      self[name].observe (newValue) ->\n        self.__state[name] = newValue.__state\n\n      return self\n\n    ###\n    Observe an attribute as an array of sub-models. This is the same as `attrModel`\n    except the attribute is expected to be an array of models rather than a single one.\n    ###\n    attrModels: (name, Model) ->\n      models = (self.__state[name] or []).map (x) ->\n        Model\n          __state: x\n\n      self[name] = Observable(models)\n\n      self[name].observe (newValue) ->\n        self.__state[name] = newValue.map (instance) ->\n          instance.__state\n\n      return self\n\n    ###\n    Delegate methods to another target. Makes it easier to compose rather than extend.\n    ###\n    delegate: (names..., {to}) ->\n      names.forEach (name) ->\n        Object.defineProperty self, name,\n          get: ->\n            receiver = getValue self, to\n            receiver[name]\n          set: (value) ->\n            receiver = getValue self, to\n            setValue receiver, name, value\n\n    ###\n    The JSON representation is kept up to date via the observable properites and resides in `I`.\n    ###\n    toJSON: ->\n      self.__state\n\n  return self\n\nisFn = (x) ->\n  typeof x is 'function'\n\ngetValue = (receiver, property) ->\n  if isFn receiver[property]\n    receiver[property]()\n  else\n    receiver[property]\n\nsetValue = (receiver, property, value) ->\n  target = receiver[property]\n\n  if isFn target\n    target.call(receiver, value)\n  else\n    receiver[property] = value\n\ndefaults = (target, objects...) ->\n  for object in objects\n    for name of object\n      unless target.hasOwnProperty(name)\n        target[name] = object[name]\n\n  return target\n\nextend = Object.assign\n\nObject.assign Model, {Observable, defaults, extend}\n"},"lib/test/exp/core-state.coffee":{"content":"Core = require \"/lib/exp/core-state\"\n\ndescribe 'Core', ->\n  # Association Testing model\n  Person = (self) ->\n    person = Core self\n\n    person.attrObservable(\n      'firstName'\n      'lastName'\n      'suffix'\n    )\n\n    person.fullName = ->\n      \"#{@firstName()} #{@lastName()} #{@suffix()}\"\n\n    return person\n\n  it \"#extend\", ->\n    o = Core()\n\n    o.extend\n      test: \"jawsome\"\n\n    assert.equal o.test, \"jawsome\"\n\n  it \"#include\", ->\n    o = Core\n      __state:\n        test: \"my_val\"\n\n    M = (self) ->\n      self.extend\n        test2: \"cool\"\n        test: ->\n          self.__state.test\n\n    ret = o.include M\n\n    assert.equal ret, o, \"Should return self\"\n\n    assert.equal o.test(), \"my_val\"\n    assert.equal o.test2, \"cool\"\n\n  it \"#include multiple\", ->\n    o = Core\n      test: \"my_val\"\n\n    M = (self) ->\n      self.extend\n        test2: \"cool\"\n\n    M2 = (self) ->\n      self.extend\n        test2: \"coolio\"\n\n    o.include M, M2\n\n    assert.equal o.test2, \"coolio\"\n\n  describe \"#attrData\", ->\n    pointProto =\n      add: ({x, y}) ->\n        @x += x\n        @y += y\n\n    Point = ({x, y}) ->\n      Object.create pointProto,\n        x:\n          value: x\n        y:\n          value: y\n\n    it \"should expose a property mapping to the instance data\", ->\n      model = Core\n        __state:\n          position:\n            x: 5\n            y: 5\n\n      model.attrData \"position\", Point\n\n      assert model.position.add\n\n      model.position.x = 12\n      assert.equal model.position.x, model.__state.position.x\n\n      model.position =\n        x: 9\n        y: 6\n\n      assert.equal model.position.y, 6\n      assert.equal model.__state.position.x, 9\n\n  describe \"#attrObservable\", ->\n    it 'should allow for observing of attributes', ->\n      model = Core\n        name: \"Duder\"\n\n      model.attrObservable \"name\"\n\n      model.name(\"Dudeman\")\n\n      assert.equal model.name(), \"Dudeman\"\n\n    it 'should bind properties to observable attributes', ->\n      model = Core\n        name: \"Duder\"\n\n      model.attrObservable \"name\"\n\n      model.name(\"Dudeman\")\n\n      assert.equal model.name(), \"Dudeman\"\n      assert.equal model.name(), model.__state.name\n\n  describe \"#attrModel\", ->\n    it \"should be a model instance\", ->\n      model = Core\n        __state:\n          person:\n            firstName: \"Duder\"\n            lastName: \"Mannington\"\n            suffix: \"Jr.\"\n\n      model.attrModel(\"person\", Person)\n\n      assert.equal model.person().fullName(), \"Duder Mannington Jr.\"\n\n    it \"should allow setting the associated model\", ->\n      model = Core\n        __state:\n          person:\n            firstName: \"Duder\"\n            lastName: \"Mannington\"\n            suffix: \"Jr.\"\n\n      model.attrModel(\"person\", Person)\n\n      otherPerson = Person\n        __state:\n          firstName: \"Mr.\"\n          lastName: \"Man\"\n\n      model.person(otherPerson)\n\n      assert.equal model.person().firstName(), \"Mr.\"\n\n    it \"shouldn't update the instance properties after it's been replaced\", ->\n      model = Core\n        __state:\n          person:\n            firstName: \"Duder\"\n            lastName: \"Mannington\"\n            suffix: \"Jr.\"\n\n      model.attrModel(\"person\", Person)\n\n      duder = model.person()\n\n      otherPerson = Person\n        __state:\n          firstName: \"Mr.\"\n          lastName: \"Man\"\n\n      model.person(otherPerson)\n\n      duder.firstName(\"Joe\")\n\n      assert.equal duder.__state.firstName, \"Joe\"\n      assert.equal model.__state.person.firstName, \"Mr.\"\n\n  describe \"#attrModels\", ->\n    it \"should have an array of model instances\", ->\n      model = Core\n        __state:\n          people: [{\n            firstName: \"Duder\"\n            lastName: \"Mannington\"\n            suffix: \"Jr.\"\n          }, {\n            firstName: \"Mr.\"\n            lastName: \"Mannington\"\n            suffix: \"Sr.\"\n          }]\n\n      model.attrModels(\"people\", Person)\n\n      assert.equal model.people()[0].fullName(), \"Duder Mannington Jr.\"\n\n    it \"should track pushes\", ->\n      model = Core\n        __state:\n          people: [{\n            firstName: \"Duder\"\n            lastName: \"Mannington\"\n            suffix: \"Jr.\"\n          }, {\n            firstName: \"Mr.\"\n            lastName: \"Mannington\"\n            suffix: \"Sr.\"\n          }]\n\n      model.attrModels(\"people\", Person)\n\n      model.people.push Person\n        firstName: \"JoJo\"\n        lastName: \"Loco\"\n\n      assert.equal model.people().length, 3\n      assert.equal model.__state.people.length, 3\n\n    it \"should track pops\", ->\n      model = Core\n        __state:\n          people: [{\n            firstName: \"Duder\"\n            lastName: \"Mannington\"\n            suffix: \"Jr.\"\n          }, {\n            firstName: \"Mr.\"\n            lastName: \"Mannington\"\n            suffix: \"Sr.\"\n          }]\n\n      model.attrModels(\"people\", Person)\n\n      model.people.pop()\n\n      assert.equal model.people().length, 1\n      assert.equal model.__state.people.length, 1\n\n  describe \"#delegate\", ->\n    it \"should delegate to another method\", ->\n      model = Core\n        __state:\n          position:\n            x: 1\n            y: 2\n            z: 3\n        position: ->\n          model.__state.position\n\n      model.delegate \"x\", \"y\", \"z\", to: \"position\"\n\n      assert.equal model.x, 1\n      assert.equal model.y, 2\n      assert.equal model.z, 3\n\n      model.x = 5\n\n      assert.equal model.position().x, 5\n      assert.equal model.__state.position.x, 5\n\n    it \"should delegate to another property\", ->\n      model = Core\n        __state:\n          position:\n            x: 1\n            y: 2\n            z: 3\n\n      model.position = model.__state.position\n\n      model.delegate \"x\", \"y\", \"z\", to: \"position\"\n\n      assert.equal model.x, 1\n      assert.equal model.y, 2\n      assert.equal model.z, 3\n\n      model.x = 5\n\n      assert.equal model.position.x, 5\n      assert.equal model.__state.position.x, 5\n\n    it \"should delegate to methods just fine\", ->\n      model = Core\n        __state:\n          size:\n            width: 10\n            height: 20\n\n      model.attrData \"size\", ({width, height}) ->\n        width: -> width\n        height: -> height\n\n      model.delegate \"width\", \"height\", to: \"size\"\n\n      assert.equal model.width(), 10\n      assert.equal model.height(), 20\n\n  describe \"#toJSON\", ->\n    it \"should return an object appropriate for JSON serialization\", ->\n      model = Core\n        __state:\n          test: true\n\n      assert model.toJSON().test\n\n  describe \"#observeAll\", ->\n    it \"should observe all attributes of a simple model\"\n    ->  # TODO\n      model = Core\n        test: true\n        yolo: \"4life\"\n\n      model.observeAll()\n\n      assert model.test()\n      assert.equal model.yolo(), \"4life\"\n\n    it \"should camel case underscored names\"\n\n  describe \".defaults\", ->\n    it \"should expose defaults method\", ->\n      assert Core.defaults\n\n  describe \".extend\", ->\n    it \"should expose extend method\", ->\n      assert Core.extend\n"},"lib/core.coffee":{"content":"###\nModel\n=====\n\nThe `Model` module provides helper methods to compose nested data models.\n\n###\n\nObservable = require \"./observable\"\n\nmodule.exports = Model = (I={}, self={}) ->\n  Object.assign self,\n\n    ###\n    `I` holds the instance state. It is generally considered private, but access\n    is available for debugging and other purposes.\n    ###\n    I: I\n\n    ###\n    Extends this object with methods from the passed in object. A shortcut for Object.extend(self, methods)\n    \n    >     I =\n    >       x: 30\n    >       y: 40\n    >       maxSpeed: 5\n    >\n    >     # we are using extend to give player\n    >     # additional methods that Model doesn't have\n    >     player = Model(I).extend\n    >       increaseSpeed: ->\n    >         I.maxSpeed += 1\n    >\n    >     player.increaseSpeed()\n    \n    ###\n    extend: (objects...) ->\n      Object.assign self, objects...\n\n    ###\n    Includes a module in this object. A module is a constructor that takes two parameters, `I` and `self`\n    \n    >     myObject = Model()\n    >     myObject.include(Bindable)\n    \n    >     # now you can bind handlers to functions\n    >     myObject.bind \"someEvent\", ->\n    >       alert(\"wow. that was easy.\")\n    ###\n    include: (modules...) ->\n      for Module in modules\n        if Module.length is 1\n          Module(self)\n        else\n          Module(I, self)\n\n      return self\n\n    ###\n    Bind a data model getter/setter to an attribute. The data model is bound directly to\n    the attribute and must be directly convertible to and from JSON.\n    ###\n    attrData: (name, DataModel) ->\n      I[name] = DataModel(I[name])\n\n      Object.defineProperty self, name,\n        get: ->\n          I[name]\n        set: (value) ->\n          I[name] = DataModel(value)\n\n    ###\n    Observe any number of attributes as observables. For each attribute name passed in we expose a public getter/setter method and listen to changes when the value is set.\n    ###\n    attrObservable: (names...) ->\n      names.forEach (name) ->\n        self[name] = Observable(I[name])\n\n        self[name].observe (newValue) ->\n          I[name] = newValue\n\n      return self\n\n    ###\n    Observe an attribute as a model. Treats the attribute given as an Observable\n    model instance exposing a getter/setter method of the same name. The Model\n    constructor must be passed explicitly.\n    ###\n    attrModel: (name, Model) ->\n      model = Model(I[name])\n\n      self[name] = Observable(model)\n\n      self[name].observe (newValue) ->\n        I[name] = newValue.I\n\n      return self\n\n    ###\n    Observe an attribute as an array of sub-models. This is the same as `attrModel`\n    except the attribute is expected to be an array of models rather than a single one.\n    ###\n    attrModels: (name, Model) ->\n      models = (I[name] or []).map (x) ->\n        Model(x)\n\n      self[name] = Observable(models)\n\n      self[name].observe (newValue) ->\n        I[name] = newValue.map (instance) ->\n          instance.I\n\n      return self\n\n    ###\n    Delegate methods to another target. Makes it easier to compose rather than extend.\n    ###\n    delegate: (names..., {to}) ->\n      names.forEach (name) ->\n        Object.defineProperty self, name,\n          get: ->\n            receiver = getValue self, to\n            receiver[name]\n          set: (value) ->\n            receiver = getValue self, to\n            setValue receiver, name, value\n\n    ###\n    The JSON representation is kept up to date via the observable properites and resides in `I`.\n    ###\n    toJSON: ->\n      I\n\n  return self\n\nisFn = (x) ->\n  typeof x is 'function'\n\ngetValue = (receiver, property) ->\n  if isFn receiver[property]\n    receiver[property]()\n  else\n    receiver[property]\n\nsetValue = (receiver, property, value) ->\n  target = receiver[property]\n\n  if isFn target\n    target.call(receiver, value)\n  else\n    receiver[property] = value\n\ndefaults = (target, objects...) ->\n  for object in objects\n    for name of object\n      unless target.hasOwnProperty(name)\n        target[name] = object[name]\n\n  return target\n\nextend = Object.assign\n\nObject.assign Model, {Observable, defaults, extend}\n"},"data/views/ace-editor.coffee":{"content":""},"lib/fs/util.coffee":{"content":"###\nUtility methods for manipulating and normalizing file system paths.\n###\n\nseparator = \"/\"\n\nnormalizePath = (path) ->\n  path.replace(/\\/+/g, separator) # /// -> /\n  .replace(/\\/[^/]*\\/\\.\\.(\\/|$)/g, separator) # /base/something/.. -> /base/\n  .replace(/\\/(\\.(\\/|$))*/g, separator) # /base/. -> /base/\n\nnormalizePath2 = (path) ->\n  stack = []\n  path.split(separator).forEach (part) ->\n    switch part\n      when \".\", \"\"\n        ;# Skip\n      when \"..\"\n        if stack.length\n          stack.pop()\n        else\n          throw new Error \"No upper directory when normalizing '#{path}'\"\n      else\n        stack.push part\n\n  # Add leading and trailing slashes as necessary\n  if path.startsWith '/'\n    stack.unshift ''\n  else if path.startsWith './' # Keep local paths\n    stack.unshift '.'\n  if path.match /\\/\\.{0,2}$/\n    stack.push ''\n\n  return stack.join(separator)\n\n# By default throws an error when paths '../..' try go above the base path\n# can be overridden by passing false as the third parameter.\nabsolutizePath = (base, relativePath, preventEscape=true) ->\n  unless base.startsWith separator\n    throw new Error \"base path must be absolute\"\n  unless base.endsWith separator\n    throw new Error \"base path must be a directory\"\n\n  path = normalizePath \"#{base}#{relativePath}\"\n\n  if preventEscape\n    unless path.startsWith normalizePath base\n      throw new Error \"path escaped base directory (too many ../)\"\n\n  return path\n\nallDirectories = /^.*\\//\n\nbaseName = (path) ->\n  path.replace(allDirectories, \"\")\n\nextensionFor = (path) ->\n    result = baseName(path).match /\\.([^.]+)$/\n\n    if result\n      result[1]\n    else\n      \"\"\n\n# Only media types for editible text types that have a special meaning to the\n# browser. html, css, js, json all require the proper content type header to\n# work properly so we make sure to have the correct data. Also setting the\n# charset to utf-8 which is the only one that we currently support.\nmimes =\n  css: \"text/css\"\n  html: \"text/html\"\n  js: \"text/javascript\"\n  json: \"application/json\"\n  md: \"text/markdown\"\n\ntextMediaType = (path) ->\n  extension = extensionFor(path)\n  type = mimes[extension] or \"text/plain\"\n\n  \"#{type}; charset=utf-8\"\n\nmodule.exports =\n  absolutizePath: absolutizePath\n  baseDirectory: (absolutePath=\"/\") ->\n    absolutePath.match(allDirectories)?[0]\n  baseName: baseName\n  extensionFor: extensionFor\n  fileSeparator: separator\n  isRelativePath:  (path) ->\n    !!path.match /^.?.\\//\n  normalizePath: normalizePath\n  normalizePath2: normalizePath2\n\n  Ergonomics: (fs) ->\n    # Wrap read with more ergonomic text file writing\n    do (write=fs.write) ->\n      fs.write = (path, stringOrBlob, args...) ->\n        if typeof stringOrBlob is \"string\"\n          blob = new Blob [stringOrBlob],\n            type: textMediaType path\n        else\n          blob = stringOrBlob\n\n        write.call(fs, path, blob, args...)\n\n    return fs\n\n  separator: separator\n  textMediaType: textMediaType\n\n  withoutExtension: (path) ->\n    path.replace(/\\.[^\\.\\/]*$/,\"\")\n\n  withoutAllExtensions: (path) ->\n    path.replace(/\\.[^\\/]*$/,\"\")\n"},"lib/test/fs/util.coffee":{"content":"{\n  absolutizePath\n  baseDirectory\n  extensionFor\n  isRelativePath\n  textMediaType\n  normalizePath\n  # normalizePath2:normalizePath\n  withoutExtension\n  withoutAllExtensions\n} = require \"/lib/fs/index\"\n\ndescribe \"fs\", ->\n  describe \"util\", ->\n    it \"should absolutize paths\", ->\n      assert.equal absolutizePath(\"/Home/\", \"app.config\"), \"/Home/app.config\"\n\n      assert.equal absolutizePath(\"/Home/\", \"something/../app.config\"), \"/Home/app.config\"\n      assert.equal absolutizePath(\"/Home/\", \"/something/../app.config\"), \"/Home/app.config\"\n\n      assert.equal absolutizePath(\"/Home//\", \"///./app.config\"), \"/Home/app.config\"\n      assert.equal absolutizePath(\"/Home/./\", \"///./app.config\"), \"/Home/app.config\"\n\n    it \"should error when escaping base dir\", ->\n      assert.throws ->\n        absolutizePath(\"/Home/\", \"../app.config\")\n\n    it \"should normalize paths\", ->\n      assert.equal normalizePath(\"///./app.config\"), \"/app.config\"\n      assert.equal normalizePath(\"/yolo/.././/./app.config\"), \"/app.config\"\n      assert.equal normalizePath(\"yolo/rad/..//./app.config\"), \"yolo/app.config\"\n\n      assert.equal normalizePath(\"/public/danielx.net/..\"), \"/public/\"\n      assert.equal normalizePath(\"/public/danielx.net/.\"), \"/public/danielx.net/\"\n\n      assert.equal normalizePath(\"/public/..weird/danielx.net/\"), \"/public/..weird/danielx.net/\"\n\n    it \"should normalize strage cases\", ->\n      assert.equal normalizePath(\"./\"), \"./\"\n      assert.equal normalizePath(\"./cool\"), \"./cool\"\n\n    it.skip \"should throw an error when there is no parent directory\", ->\n      assert.throws ->\n        normalizePath \"/../danielx.net/\"\n      assert.throws ->\n        normalizePath \"./..\"\n      assert.throws ->\n        normalizePath \"/./..\"\n\n    it \"should know relative paths\", ->\n      assert.equal isRelativePath(\"../yo.txt\"), true\n      assert.equal isRelativePath(\"./yo.md\"), true\n\n      assert.equal isRelativePath(\"/Home/yo\"), false\n\n    describe \"baseDirectory\", ->\n      it \"should resolve base directories\", ->\n        # A directory is its own base directory\n        assert.equal baseDirectory(\"/Home/\"), \"/Home/\"\n        # The directory that contains a file is that file's base directory\n        assert.equal baseDirectory(\"/Home/cool.gif\"), \"/Home/\"\n        # A non-root path can be a base directory\n        assert.equal baseDirectory(\"folder/sub/cool.gif\"), \"folder/sub/\"\n  \n      it \"should have base directory undefined if no folder\", ->\n        assert.equal baseDirectory(\"just-a-file.js\"), undefined\n\n    describe \"extensionFor\", ->\n      it \"should give extensios\", ->\n        assert.equal extensionFor(\"home/rad.js\"), \"js\"\n        assert.equal extensionFor(\"home/rad.js.md\"), \"md\"\n\n      it \"should handle directories with a dot\", ->\n        assert.equal extensionFor(\"home.app/md\"), \"\"\n        assert.equal extensionFor(\"home.app/cool.md\"), \"md\"\n\n    describe \"textMediaType\", ->\n      it \"should return the proper mime types\", ->\n        assert.equal textMediaType(\"cool.html\"), \"text/html; charset=utf-8\"\n        assert.equal textMediaType(\"sick.js\"), \"text/javascript; charset=utf-8\"\n        assert.equal textMediaType(\"noice.json\"), \"application/json; charset=utf-8\"\n        assert.equal textMediaType(\"rad.txt\"), \"text/plain; charset=utf-8\"\n        assert.equal textMediaType(\"lit.md\"), \"text/markdown; charset=utf-8\"\n        assert.equal textMediaType(\"yo.coffee\"), \"text/plain; charset=utf-8\"\n        assert.equal textMediaType(\"style.styl\"), \"text/plain; charset=utf-8\"\n        # Any unrecognized type is text/plain\n        assert.equal textMediaType(\"heyy.webm\"), \"text/plain; charset=utf-8\"\n\n    describe \"withoutExtension\", ->\n      it \"should remove extensions\", ->\n        assert.equal withoutExtension(\"cool/file.ab.c\"), \"cool/file.ab\"\n        assert.equal withoutExtension(\"but.why/file.ab.c\"), \"but.why/file.ab\"\n        assert.equal withoutExtension(\"but.why/file\"), \"but.why/file\"\n    \n    describe \"withoutAllExtensions\", ->\n      it \"should remove extensions\", ->\n        assert.equal withoutAllExtensions(\"cool/file.ab.c\"), \"cool/file\"\n        assert.equal withoutAllExtensions(\"but.why/file.ab.c\"), \"but.why/file\"\n        assert.equal withoutExtension(\"but.why/file\"), \"but.why/file\"\n"},"lib/pkg/require.coffee.md":{"content":"Require\r\n=======\r\n\r\nA Node.js compatible require implementation for pure client side apps.\r\n\r\nEach file is a module. Modules are responsible for exporting an object. Unlike\r\ntraditional client side JavaScript, Ruby, or other common languages the module\r\nis not responsible for naming its product in the context of the requirer. This\r\nmaintains encapsulation because it is impossible from within a module to know\r\nwhat external name would be correct to prevent errors of composition in all\r\npossible uses.\r\n\r\nUses\r\n----\r\n\r\nFrom a module require another module in the same package.\r\n\r\n>     require \"./soup\"\r\n\r\nRequire a module in the parent directory\r\n\r\n>     require \"../nuts\"\r\n\r\nRequire a module from the root directory in the same package.\r\n\r\nNOTE: This could behave slightly differently under Node.js if your package does\r\nnot have it's own isolated filesystem.\r\n\r\n>     require \"/silence\"\r\n\r\nFrom a module within a package, require a dependent package.\r\n\r\n>     require \"console\"\r\n\r\nThe dependency could be delcared in pixie.cson as follows:\r\n\r\n>     dependencies:\r\n>       console: \"http://strd6.github.io/console/v1.2.2.json\"\r\n\r\nYou can require a package directly from its JSON representation as well.\r\n\r\n>     $.getJSON(packageURL)\r\n>     .then (pkg) ->\r\n>       require pkg\r\n\r\nImplementation\r\n--------------\r\n\r\nFile separator is '/'\r\n\r\n    fileSeparator = '/'\r\n\r\nIn the browser `global` is `self`.\r\n\r\n    global = self\r\n\r\nDefault entry point\r\n\r\n    defaultEntryPoint = \"main\"\r\n\r\nA sentinel against circular requires.\r\n\r\n    circularGuard = {}\r\n\r\nA top-level module so that all other modules won't have to be orphans.\r\n\r\n    rootModule =\r\n      path: \"\"\r\n\r\nRequire a module given a path within a package. Each file is its own separate\r\nmodule. An application is composed of packages.\r\n\r\n    loadPath = (parentModule, pkg, path) ->\r\n      if startsWith(path, '/')\r\n        localPath = []\r\n      else\r\n        localPath = parentModule.path.split(fileSeparator)\r\n\r\n      normalizedPath = normalizePath(path, localPath)\r\n\r\n      cache = cacheFor(pkg)\r\n\r\n      if module = cache[normalizedPath]\r\n        if module is circularGuard\r\n          throw \"Circular dependency detected when requiring #{normalizedPath}\"\r\n      else\r\n        cache[normalizedPath] = circularGuard\r\n\r\n        try\r\n          cache[normalizedPath] = module = loadModule(pkg, normalizedPath)\r\n        finally\r\n          delete cache[normalizedPath] if cache[normalizedPath] is circularGuard\r\n\r\n      return module.exports\r\n\r\nTo normalize the path we convert local paths to a standard form that does not\r\ncontain any references to current or parent directories.\r\n\r\n    normalizePath = (path, base=[]) ->\r\n      base = base.concat path.split(fileSeparator)\r\n      result = []\r\n\r\nChew up all the pieces into a standardized path.\r\n\r\n      while base.length\r\n        switch piece = base.shift()\r\n          when \"..\"\r\n            result.pop()\r\n          when \"\", \".\"\r\n            # Skip\r\n          else\r\n            result.push(piece)\r\n\r\n      return result.join(fileSeparator)\r\n\r\n`loadPackage` Loads a dependent package at that packages entry point.\r\n\r\n    loadPackage = (pkg) ->\r\n      path = pkg.entryPoint or defaultEntryPoint\r\n\r\n      loadPath(rootModule, pkg, path)\r\n\r\nLoad a file from within a package.\r\n\r\n    loadModule = (pkg, path) ->\r\n      unless (file = pkg.distribution[path])\r\n        throw \"Could not find file at #{path} in #{pkg.name}\"\r\n\r\n      unless (content = file.content)?\r\n        throw \"Malformed package. No content for file at #{path} in #{pkg.name}\"\r\n\r\n      # program = annotateSourceURL content, pkg, path\r\n      program = content\r\n      dirname = path.split(fileSeparator)[0...-1].join(fileSeparator)\r\n\r\n      module =\r\n        path: dirname\r\n        exports: {}\r\n\r\nThis external context provides some variable that modules have access to.\r\n\r\nA `require` function is exposed to modules so they may require other modules.\r\n\r\nAdditional properties such as a reference to the global object and some metadata\r\nare also exposed.\r\n\r\n      context =\r\n        require: generateRequireFn(pkg, module)\r\n        global: global\r\n        module: module\r\n        exports: module.exports\r\n        PACKAGE: pkg\r\n        __filename: path\r\n        __dirname: dirname\r\n\r\n      args = Object.keys(context)\r\n      values = args.map (name) -> context[name]\r\n\r\nExecute the program within the module and given context.\r\n\r\n      Function(args..., program).apply(module, values)\r\n\r\n      return module\r\n\r\nHelper to detect if a given path is a package.\r\n\r\n    isPackage = (path) ->\r\n      if !(startsWith(path, fileSeparator) or\r\n        startsWith(path, \".#{fileSeparator}\") or\r\n        startsWith(path, \"..#{fileSeparator}\")\r\n      )\r\n        path.split(fileSeparator)[0]\r\n      else\r\n        false\r\n\r\nGenerate a require function for a given module in a package.\r\n\r\nIf we are loading a package in another module then we strip out the module part\r\nof the name and use the `rootModule` rather than the local module we came from.\r\nThat way our local path won't affect the lookup path in another package.\r\n\r\nLoading a module within our package, uses the requiring module as a parent for\r\nlocal path resolution.\r\n\r\n    generateRequireFn = (pkg, module=rootModule) ->\r\n      pkg.name ?= \"ROOT\"\r\n      pkg.scopedName ?= \"ROOT\"\r\n\r\n      fn = (path) ->\r\n        if typeof path is \"object\"\r\n          loadPackage(path)\r\n        else if isPackage(path)\r\n          unless otherPackage = pkg.dependencies[path]\r\n            throw \"Package: #{path} not found.\"\r\n\r\n          otherPackage.name ?= path\r\n          otherPackage.scopedName ?= \"#{pkg.scopedName}/#{path}\"\r\n\r\n          loadPackage(otherPackage)\r\n        else\r\n          loadPath(module, pkg, path)\r\n\r\n      fn.packageWrapper = publicAPI.packageWrapper\r\n      fn.executePackageWrapper = publicAPI.executePackageWrapper\r\n\r\n      return fn\r\n\r\nBecause we can't actually `require('require')` we need to export it a little\r\ndifferently.\r\n\r\n    publicAPI =\r\n      generateFor: generateRequireFn\r\n\r\nWrap a package as a string that will bootstrap `require` and execute the package.\r\nThis can be used for generating standalone HTML pages, scripts, and tests.\r\n\r\n      packageWrapper: (pkg, code) ->\r\n        \"\"\"\r\n          ;(function(PACKAGE) {\r\n            var require = (function() {\r\n              var src = #{JSON.stringify(PACKAGE.distribution[\"lib/pkg/require\"].content)};\r\n              var module = {};\r\n              Function(\"PACKAGE\", \"module\", \"exports\", src)({\r\n                distribution: {\"lib/pkg/require\": {content: src}}\r\n              }, module, true);\r\n\r\n              return module.exports;\r\n            }()).generateFor(PACKAGE);\r\n            #{code};\r\n          })(#{JSON.stringify(pkg, null, 2)});\r\n        \"\"\"\r\n\r\nWrap a package as a string that will execute its entry point.\r\n\r\n      executePackageWrapper: (pkg) ->\r\n        publicAPI.packageWrapper pkg, \"require('./#{pkg.entryPoint}')\"\r\n\r\nRequire a package directly.\r\n\r\n      loadPackage: loadPackage\r\n\r\n    if exports?\r\n      module.exports = publicAPI\r\n    else\r\n      global.Require = publicAPI\r\n\r\nNotes\r\n-----\r\n\r\nWe have to use `pkg` as a variable name because `package` is a reserved word.\r\n\r\nNode needs to check file extensions, but because we only load compiled products\r\nwe never have extensions in our path.\r\n\r\nSo while Node may need to check for either `path/somefile.js` or `path/somefile.coffee`\r\nthat will already have been resolved for us and we will only check `path/somefile`\r\n\r\nCircular dependencies are not allowed and raise an exception when detected.\r\n\r\nHelpers\r\n-------\r\n\r\nDetect if a string starts with a given prefix.\r\n\r\n    startsWith = (string, prefix) ->\r\n      string.lastIndexOf(prefix, 0) is 0\r\n\r\nCreates a cache for modules within a package. It uses `defineProperty` so that\r\nthe cache doesn't end up being enumerated or serialized to json.\r\n\r\n    cacheFor = (pkg) ->\r\n      return pkg.cache if pkg.cache\r\n\r\n      Object.defineProperty pkg, \"cache\",\r\n        value: {}\r\n\r\n      return pkg.cache\r\n\r\nAnnotate a program with a source url so we can debug in Chrome's dev tools.\r\n\r\n    annotateSourceURL = (program, pkg, path) ->\r\n      \"\"\"\r\n        #{program}\r\n        //# sourceURL=#{pkg.scopedName}/#{path}\r\n      \"\"\"\r\n\r\nDefinitions\r\n-----------\r\n\r\n### Module\r\n\r\nA module is a file.\r\n\r\n### Package\r\n\r\nA package is an aggregation of modules. A package is a json object with the\r\nfollowing properties:\r\n\r\n- `distribution` An object whose keys are paths and properties are `fileData`\r\n- `entryPoint` Path to the primary module that requiring this package will require.\r\n- `dependencies` An object whose keys are names and whose values are packages.\r\n\r\nIt may have additional properties such as `source`, `repository`, and `docs`.\r\n\r\n### Application\r\n\r\nAn application is a package which has an `entryPoint` and may have dependencies.\r\nAdditionally an application's dependencies may have dependencies. Dependencies\r\nmust be bundled with the package.\r\n"},"lib/test/pkg/require.coffee":{"content":"\r\n# Load our latest require code for testing\r\n# NOTE: This causes the root for relative requires to be at the root dir, not the test dir\r\nrequireSrc = \"/lib/pkg/require2\"\r\nlatestRequire = require(requireSrc).generateFor(PACKAGE)\r\nsampleDir = \"/data/pkg/samples/\"\r\n\r\ndescribe \"require\", ->\r\n  it \"should not exist globally\", ->\r\n    assert !global.require\r\n\r\n  it \"should be able to require a file that exists with a relative path\", ->\r\n    assert latestRequire(\"#{sampleDir}terminal\")\r\n\r\n  it \"should get whatever the file exports\", ->\r\n    assert latestRequire(\"#{sampleDir}terminal\").something\r\n\r\n  it \"should not get something the file doesn't export\", ->\r\n    assert !latestRequire(\"#{sampleDir}terminal\").something2\r\n\r\n  it \"should throw a descriptive error when requring circular dependencies\", ->\r\n    assert.throws ->\r\n      latestRequire(\"#{sampleDir}circular\")\r\n    , /circular/i\r\n\r\n  it \"should throw a descriptive error when requiring a package that doesn't exist\", ->\r\n    assert.throws ->\r\n      latestRequire \"does_not_exist\"\r\n    , /not found/i\r\n\r\n  it \"should throw a descriptive error when requiring a relative path that doesn't exist\", ->\r\n    assert.throws ->\r\n      latestRequire \"/does_not_exist\"\r\n    , /Could not find file/i\r\n\r\n  it \"should recover gracefully enough from requiring files that throw errors\", ->\r\n    assert.throws ->\r\n      latestRequire \"#{sampleDir}throws\"\r\n\r\n    assert.throws ->\r\n      latestRequire \"#{sampleDir}throws\"\r\n    , (err) ->\r\n      !/circular/i.test err\r\n\r\n  it \"should cache modules\", ->\r\n    result = latestRequire(\"#{sampleDir}random\")\r\n\r\n    assert.equal latestRequire(\"#{sampleDir}random\"), result\r\n\r\n  it \"should be able to require a JSON package object\", ->\r\n    SAMPLE_PACKAGE =\r\n      entryPoint: \"main\"\r\n      distribution:\r\n        main:\r\n          content: \"module.exports = require('./other')\"\r\n        other:\r\n          content: \"module.exports = 'TEST'\"\r\n\r\n    result = latestRequire SAMPLE_PACKAGE\r\n\r\n    assert.equal \"TEST\", result\r\n\r\n  it \"should be able to require something packaged with browserify\", ->\r\n    assert.equal latestRequire(\"#{sampleDir}browserified\"), \"coolio\"\r\n\r\ndescribe \"package wrapper\", ->\r\n  it \"should be able to generate a package wrapper recursively\", ->\r\n    pkgString = latestRequire.packageWrapper(PACKAGE, \"window.r = require\")\r\n\r\n    Function(pkgString)()\r\n    Function(r.packageWrapper(PACKAGE, \"window.r2 = require\"))()\r\n    Function(r2.packageWrapper(PACKAGE, \"window.r3 = require\"))()\r\n\r\n    assert r2\r\n    assert r3\r\n\r\n    delete r\r\n    delete r2\r\n    delete r3\r\n\r\n  it \"should be able to execute code in the package context\", ->\r\n    code = latestRequire.packageWrapper(PACKAGE, \"window.test = require.packageWrapper(PACKAGE, 'alert(\\\"heyy\\\")');\")\r\n    Function(code)()\r\n    assert window.test\r\n    delete window.test\r\n\r\ndescribe \"public API\", ->\r\n  mocha.setup\r\n    globals: ['system', 'OBSERVABLE_ROOT_HACK']\r\n\r\n  it \"should be able to require a JSON package directly\", ->\r\n    assert require(requireSrc).loadPackage\r\n      distribution:\r\n        main:\r\n          content: \"global.test2 = true\"\r\n\r\n    assert window.test2\r\n    delete window.test2\r\n\r\ndescribe \"module context\", ->\r\n  it \"should know __dirname\", ->\r\n    assert.equal \"lib/test/pkg\", __dirname\r\n\r\n  it \"should know __filename\", ->\r\n    assert __filename\r\n\r\n  it \"should know its package\", ->\r\n    assert PACKAGE\r\n\r\ndescribe \"malformed package\", ->\r\n  malformedPackage =\r\n    distribution:\r\n      yolo: \"No content!\"\r\n\r\n  it \"should throw an error when attempting to require a malformed file in a package distribution\", ->\r\n    r = require(requireSrc).generateFor(malformedPackage)\r\n\r\n    assert.throws ->\r\n      r.require \"yolo\"\r\n    , (err) ->\r\n      !/malformed/i.test err\r\n\r\ndescribe \"dependent packages\", ->\r\n  it \"should allow for arbitrary characters\", ->\r\n    r = require(requireSrc).generateFor\r\n      dependencies:\r\n        \"#$!jadelet\":\r\n          entryPoint: \"main\"\r\n          distribution:\r\n            main: \r\n              content: \"module.exports = 'ok';\"\r\n\r\n    assert.equal r(\"#$!jadelet\"), \"ok\"\r\n  \r\n  PACKAGE.dependencies[\"test-package\"] =\r\n    distribution:\r\n      main:\r\n        content: \"module.exports = PACKAGE.name\"\r\n\r\n  PACKAGE.dependencies[\"strange/name\"] =\r\n    distribution:\r\n      main:\r\n        content: \"\"\r\n\r\n  it \"should raise an error when requiring a package that doesn't exist\", ->\r\n    assert.throws ->\r\n      latestRequire \"nonexistent\"\r\n    , (err) ->\r\n      /nonexistent/i.test err\r\n\r\n  it \"should be able to require a package that exists\", ->\r\n    assert latestRequire(\"test-package\")\r\n\r\n  it \"Dependent packages should know their names when required\", ->\r\n    assert.equal latestRequire(\"test-package\"), \"test-package\"\r\n\r\n  it \"should be able to require by pretty much any name\", ->\r\n    assert latestRequire(\"strange/name\")\r\n"},"data/pkg/samples/circular.coffee":{"content":"# This test file illustrates a circular requirement and should throw an error.\r\n\r\nrequire \"./circular\"\r\n"},"data/pkg/samples/browserified.js":{"content":"!function(e){if(\"object\"==typeof exports)module.exports=e();else if(\"function\"==typeof define&&define.amd)define(e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.Test=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\r\nmodule.exports = 'coolio';\r\n\r\n},{}]},{},[1])\r\n(1)\r\n});\r\n"},"data/pkg/samples/throws.coffee":{"content":"# A test file that throws an error.\r\n\r\nthrow \"yolo\"\r\n"},"data/pkg/samples/terminal.coffee":{"content":"# A test file for requiring a file that has no dependencies. It should succeed.\r\n\r\nexports.something = true\r\n"},"data/pkg/samples/random.coffee":{"content":"# Returns a random value, used for testing caching\r\n\r\nmodule.exports = Math.random()\r\n"},"lib/aws/_lazy.coffee":{"content":"{lazyLoader} = require \"../util/index\"\n\nmodule.exports = lazyLoader [\n  # TODO: Figure out a good cdn for these because they are chewing through bandwidth\n  # jsdelivr looks promising but these don't seem to work...\n  #   \"https://cdn.jsdelivr.net/npm/amazon-cognito-auth-js@1.3.3/dist/aws-cognito-sdk.min.js\"\n  #   \"https://cdn.jsdelivr.net/npm/amazon-cognito-identity-js@5.1.0/dist/amazon-cognito-identity.min.js\"\n\n  \"https://danielx.whimsy.space/cdn/cognito/sdk.min.js\"\n  \"https://danielx.whimsy.space/cdn/cognito/identity.min.js\"\n  \"https://sdk.amazonaws.com/js/aws-sdk-2.7.20.min.js\"\n]\n"},"lib/test/aws/_lazy.coffee":{"content":""},"views/login.coffee":{"content":"# Note: This is adapted from whimsy.space My Briefcase to provide a generic\n# login for all whimsy.space and danielx.net apps\n\nAccount = require \"/lib/acct/account\"\n\nCognito = require \"/lib/aws/cognito\"\ncognito = Cognito(PACKAGE.config.cognito)\n\n{exec: compileTemplate} = require \"/lib/jadelet\"\n\nObservable = require \"/lib/observable\"\n\nModal = require \"/modal\"\n\nmodule.exports = (options={}) ->\n  {description, headless, resolve, reject, title} = options\n\n  title ?= \"ðŸ”‘ Log in to Whimsy.Space [DanielX.net]\"\n  description ?= \"\"\"\n    Maintain access to your files across different machines. Publish\n    effortlessly to the internet. Participate in the DanielX.net community.\n  \"\"\"\n\n  model =\n    loading: Observable true\n    state: Observable \"start\"\n    content: Observable()\n    submit: (e) ->\n      e.preventDefault()\n      @errorMessage \"\"\n\n      if @state() is \"register\"\n        @loading true\n\n        if @password() is @confirmPassword()\n          cognito.signUp(@email(), @password())\n          .then =>\n            @loading false\n            @clearForm()\n            @errorMessage \"\"\n            @state \"confirm\"\n          .catch (e) =>\n            @loading false\n            @errorMessage \"Error: \" + e.message\n        else\n          @errorMessage \"Error: Password does not match password confirmation\"\n          @loading false\n      else\n        @loading true\n\n        cognito.authenticate(@email(), @password())\n        .then receivedCredentials\n        .catch (e) =>\n          console.error(e)\n          @errorMessage \"Error: \" + e.message\n        .finally =>\n          @loading false\n\n    title: title \n    description: description\n    email: Observable \"\"\n    password: Observable \"\"\n    confirmPassword: Observable \"\"\n    clearForm: ->\n      @email \"\"\n      @password \"\"\n      @confirmPassword \"\"\n    errorMessage: Observable \"\"\n    goBack: (e) ->\n      e.preventDefault()\n      @errorMessage \"\"\n      @state \"start\"\n    goToRegister: (e) ->\n      e.preventDefault()\n      @state \"register\"\n    goToLogin: (e) ->\n      e.preventDefault()\n      @state \"login\"\n    logout: (e) ->\n      e.preventDefault()\n\n      @id null\n      @state \"start\"\n      cognito.logout()\n\n  stateTemplates =\n    register: compileTemplate \"\"\"\n      section\n        p.error @errorMessage\n        label\n          h2 Email\n          input(name=\"email\" value=@email)\n        label\n          h2 Password\n          input(type=\"password\" name=\"password\" value=@password)\n        label\n          h2 Confirm Password\n          input(type=\"password\" name=\"confirm\" value=@confirmPassword)\n\n        button.full Register\n        button.top-left(click=@goBack) Back\n    \"\"\"\n\n    loading: compileTemplate \"\"\"\n      progress\n    \"\"\"\n\n    start: compileTemplate \"\"\"\n      section\n        p.error @errorMessage\n        p @description\n        button.full(click=@goToLogin) Login\n        button.full(click=@goToRegister) Register\n    \"\"\"\n\n    confirm: compileTemplate \"\"\"\n      section\n        p.error @errorMessage\n        p A confirmation email has been sent to your address, please follow the confirmation link!\n        button.full(click=@goToLogin) Next\n    \"\"\"\n\n    login: compileTemplate \"\"\"\n      section\n        p.error @errorMessage\n        label\n          h2 Email or Username\n          input(name=\"email\" value=@email)\n        label\n          h2 Password\n          input(type=\"password\" name=\"password\" value=@password)\n\n        button.full Sign In\n        a(href=\"https://auth.danielx.net/forgotPassword?client_id=3fd84r6idec9iork4e9l43mp61&response_type=token&scope=aws.cognito.signin.user.admin+email+openid+phone+profile&redirect_uri=https://whimsy.space/\" target=\"_blank\") Forgot Password?\n        button.top-left(click=@goBack) Back\n    \"\"\"\n\n  formTemplate = compileTemplate \"\"\"\n    section.ws-login\n      form(@submit)\n        h1 @title\n        @content\n  \"\"\"\n\n  Observable ->\n    state = model.state()\n    loading = model.loading()\n\n    if loading\n      model.content stateTemplates.loading(model)\n    else\n      model.content stateTemplates[state](model)\n\n  # Callback after the user has authenticate either through cached\n  # credentials or by registering or signing in.\n  receivedCredentials = (AWS) ->\n    model.clearForm()\n\n    resolve Account AWS\n\n    if !headless\n      Modal.hide()\n\n  cognito.cachedUser()\n  .then receivedCredentials\n  .catch (e) ->\n    model.loading false\n    console.debug e\n\n  # Show modal to login if not in headless mode\n  if !headless\n    element = formTemplate model\n\n    Modal.show element, reject\n"},"lib/ui/drop.coffee":{"content":"module.exports = (element, handler) ->\n  cancel = (e) ->\n    e.preventDefault()\n    return false\n\n  element.addEventListener \"dragover\", cancel\n  element.addEventListener \"dragenter\", cancel\n  element.addEventListener \"drop\", (e) ->\n    handler(e)\n"},"lib/ui/index.coffee":{"content":"require \"/setup\"\n\nJadelet = require \"../jadelet\"\nObservable = require \"../observable\"\nStyle = require \"/style\"\n\nContextMenuView = require \"/views/context-menu\"\nModal = require \"/modal\"\nMenuView = require \"/views/menu\"\nMenuBarView = require \"/views/menu-bar\"\nMenuItemView = require \"/views/menu-item\"\nProgressView = require \"/views/progress\"\nTableView = require \"/views/table\"\nWindowView = require \"/views/window\"\n\n# create or replace the style element with the given name\napplyStyle = (styleContent, className) ->\n  if className\n    escapedName = CSS.escape(className)\n    style = document.head.querySelector(\"style.#{escapedName}\") or document.createElement \"style\"\n    style.className = className\n  else\n    style = document.createElement \"style\"\n\n  style.innerHTML = styleContent\n  document.head.appendChild style\n\nmodule.exports = {\n  AceEditor: require \"/views/ace-editor\"\n  applyStyle\n  Bindable: require \"../bindable\"\n  ContextMenu: ContextMenuView\n  Drop: require \"./drop\"\n  FuzzyListView: require \"/views/fuzzy-list\"\n  Jadelet: Jadelet\n  Jadelet2:\n    compile: Jadelet.exec\n  Login: require \"/views/login\"\n  Modal\n  Model: require \"../core\"\n  Menu: MenuView\n  MenuBar: MenuBarView\n  MenuItem: MenuItemView\n  Observable: Observable\n  Progress: ProgressView\n  Style:\n    all: Style\n  Table: TableView\n  # TODO: this should be removed, parseMenu should be a behavior of the\n  # menu objects\n  Util: # Public utilities that we export\n    parseMenu: require \"../indent-parse\"\n  Window: WindowView\n}\n"},"data/views/login.coffee":{"content":""},"lib/test/ui/index.coffee":{"content":""},"lib/app/hotkeys.coffee":{"content":"###\nBind app hotekeys. Assumes global context, not currently safe for multiple\ninstances. Reloading \"works\" by overwriting previous bindings.\n\nStatus: Active Experiment in Paint Composer, consolidating here.\n###\n\n{exec:compileTemplate} = require \"../jadelet\"\n{groupBy} = require \"../util/index\"\n\nMousetrap = require \"../mousetrap\"\n\n# Override default stop callback behavior\nMousetrap::stopCallback = (e, element, combo) ->\n  # Don't stop for ctrl+key etc. even in textareas\n  if combo.match /^(ctrl|alt|meta|option|command)\\+/\n    return false\n\n  # stop for input, select, textarea, and content editable\n  return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || (element.contentEditable && element.contentEditable == 'true')\n\n\nHotkeyTable = compileTemplate \"\"\"\ntable\n  thead\n    tr\n      th(colspan=\"2\") Hotkeys\n  tbody\n    @rows\n\"\"\"\nHotkeyRow = compileTemplate \"\"\"\ntr\n  td @name\n  td.right\n    code @key\n\"\"\"\nHotkeyCategoryRow = compileTemplate \"\"\"\ntr.hotkey-category\n  th(colspan=\"2\") @group\n\"\"\"\n\ncategoryAttr = (m) -> m.category\n\nmodule.exports = (self) ->\n  hotkeys = []\n\n  Object.assign self,\n    hotkey: ->\n      self.addHotkey(arguments...)\n    addHotkey: (key, method, meta) ->\n      if meta\n        if typeof key is 'string'\n          keyString = key\n        else\n          keyString = key.join ','\n\n        hotkeys.push Object.assign {\n          key: keyString\n        }, meta\n\n      # Note: Using the global Mousetrap instance\n      # added hotkeys will replace others with the same key\n      # no cleanup since there is no way to remove event listeners from\n      # bound instances: https://github.com/ccampbell/mousetrap/pull/427\n      Mousetrap.bind key, (e) ->\n        return if e.defaultPrevented\n        e.preventDefault()\n\n        if typeof method is \"function\"\n          method.call(self, e)\n        else\n          self[method](e)\n\n    # Add info without binding hotkey\n    # useful for large batches of similar keys like 0-9 to select a numbered tool\n    addHotkeyInfo: (meta) ->\n      hotkeys.push meta\n\n    hotkeys: ->\n      hotkeys\n\n    hotkeysInfoElement: ->\n      aggregatedHotkeys = groupBy hotkeys, categoryAttr\n\n      rows = Object.keys(aggregatedHotkeys).reduce (result, group) ->\n        entries = aggregatedHotkeys[group]\n\n        result.push HotkeyCategoryRow\n          group: group\n\n        return result.concat entries.map HotkeyRow\n      , []\n\n      return HotkeyTable\n        rows: rows\n"},"lib/pkg/compilers.coffee":{"content":"{lazyLoader} = require \"../util/index\"\n\nidentity = (path, source) -> source\n\nCompileError = (message, location) ->\n  @location = location\n  @message = message\n  delete this.stack\n\nCompileError.prototype = Object.create(new Error)\n\ncompilers =\n  css: identity\n  html: identity\n  js: identity\n  coffee: lazyLoader([\"https://danielx.net/cdn/coffee-script/1.7.1.min.js\"]) (path, source) ->\n    try\n      CoffeeScript.compile source, \n        bare: true\n        filename: path\n    catch e # normalize coffeescript errors\n      {message, location} = e\n      if location\n        throw new CompileError message,\n          row: location.first_line\n          column: location.first_column\n          text: message\n          type: \"error\"\n      else\n        throw e\n  md: lazyLoader([\"https://danielx.net/cdn/marked/0.6.2.min.js\"]) (path, source) ->\n    marked source\n  styl: lazyLoader([\"https://danielx.net/cdn/stylus/0.54.5.min.js\"]) (path, source) ->\n    try\n      stylus.render source,\n        filename: path\n    catch e # normalize errors\n      if e.name is \"ParseError\" # stylus parse errors\n        if match = e.message.match(/^[^:]*:(\\d+):(\\d+)/)\n          [_, row, column] = match\n\n          message = e.message.split(\"\\n\")[8] # only display error line\n\n          throw new CompileError message,\n            # Need to subtract 298 from stylus error locations because it \n            # includes the function imports in the line count\n            row: row - 298,\n            column: column,\n            text: message\n            type: \"error\"\n      else\n        throw e\n\ncompile = (path, source) ->\n  {extensionFor} = require \"../fs/util\"\n\n  extension = extensionFor(path)\n\n  Promise.resolve()\n  .then ->\n    if compiler = compilers[extension]\n      return compiler(path, source)\n    else\n      throw new Error \"Couldn't compile '#{path}'. No compiler for '.#{extension}'\"\n\nmodule.exports =\n  compile: compile\n  CompileError: CompileError\n  registerCompiler: (ext, fn) ->\n    compilers[ext] = fn\n"},"lib/acct/index.coffee":{"content":"Login = require \"/views/login\"\n\nmodule.exports =\n  login: (showUI) ->\n    new Promise (resolve, reject) ->\n      Login {\n        headless: !showUI\n        resolve\n        reject\n      }\n"},"lib/acct/account.coffee":{"content":"# User account model\n# depends on shared global AWS config state, so only one user at a time for now\n\nCognito = require \"/lib/aws/cognito\"\ncognito = Cognito(PACKAGE.config.cognito)\n\nfs = require \"../fs/index\"\n\n{promiseChoke} = require \"../util/index\"\n\nmodule.exports = (AWS) ->\n  # The credentials need to have been populated by cognito.\n  id = AWS.config.credentials.identityId\n\n  bucket = new AWS.S3\n    params:\n      Bucket: \"whimsy-fs\"\n\n  refreshCredentials = promiseChoke ->\n    # This has the side effect of updating the global AWS object's credentials\n    cognito.cachedUser()\n    .then (AWS) ->\n      # Copy the updated credentials to the bucket\n      bucket.config.credentials = AWS.config.credentials\n    .catch console.debug\n\n  id: id\n  fs: fs.S3(id, bucket, refreshCredentials)\n  logout: ->\n    cognito.logout()\n"},"lib/exports.coffee":{"content":"{version} = require \"../pixie\"\n\nPostmaster = require \"./postmaster\"\nRuntime = require \"./runtime\"\n\nmodule.exports = system =\n  # app, client, host are merged in during the `launch` call to Runtime\n  app:\n    Base: -> throw new Error \"app.Base can't be called until after system.launch\"\n  acct: require \"./acct/index\"\n  aws: require \"./aws/index\"\n  fs: require \"./fs/index\"\n\n  ###\n  Launch the system client, attach `system` and `application` globals, send\n  ready message, invoke callback.\n\n  Once we launch system becomes a global and is extended with \n  ###\n  launch: (opts, fn) ->\n    if typeof opts is 'function'\n      fn = opts\n      opts = {}\n\n    if opts.debug\n      opts.logger = console\n\n    # This is still kind of a mess\n    Object.assign global, Runtime(system, opts)\n\n    if window? and Postmaster.dominant() # We're being hosted by another window\n      window.addEventListener 'unload', ->\n        system.host.unload()\n\n    system.host.ready()\n    .then (hostConfig) ->\n      Object.assign system.config,\n        host: hostConfig\n    .finally ->\n      fn(system.config)\n\n  pkg: require \"./pkg/index\"\n  ui: require \"./ui/index\"\n  # Merge deprecated util methods until we're ready to remove them\n  util: require \"./util/index\"\n  version: version\n"},"lib/test/exports.coffee":{"content":"system = require \"../exports\"\n\ndescribe \"exports\", ->\n  it \"should provide fs\", ->\n    # Four filesystem types and counting!\n    assert system.fs\n    assert system.fs.Dexie\n    assert system.fs.Mount\n    assert system.fs.Package\n    assert system.fs.S3\n\n    assert system.aws.Cognito\n\n  it \"should provide acct.login\", ->\n    assert system.acct.login\n\n  it \"should provide util\", ->\n    assert system.util.Postmaster\n\n  it \"should provide ui\", ->\n    {Bindable, Drop, Jadelet, Observable} = system.ui\n\n    assert Bindable\n    assert Drop\n    assert Jadelet\n    assert.equal typeof Observable, \"function\"\n"},"lib/pkg/require2.coffee":{"content":"# Testing a more compact version of require, also looking into packaging as\r\n# js objects with functions and not source text inside json. We'll need both,\r\n# json for loading packages as data from URLs, but we don't want to pay the\r\n# extra character escaping when loading directly on a page.\r\n\r\n# Goal is smaller package outputs, especially when embedded in script tags\r\n# handle requiring `function(){}` properties in distribution.\r\n\r\ncreate = (create) ->\r\n  fileSeparator = '/'\r\n  global = self\r\n  defaultEntryPoint = \"main\"\r\n  circularGuard = {}\r\n\r\n  rootModule =\r\n    path: \"\"\r\n  \r\n  loadPath = (parentModule, pkg, path) ->\r\n    if startsWith(path, '/')\r\n      localPath = []\r\n    else\r\n      localPath = parentModule.path.split(fileSeparator)\r\n  \r\n    normalizedPath = normalizePath(path, localPath)\r\n  \r\n    cache = cacheFor(pkg)\r\n  \r\n    if module = cache[normalizedPath]\r\n      if module is circularGuard\r\n        throw \"Circular dependency detected when requiring #{normalizedPath}\"\r\n    else\r\n      cache[normalizedPath] = circularGuard\r\n  \r\n      try\r\n        cache[normalizedPath] = module = loadModule(pkg, normalizedPath)\r\n      finally\r\n        delete cache[normalizedPath] if cache[normalizedPath] is circularGuard\r\n  \r\n    return module.exports\r\n  \r\n  normalizePath = (path, base=[]) ->\r\n    base = base.concat path.split(fileSeparator)\r\n    result = []\r\n  \r\n    while base.length\r\n      switch piece = base.shift()\r\n        when \"..\"\r\n          result.pop()\r\n        when \"\", \".\"\r\n          # Skip\r\n        else\r\n          result.push(piece)\r\n  \r\n    return result.join(fileSeparator)\r\n  \r\n  loadPackage = (pkg) ->\r\n    path = pkg.entryPoint or defaultEntryPoint\r\n  \r\n    loadPath(rootModule, pkg, path)\r\n  \r\n  loadModule = (pkg, path) ->\r\n    unless (file = pkg.distribution[path])\r\n      throw \"Could not find file at #{path} in #{pkg.name}\"\r\n\r\n    unless (content = file.content)?\r\n      throw \"Malformed package. No content for file at #{path} in #{pkg.name}\"\r\n  \r\n    program = annotateSourceURL content, pkg, path\r\n    dirname = path.split(fileSeparator)[0...-1].join(fileSeparator)\r\n  \r\n    module =\r\n      path: dirname\r\n      exports: {}\r\n  \r\n    context =\r\n      require: generateRequireFn(pkg, module)\r\n      global: global\r\n      module: module\r\n      exports: module.exports\r\n      PACKAGE: pkg\r\n\r\n    args = Object.keys(context)\r\n    values = args.map (name) -> context[name]\r\n  \r\n    Function(args..., program).apply(module, values)\r\n  \r\n    return module\r\n  \r\n  isPackage = (path) ->\r\n    if !(startsWith(path, fileSeparator) or\r\n      startsWith(path, \".#{fileSeparator}\") or\r\n      startsWith(path, \"..#{fileSeparator}\")\r\n    )\r\n      path.split(fileSeparator)[0]\r\n    else\r\n      false\r\n  \r\n  generateRequireFn = (pkg, module=rootModule) ->\r\n    pkg.name ?= \"ROOT\"\r\n    pkg.scopedName ?= \"ROOT\"\r\n\r\n    fn = (path) ->\r\n      if typeof path is \"object\"\r\n        loadPackage(path)\r\n      else if isPackage(path)\r\n        unless otherPackage = pkg.dependencies[path]\r\n          throw \"Package: #{path} not found.\"\r\n  \r\n        otherPackage.name ?= path\r\n        otherPackage.scopedName ?= \"#{pkg.scopedName}/#{path}\"\r\n  \r\n        loadPackage(otherPackage)\r\n      else\r\n        loadPath(module, pkg, path)\r\n\r\n    Object.assign fn, publicAPI\r\n  \r\n    return fn\r\n\r\n  startsWith = (string, prefix) ->\r\n    string.lastIndexOf(prefix, 0) is 0\r\n\r\n  cacheFor = (pkg) ->\r\n    return pkg.cache if pkg.cache\r\n\r\n    Object.defineProperty pkg, \"cache\",\r\n      value: {}\r\n\r\n    return pkg.cache\r\n\r\n  annotateSourceURL = (program, pkg, path) ->\r\n    \"\"\"\r\n      #{program}\r\n      //# sourceURL=#{pkg.scopedName}/#{path}\r\n    \"\"\"\r\n\r\n  # Generate source using Function#toString introspection\r\n  generateSrc = ->\r\n    src = \"\"\"\r\n      (function(create) {\r\n        return create(create)\r\n      }(#{create.toString()}))\r\n\r\n    \"\"\"\r\n\r\n  publicAPI =\r\n    generateFor: generateRequireFn\r\n\r\n    packageWrapper: (pkg, code) ->\r\n      pkgStr = JSON.stringify(pkg, null, 2)\r\n      \r\n      \"\"\"\r\n        (function(PACKAGE) {\r\n          var require = #{generateSrc()}.generateFor(PACKAGE);\r\n          #{code};\r\n        })(#{pkgStr});\r\n      \"\"\"\r\n\r\n    executePackageWrapper: (pkg) ->\r\n      publicAPI.packageWrapper pkg, \"require.loadPackage(PACKAGE)\"\r\n\r\n    loadPackage: loadPackage\r\n\r\n  if module?\r\n    module.exports = publicAPI\r\n\r\n  return publicAPI\r\n\r\n# Invoke create with reference to itself so it can output its source later.\r\ncreate create\r\n"},"lib/pkg/experimental.coffee":{"content":"# Scratch pad for pkg experiments\r\n\r\n  keyString = (key) ->\r\n    if key.match /^[A-Za-z]+[A-Za-z0-9]*$/\r\n      key\r\n    else\r\n      JSON.stringify key\r\n\r\n  # Converts a package to a string with files to require as functions \r\n  # It's like JSON but with functions for distribution files. This is intended\r\n  # to be embedded directly in a script tag or a .js file.\r\n  # Notes: This worked but didn't result in a smaller size. It may be necessary\r\n  # for use in other contexts where we need to eliminate `Function` constructor\r\n  # link in Chrome Apps or other restricted environments. Putting on the shelf\r\n  # for now.\r\n  functionalize = (pkg) ->\r\n    \"{\" + keys(pkg).map (key) ->\r\n      v = pkg[key]\r\n      if key is \"distribution\"\r\n        value = \"{\" + keys(v).map (path) ->\r\n          # TODO?: add parameters to avoid Function constructor?\r\n          \"#{keyString(path)}:function(){#{v[path].content}}\"\r\n        .join(\",\\n\") + \"}\"\r\n      else if key is \"dependencies\"\r\n        value = \"{\" + keys(v).map (dep) ->\r\n          \"#{keyString(dep)}:#{functionalize(v[dep])}\"\r\n        .join(\",\\n\") + \"}\"\r\n      else\r\n        value = JSON.stringify v, null, 2\r\n\r\n      \"#{keyString(key)}: #{value}\"\r\n    .join(\",\\n\") + \"}\"\r\n"},"style/demo.styl":{"content":"// TODO: This should be in demo app style\ndesktop\n  no-select()\n\n  display: block\n  flex: 1 0 auto\n  position: relative\n  z-index: 0\n"},"views/fuzzy-list.coffee":{"content":"Jadelet = require \"../lib/jadelet\"\nObservable = require \"../lib/observable\"\n\n{fuzzyMatch} = require \"../lib/util/index\"\n\nTemplate = Jadelet.exec \"\"\"\n  form.fuzzy-list(@submit @keydown)\n    input(@placeholder @value)\n    ul(tabindex=0)\n      @children\n\"\"\"\n\nRowTemplate = Jadelet.exec \"\"\"\n  li(@click @class @dblclick data-index=@index)\n    @content\n\"\"\"\n\nLoadingTemplate = Jadelet.exec \"\"\"\n  li Loading...\n\"\"\"\n\nkeepsKeyboard = (element) ->\n  element.tagName == 'INPUT' ||\n  element.tagName == 'SELECT' ||\n  element.tagName == 'TEXTAREA' ||\n  (element.contentEditable && element.contentEditable == 'true')\n\nmodule.exports = (model) ->\n  {\n    filter\n    ItemTemplate\n    items\n    loading\n    maxItems\n    submit\n    value\n  } = model\n\n  ItemTemplate ?= (x) -> x\n  loading ?= Observable false\n  value ?= Observable \"\"\n  maxItems ?= Observable 100\n  filter ?= (value, items) ->\n    fuzzyMatch(value, items)\n\n  activeIndex = Observable 0\n\n  clickHandler = (e) ->\n    index = parseInt e.currentTarget.dataset.index, 10\n    activeIndex index\n\n  dblclickHandler = (e) ->\n    index = parseInt e.currentTarget.dataset.index, 10\n    submit view.filteredItems()[index]\n\n  view =\n    activeIndex: activeIndex\n    activeItem: ->\n      view.filteredItems()[activeIndex()]\n    loading: loading\n    element: null\n    children: ->\n      if loading()\n        return LoadingTemplate()\n\n      view.filteredItems()\n      .slice(0, maxItems())\n      .map (item, index) ->\n        RowTemplate\n          class: ->\n            \"active\" if index is activeIndex()\n          click: clickHandler\n          dblclick: dblclickHandler\n          content: ItemTemplate item\n          index: index\n\n    filteredItems: ->\n      filter(value(), items())\n\n    keydown: (e) ->\n      if e.key is \"Enter\"\n        view.submit(e)\n        return\n\n      switch e.key\n        when \"ArrowUp\"\n          view.previousItem()\n          e.preventDefault()\n\n        when \"ArrowDown\"\n          view.nextItem()\n          e.preventDefault()\n\n    placeholder: \"Type to filter results\"\n\n    nextItem: ->\n      n = activeIndex() + 1\n      if n >= view.filteredItems().length\n        n = 0\n      activeIndex n\n\n    previousItem: ->\n      n = activeIndex() - 1\n      if n < 0\n        n = view.filteredItems().length - 1\n      activeIndex  n\n\n    submit: (e) ->\n      e.preventDefault()\n      submit view.activeItem()\n\n    value: value\n\n  activeIndex.observe (i) ->\n    el = view.element.querySelectorAll(':scope > ul > li')[i]\n    el?.scrollIntoView\n      block: \"nearest\"\n\n  view.element = Template view\n  return view\n"},"data/views/fuzzy-list.coffee":{"content":""},"lib/pkg/mod-loader.coffee":{"content":"# Experimental!\n\n# Load an exported module from a remote path into the system namespace\n# fs/storage.coffee -> system.fs.Storage\n# This is insane and I love it\nmodLoad = (path, source, namespace=system) ->\n  {compile, crudeRequire} = system.pkg\n  {withoutAllExtensions} = system.fs\n\n  compile(path, source)\n  .then (program) ->\n    exportedModule = crudeRequire program\n\n    paths = path.split(\"/\")\n    l = paths.length\n    paths.reduce (namespace, name, i) ->\n      if i is l - 1\n        # Strip all extensions\n        name = withoutAllExtensions name\n\n        # system/util/index.coffee -> methods on system.util\n        if typeof exportedModule is \"object\"\n          return Object.assign namespace, exportedModule\n        else\n          # system/fs/storage.coffee -> system.fs.Storage class\n          # Titleize name\n          name = name.replace /^([a-z])|[_-]([a-z])/g, (m, a, b) ->\n            (a or b).toUpperCase()\n  \n          return namespace[name] = exportedModule\n  \n      return namespace[name] ||= {}\n    , namespace\n\n# Create a loader for a namespace\nmodule.exports = (fs, basePath, namespace) ->\n  (path) ->\n    fs.read basePath + path\n    .then (b) -> b.text()\n    .then (source) ->\n      modLoad path, source, namespace\n"}},"distribution":{"NOTES":{},"README":{},"TODO":{},"data/pkg/samples/browserified":{"content":"!function(e){if(\"object\"==typeof exports)module.exports=e();else if(\"function\"==typeof define&&define.amd)define(e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.Test=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\r\nmodule.exports = 'coolio';\r\n\r\n},{}]},{},[1])\r\n(1)\r\n});\n"},"data/pkg/samples/circular":{"content":"require(\"./circular\");\n"},"data/pkg/samples/random":{"content":"module.exports = Math.random();\n"},"data/pkg/samples/terminal":{"content":"exports.something = true;\n"},"data/pkg/samples/throws":{"content":"throw \"yolo\";\n"},"data/templates/input":{"content":"\n"},"data/templates/menu":{"content":"module.exports = {\n  items: [\"yolo\"]\n};\n"},"data/templates/modal":{"content":"\n"},"data/templates/modal/prompt":{"content":"\n"},"data/templates/progress":{"content":"module.exports = {\n  value: 0.25,\n  min: 0,\n  max: 1\n};\n"},"data/templates/samples/test-form":{"content":"\n"},"data/templates/table":{"content":"\n"},"data/templates/window":{"content":"\n"},"data/views/ace-editor":{"content":"\n"},"data/views/context-menu":{"content":"var Util, parseMenu;\n\nUtil = require(\"../../lib/ui/index\").Util;\n\nparseMenu = Util.parseMenu;\n\nmodule.exports = {\n  items: parseMenu(\"Hello\"),\n  handlers: {}\n};\n"},"data/views/login":{"content":"\n"},"data/views/menu-bar":{"content":"module.exports = {\n  items: \"Hello\\n  Yo\",\n  handlers: {\n    yo: function() {\n      return alert(\"yo\");\n    }\n  }\n};\n"},"data/views/menu-item":{"content":"module.exports = {\n  label: \"yo23\",\n  contextRoot: {\n    handlers: {},\n    activeItem: function() {}\n  }\n};\n"},"data/views/menu-separator":{"content":"module.exports = {};\n"},"data/views/menu":{"content":"var Util, parseMenu;\n\nUtil = require(\"../../lib/ui/index\").Util;\n\nparseMenu = Util.parseMenu;\n\nmodule.exports = {\n  items: parseMenu(\"Hello\\n\"),\n  handlers: {}\n};\n"},"data/views/progress":{"content":"var Observable, model;\n\nObservable = require(\"../../lib/observable\");\n\nmodule.exports = model = {\n  max: 1,\n  value: Observable(0.25)\n};\n\nsetInterval(function() {\n  return model.value.increment(0.01);\n}, 100);\n"},"data/views/size":{"content":"\n"},"data/views/table":{"content":"module.exports = {};\n"},"data/views/window":{"content":"\n"},"demo":{"content":"var AceEditor, ContextMenu, FormSampleTemplate, FuzzyListView, Jadelet, Login, MenuBar, Modal, Observable, Progress, Style, Table, Window, addWindow, applyStyle, contextMenu, desktop, element, notepadMenuParsed, notepadMenuText, o, parseMenu, sampleMenuParsed, _ref, _ref1;\n\n_ref = require(\"./lib/ui/index\"), AceEditor = _ref.AceEditor, applyStyle = _ref.applyStyle, ContextMenu = _ref.ContextMenu, FuzzyListView = _ref.FuzzyListView, Login = _ref.Login, MenuBar = _ref.MenuBar, Modal = _ref.Modal, Observable = _ref.Observable, (_ref1 = _ref.Util, parseMenu = _ref1.parseMenu), Progress = _ref.Progress, Style = _ref.Style, Table = _ref.Table, Window = _ref.Window;\n\no = require(\"./util\").o;\n\nJadelet = require(\"./lib/jadelet\");\n\nnotepadMenuText = require(\"./samples/notepad-menu\");\n\nnotepadMenuParsed = parseMenu(notepadMenuText);\n\nFormSampleTemplate = require(\"./samples/test-form\");\n\nglobal.PACKAGE = PACKAGE;\n\napplyStyle(Style.all, \"system\");\n\napplyStyle(require(\"./style/demo\"), \"demo\");\n\nsampleMenuParsed = parseMenu(\"[M]odal\\n  [A]lert\\n  [C]onfirm\\n  [P]rompt\\n  [F]orm\\n  F[u]zzy List\\n  P[r]ogress\\n[T]est Nesting\\n  Test[1]\\n    Hello\\n    Wat\\n  Test[2]\\n    [N]ested\\n    -----\\n    [R]ad\\n      So Rad\\n      =====\\n      Hella\\n        Hecka\\n          Super Hecka\\n            Wicked\\n        ---\\n        -\\n        -\\n        ==\\n[W]indow\\n  [L]ogin\\n  New [I]mage -> newImage\\n  New [P]ixel -> newPixel\\n  New [T]ext -> newText\\n  New [S]preadsheet -> newSheet\");\n\nelement = MenuBar({\n  items: sampleMenuParsed,\n  handlers: {\n    alert: function() {\n      return Modal.alert(\"yolo\");\n    },\n    prompt: function() {\n      return Modal.prompt(\"Pretty cool, eh?\", \"Yeah!\").then(console.log);\n    },\n    confirm: function() {\n      return Modal.confirm(\"Jawsome!\").then(console.log);\n    },\n    form: function() {\n      return Modal.form(FormSampleTemplate({\n        cancel: function(e) {\n          e.preventDefault();\n          return Modal.hide();\n        }\n      })).then(console.log);\n    },\n    fuzzyList: function() {\n      var view;\n      view = FuzzyListView({\n        items: function() {\n          return Object.keys(PACKAGE.source);\n        },\n        ItemTemplate: function(item) {\n          var Template, content;\n          content = PACKAGE.source[item].content;\n          Template = Jadelet.exec(\"div\\n  span.name @name\\n  span.length(style=\\\"float: right; font-style: italic; margin-right: 1rem\\\") @size\");\n          return Template({\n            name: item,\n            size: content.length\n          });\n        },\n        maxItems: function() {\n          return 9999;\n        },\n        submit: function(item) {\n          Modal.hide();\n          return console.log(PACKAGE.source[item]);\n        }\n      });\n      return Modal.form(view.element, {\n        cancellable: true\n      });\n    },\n    login: function() {\n      return new Promise(function(resolve, reject) {\n        return Login({\n          resolve: resolve,\n          reject: reject\n        });\n      }).then(function(account) {\n        return console.log(account);\n      })[\"catch\"](function() {\n        return console.log(\"Login cancelled\");\n      });\n    },\n    progress: function() {\n      var initialMessage, intervalId, progressView;\n      initialMessage = \"Reticulating splines\";\n      progressView = Progress({\n        value: 0,\n        max: 2,\n        message: initialMessage\n      });\n      Modal.show(progressView.element, {\n        cancellable: false\n      });\n      return intervalId = setInterval(function() {\n        var ellipses, ellipsesCount, newValue, _i, _results;\n        newValue = progressView.value() + 1 / 60;\n        ellipsesCount = Math.floor(newValue * 4) % 4;\n        ellipses = (function() {\n          _results = [];\n          for (var _i = 0; 0 <= ellipsesCount ? _i < ellipsesCount : _i > ellipsesCount; 0 <= ellipsesCount ? _i++ : _i--){ _results.push(_i); }\n          return _results;\n        }).apply(this).map(function() {\n          return \".\";\n        }).join(\"\");\n        progressView.value(newValue);\n        progressView.message(initialMessage + ellipses);\n        if (newValue > 2) {\n          clearInterval(intervalId);\n          return Modal.hide();\n        }\n      }, 15);\n    },\n    newImage: function() {\n      var img;\n      img = document.createElement(\"img\");\n      img.src = \"https://s3.amazonaws.com/whimsyspace-databucket-1g3p6d9lcl6x1/danielx/data/pI1mvEvxcXJk4mNHNUW-kZsNJsrPDXcAtgguyYETRXQ\";\n      return addWindow({\n        title: \"Yoo\",\n        content: img,\n        iconEmoji: \"ðŸ’¼\"\n      });\n    },\n    newPixel: function() {\n      var frame;\n      frame = document.createElement(\"iframe\");\n      frame.src = \"https://danielx.net/pixel-editor/embedded/\";\n      return addWindow({\n        title: \"Pixel\",\n        content: frame\n      });\n    },\n    newText: function() {\n      return AceEditor.preload().then(function() {\n        var editor;\n        editor = AceEditor();\n        return addWindow({\n          title: \"Notepad.exe\",\n          content: editor.element\n        });\n      });\n    },\n    newSheet: function() {\n      var InputTemplate, RowElement, data, menuBar, tableView;\n      data = [0, 1, 2, 3, 4].map(function(i) {\n        return {\n          id: i,\n          name: \"yolo\",\n          color: \"#FF0000\"\n        };\n      });\n      InputTemplate = require(\"./templates/input\");\n      RowElement = function(datum) {\n        var tr, types;\n        tr = document.createElement(\"tr\");\n        types = [\"number\", \"text\", \"color\"];\n        Object.keys(datum).forEach(function(key, i) {\n          var td;\n          td = document.createElement(\"td\");\n          td.appendChild(InputTemplate({\n            value: o(datum, key),\n            type: types[i]\n          }));\n          return tr.appendChild(td);\n        });\n        return tr;\n      };\n      element = (tableView = Table({\n        data: data,\n        RowElement: RowElement\n      })).element;\n      menuBar = MenuBar({\n        items: parseMenu(\"Insert\\n  Row -> insertRow\\nHelp\\n  About\"),\n        handlers: {\n          about: function() {\n            return Modal.alert(\"Spreadsheet v0.0.1 by Daniel X Moore\");\n          },\n          insertRow: function() {\n            data.push({\n              id: 50,\n              name: \"new\",\n              color: \"#FF00FF\"\n            });\n            return tableView.render();\n          }\n        }\n      });\n      return addWindow({\n        title: \"Spreadsheet [DEMO VERSION]\",\n        content: element,\n        menuBar: menuBar.element\n      });\n    }\n  }\n}).element;\n\ndocument.body.appendChild(element);\n\ndesktop = document.createElement(\"desktop\");\n\ndocument.body.appendChild(desktop);\n\ncontextMenu = ContextMenu({\n  items: sampleMenuParsed[1][1],\n  handlers: {}\n});\n\ndesktop.addEventListener(\"contextmenu\", function(e) {\n  if (e.target === desktop) {\n    e.preventDefault();\n    return contextMenu.display({\n      inElement: document.body,\n      x: e.pageX,\n      y: e.pageY\n    });\n  }\n});\n\naddWindow = function(params) {\n  var windowView;\n  windowView = Window(params);\n  desktop.appendChild(windowView.element);\n  return windowView;\n};\n"},"docs/Bindable":{},"docs/app":{},"docs/getting-started":{},"hotkeys":{"content":"\n/*\nHotkeys\n=======\n\nBind hotkeys\n\n    Hotkey = require \"hotkey\"\n\n    Hotkey \"ctrl+r\", ->\n      alert \"radical!\"\n\nWe'd like to be able to generate a list of hotkeys with descriptions.\n\nQuestions\n---------\n\nShould we just use Mousetrap?\n\nMaybe, but it may have different semantics with preventDefault/defaultPrevented.\n\nShould we allow binding to specific elements?\n\nImagine a windowing OS where non-iframe apps are inside draggable windows. We'd\nlike to have each 'app' able to have its own hotkeys and at the same time have\nglobal OS level hotkeys.\n\nShould `defaultPrevented` prevent executing the hotkey action? Yes\n\nShould executing a hotkey preventDefault? Yes\n */\nmodule.exports = function(element) {\n  var handle, handlers;\n  handlers = {};\n  return handle = function(event) {\n    var combo, key, modifiersActive;\n    key = event.key;\n    modifiersActive = [\"alt\", \"ctrl\", \"meta\", \"shift\"].filter(function(modifier) {\n      return event[\"\" + modifier + \"Key\"];\n    });\n    combo = modifiersActive.concat(key).join(\"+\");\n    return typeof handlers[combo] === \"function\" ? handlers[combo](e) : void 0;\n  };\n};\n"},"lib/acct/account":{"content":"var Cognito, cognito, fs, promiseChoke;\n\nCognito = require(\"/lib/aws/cognito\");\n\ncognito = Cognito(PACKAGE.config.cognito);\n\nfs = require(\"../fs/index\");\n\npromiseChoke = require(\"../util/index\").promiseChoke;\n\nmodule.exports = function(AWS) {\n  var bucket, id, refreshCredentials;\n  id = AWS.config.credentials.identityId;\n  bucket = new AWS.S3({\n    params: {\n      Bucket: \"whimsy-fs\"\n    }\n  });\n  refreshCredentials = promiseChoke(function() {\n    return cognito.cachedUser().then(function(AWS) {\n      return bucket.config.credentials = AWS.config.credentials;\n    })[\"catch\"](console.debug);\n  });\n  return {\n    id: id,\n    fs: fs.S3(id, bucket, refreshCredentials),\n    logout: function() {\n      return cognito.logout();\n    }\n  };\n};\n"},"lib/acct/index":{"content":"var Login;\n\nLogin = require(\"/views/login\");\n\nmodule.exports = {\n  login: function(showUI) {\n    return new Promise(function(resolve, reject) {\n      return Login({\n        headless: !showUI,\n        resolve: resolve,\n        reject: reject\n      });\n    });\n  }\n};\n"},"lib/app/hotkeys":{"content":"\n/*\nBind app hotekeys. Assumes global context, not currently safe for multiple\ninstances. Reloading \"works\" by overwriting previous bindings.\n\nStatus: Active Experiment in Paint Composer, consolidating here.\n */\nvar HotkeyCategoryRow, HotkeyRow, HotkeyTable, Mousetrap, categoryAttr, compileTemplate, groupBy;\n\ncompileTemplate = require(\"../jadelet\").exec;\n\ngroupBy = require(\"../util/index\").groupBy;\n\nMousetrap = require(\"../mousetrap\");\n\nMousetrap.prototype.stopCallback = function(e, element, combo) {\n  if (combo.match(/^(ctrl|alt|meta|option|command)\\+/)) {\n    return false;\n  }\n  return element.tagName === 'INPUT' || element.tagName === 'SELECT' || element.tagName === 'TEXTAREA' || (element.contentEditable && element.contentEditable === 'true');\n};\n\nHotkeyTable = compileTemplate(\"table\\n  thead\\n    tr\\n      th(colspan=\\\"2\\\") Hotkeys\\n  tbody\\n    @rows\");\n\nHotkeyRow = compileTemplate(\"tr\\n  td @name\\n  td.right\\n    code @key\");\n\nHotkeyCategoryRow = compileTemplate(\"tr.hotkey-category\\n  th(colspan=\\\"2\\\") @group\");\n\ncategoryAttr = function(m) {\n  return m.category;\n};\n\nmodule.exports = function(self) {\n  var hotkeys;\n  hotkeys = [];\n  return Object.assign(self, {\n    hotkey: function() {\n      return self.addHotkey.apply(self, arguments);\n    },\n    addHotkey: function(key, method, meta) {\n      var keyString;\n      if (meta) {\n        if (typeof key === 'string') {\n          keyString = key;\n        } else {\n          keyString = key.join(',');\n        }\n        hotkeys.push(Object.assign({\n          key: keyString\n        }, meta));\n      }\n      return Mousetrap.bind(key, function(e) {\n        if (e.defaultPrevented) {\n          return;\n        }\n        e.preventDefault();\n        if (typeof method === \"function\") {\n          return method.call(self, e);\n        } else {\n          return self[method](e);\n        }\n      });\n    },\n    addHotkeyInfo: function(meta) {\n      return hotkeys.push(meta);\n    },\n    hotkeys: function() {\n      return hotkeys;\n    },\n    hotkeysInfoElement: function() {\n      var aggregatedHotkeys, rows;\n      aggregatedHotkeys = groupBy(hotkeys, categoryAttr);\n      rows = Object.keys(aggregatedHotkeys).reduce(function(result, group) {\n        var entries;\n        entries = aggregatedHotkeys[group];\n        result.push(HotkeyCategoryRow({\n          group: group\n        }));\n        return result.concat(entries.map(HotkeyRow));\n      }, []);\n      return HotkeyTable({\n        rows: rows\n      });\n    }\n  });\n};\n"},"lib/app/index":{"content":"var Bindable, Drop, Hotkeys, Jadelet, MenuBar, Modal, Observable, Style, TemplateLoader, applyStyle, crudeRequire, getProp, _ref;\n\n_ref = require(\"../ui/index\"), applyStyle = _ref.applyStyle, Drop = _ref.Drop, Jadelet = _ref.Jadelet, MenuBar = _ref.MenuBar, Modal = _ref.Modal, Observable = _ref.Observable, Style = _ref.Style;\n\nBindable = require(\"../bindable\");\n\ncrudeRequire = require(\"../pkg/index\").crudeRequire;\n\nTemplateLoader = require(\"./template-loader\");\n\nHotkeys = require(\"./hotkeys\");\n\nmodule.exports = function(host, application) {\n  return function(app) {\n    var ReaderInput, _ref1;\n    if (app == null) {\n      app = {};\n    }\n    if (app.saved == null) {\n      app.saved = Observable(true);\n    }\n    if (app.currentPath == null) {\n      app.currentPath = Observable(\"\");\n    }\n    if (app.config == null) {\n      app.config = {};\n    }\n    Bindable(null, app);\n    Hotkeys(app);\n    Object.assign(app, {\n      confirmUnsaved: function() {\n        if (app.saved()) {\n          return Promise.resolve();\n        }\n        return new Promise(function(resolve, reject) {\n          return Modal.confirm(\"You will lose unsaved progress, continue?\").then(function(result) {\n            if (result) {\n              return resolve();\n            } else {\n              return reject();\n            }\n          });\n        });\n      },\n      exit: function() {\n        return application.exit();\n      },\n      extend: Object.assign.bind(null, app),\n      drop: function(files) {\n        var file;\n        file = files[0];\n        app.loadFile(file, file.name);\n        return true;\n      },\n      paste: function(files) {\n        var file;\n        file = files[0];\n        app.loadFile(file, file.name);\n        return true;\n      },\n      \"new\": function() {\n        if (app.saved()) {\n          app.currentPath(\"\");\n          return app.newFile();\n        } else {\n          return app.confirmUnsaved().then(function() {\n            app.saved(true);\n            return app.newFile();\n          });\n        }\n      },\n      open: function() {\n        return app.confirmUnsaved().then(function() {\n          return Modal.prompt(\"File Path\", app.currentPath()).then(function(newPath) {\n            if (newPath) {\n              return app.currentPath(newPath);\n            } else {\n              throw new Error(\"No path given\");\n            }\n          }).then(function(path) {\n            return host.readFile(path, true).then(function(file) {\n              return app.loadFile(file, path);\n            });\n          });\n        })[\"catch\"](function(e) {\n          if (e) {\n            throw e;\n          }\n        });\n      },\n      reloadStyle: function(cssText) {\n        return applyStyle(cssText, \"app\");\n      },\n      save: function() {\n        var path;\n        path = app.currentPath();\n        if (path) {\n          return Promise.resolve().then(function() {\n            return app.saveData();\n          }).then(function(blob) {\n            return host.writeFile(path, blob, true);\n          }).then(function() {\n            app.saved(true);\n            return path;\n          });\n        } else {\n          return app.saveAs();\n        }\n      },\n      saveAs: function() {\n        return Modal.prompt(\"File Path\", app.currentPath()).then(function(path) {\n          if (path) {\n            app.currentPath(path);\n            return app.save();\n          }\n        });\n      }\n    });\n    if ((_ref1 = system.config) != null ? _ref1.standalone : void 0) {\n      ReaderInput = require(\"../../templates/reader-input\");\n      app.open = function() {\n        return Modal.show(ReaderInput({\n          accept: typeof app.accept === \"function\" ? app.accept() : void 0,\n          select: function(file) {\n            Modal.hide();\n            return app.loadFile(file);\n          }\n        }));\n      };\n      app.save = function() {\n        return Modal.prompt(\"File name\", \"newfile.txt\").then(function(name) {\n          return app.saveData();\n        }).then(function(blob) {\n          return blob.download();\n        });\n      };\n    }\n    Drop(document, function(e) {\n      var files;\n      if (e.defaultPrevented) {\n        return;\n      }\n      files = e.dataTransfer.files;\n      if (files.length) {\n        if (app.drop(files)) {\n          return e.preventDefault();\n        }\n      }\n    });\n    document.addEventListener(\"paste\", function(e) {\n      var clipboardData, files;\n      if (e.defaultPrevented) {\n        return;\n      }\n      clipboardData = e.clipboardData;\n      files = clipboardData.files;\n      if (files.length) {\n        if (app.paste(files)) {\n          return e.preventDefault();\n        }\n      }\n      files = Array.prototype.map.call(e.clipboardData.items, function(item) {\n        return item.getAsFile();\n      }).filter(function(file) {\n        return file;\n      });\n      if (files.length) {\n        if (app.paste(files)) {\n          return e.preventDefault();\n        }\n      }\n    });\n    try {\n      if (app.T == null) {\n        app.T = {};\n      }\n      TemplateLoader(app.pkg, app.T);\n    } catch (_error) {}\n    try {\n      app.version = crudeRequire(app.pkg.distribution.pixie.content).version;\n    } catch (_error) {}\n    app.on(\"boot\", function() {\n      var menuBar;\n      if (app.config.baseStyle !== false) {\n        applyStyle(Style.all, \"base\");\n      }\n      if (this.style) {\n        applyStyle(this.style, \"app\");\n      } else {\n        try {\n          applyStyle(crudeRequire(app.pkg.distribution.style.content), \"app\");\n        } catch (_error) {}\n      }\n      if (this.menu) {\n        menuBar = MenuBar({\n          items: this.menu,\n          handlers: this\n        });\n        document.body.appendChild(menuBar.element);\n        app.on(\"dispose\", function() {\n          menuBar.element.remove();\n          return Jadelet.dispose(menuBar.element);\n        });\n      }\n      if (this.element) {\n        document.body.appendChild(this.element);\n      } else if (this.template) {\n        this.element = Jadelet.exec(this.template)(this);\n        document.body.appendChild(this.element);\n      } else if (this.T.App) {\n        this.element = this.T.App(this);\n        document.body.appendChild(this.element);\n      }\n      application.delegate = this;\n      if (this.title != null) {\n        Observable(function() {\n          return application.title(getProp(app, \"title\"));\n        });\n      }\n      if (this.icon != null) {\n        Observable(function() {\n          return application.icon(getProp(app, \"icon\"));\n        });\n      }\n      if (this.saved != null) {\n        return Observable(function() {\n          return application.saved(getProp(app, \"saved\"));\n        });\n      }\n    });\n    app.on(\"dispose\", function() {\n      if (this.element) {\n        this.element.remove();\n        return Jadelet.dispose(this.element);\n      }\n    });\n    return app;\n  };\n};\n\ngetProp = function(context, prop) {\n  if (typeof context[prop] === 'function') {\n    return context[prop]();\n  } else {\n    return context[prop];\n  }\n};\n"},"lib/app/template-loader":{"content":"var crudeRequire;\n\ncrudeRequire = require(\"../pkg/index\").crudeRequire;\n\nmodule.exports = function(pkg, templates) {\n  if (templates == null) {\n    templates = {};\n  }\n  Object.keys(pkg.distribution).forEach(function(key) {\n    var e, templateName;\n    if (key.startsWith('templates/')) {\n      templateName = key.replace(/^templates\\//, \"\").replace(/^([a-z])|[_-]([a-z])/g, function(m, a, b) {\n        return (a || b).toUpperCase();\n      });\n      try {\n        return templates[templateName] = crudeRequire(pkg.distribution[key].content);\n      } catch (_error) {\n        e = _error;\n        return console.warn(e);\n      }\n    }\n  });\n  return templates;\n};\n"},"lib/assert":{"content":"module.exports = function(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n};\n"},"lib/aws/_lazy":{"content":"var lazyLoader;\n\nlazyLoader = require(\"../util/index\").lazyLoader;\n\nmodule.exports = lazyLoader([\"https://danielx.whimsy.space/cdn/cognito/sdk.min.js\", \"https://danielx.whimsy.space/cdn/cognito/identity.min.js\", \"https://sdk.amazonaws.com/js/aws-sdk-2.7.20.min.js\"]);\n"},"lib/aws/cognito":{"content":"\n/*\nCognito info:\n\nJS SDK: https://github.com/aws/amazon-cognito-identity-js\nPricing: https://aws.amazon.com/cognito/pricing/\nAdding Social Identity Providers: http://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-social.html\n\nhttps://whimsy.auth.us-east-1.amazoncognito.com/oauth2/idpresponse\n */\nvar _LL,\n  __slice = [].slice;\n\n_LL = require(\"./_lazy\");\n\nmodule.exports = function(_arg) {\n  var LL, configureAWSFor, identityPoolId, mapAttributes, poolData, self, userPool, _init;\n  identityPoolId = _arg.identityPoolId, poolData = _arg.poolData;\n  userPool = null;\n  _init = function() {\n    var _base;\n    if (userPool == null) {\n      userPool = new AWSCognito.CognitoIdentityServiceProvider.CognitoUserPool(poolData);\n    }\n    return (_base = AWS.config).region != null ? _base.region : _base.region = 'us-east-1';\n  };\n  LL = function(fn) {\n    return _LL(function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      _init();\n      return fn.apply(this, args);\n    });\n  };\n  configureAWSFor = function(session, resolve, reject) {\n    var loginKey, loginsConfig, token;\n    token = session.getIdToken().getJwtToken();\n    loginKey = \"cognito-idp.us-east-1.amazonaws.com/\" + poolData.UserPoolId;\n    loginsConfig = {};\n    loginsConfig[loginKey] = token;\n    AWS.config.credentials = new AWS.CognitoIdentityCredentials({\n      IdentityPoolId: identityPoolId,\n      Logins: loginsConfig\n    });\n    AWS.config.credentials.refresh(function(error) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(AWS);\n      }\n    });\n  };\n  mapAttributes = function(attributes) {\n    if (!attributes) {\n      return;\n    }\n    return Object.keys(attributes).map(function(name) {\n      var value;\n      value = attributes[name];\n      return new AWSCognito.CognitoIdentityServiceProvider.CognitoUserAttribute({\n        Name: name,\n        Value: value\n      });\n    });\n  };\n  return self = {\n    signUp: LL(function(username, password, attributes) {\n      var attributeList;\n      attributeList = mapAttributes(attributes);\n      return new Promise(function(resolve, reject) {\n        return userPool.signUp(username, password, attributeList, null, function(err, result) {\n          var cognitoUser;\n          if (err) {\n            return reject(err);\n          }\n          cognitoUser = result.user;\n          return resolve(cognitoUser);\n        });\n      });\n    }),\n    authenticate: LL(function(username, password) {\n      var authenticationData, authenticationDetails, cognitoUser, userData;\n      authenticationData = {\n        Username: username,\n        Password: password\n      };\n      authenticationDetails = new AWSCognito.CognitoIdentityServiceProvider.AuthenticationDetails(authenticationData);\n      userData = {\n        Username: username,\n        Pool: userPool\n      };\n      cognitoUser = new AWSCognito.CognitoIdentityServiceProvider.CognitoUser(userData);\n      return new Promise(function(resolve, reject) {\n        return cognitoUser.authenticateUser(authenticationDetails, {\n          onSuccess: function(session) {\n            return configureAWSFor(session, resolve, reject);\n          },\n          onFailure: reject\n        });\n      });\n    }),\n    cachedUser: LL(function() {\n      return new Promise(function(resolve, reject) {\n        var cognitoUser;\n        cognitoUser = userPool.getCurrentUser();\n        if (cognitoUser) {\n          return cognitoUser.getSession(function(err, session) {\n            if (err) {\n              reject(err);\n              return;\n            }\n            return configureAWSFor(session, resolve, reject);\n          });\n        } else {\n          return setTimeout(function() {\n            return reject(new Error(\"No cached user\"));\n          });\n        }\n      });\n    }),\n    logout: function() {\n      if (typeof AWS !== \"undefined\" && AWS !== null) {\n        delete AWS.config.credentials;\n      }\n      try {\n        localStorage;\n      } catch (_error) {\n        return;\n      }\n      Object.keys(localStorage).filter(function(key) {\n        return key.match(/^CognitoIdentityServiceProvider/);\n      }).forEach(function(key) {\n        return delete localStorage[key];\n      });\n    }\n  };\n};\n"},"lib/aws/index":{"content":"\n/*\nInterface to all our AWS madness.\n */\nvar LL, urlSafeSHA256;\n\nurlSafeSHA256 = require(\"../util/index\").urlSafeSHA256;\n\nLL = require(\"./_lazy\");\n\nmodule.exports = {\n  Cognito: require(\"./cognito\"),\n  api: LL(function(path, params) {\n    var url;\n    if (params == null) {\n      params = {};\n    }\n    url = new URL(\"https://api.whimsy.space/\" + path);\n    url.searchParams.append(\"idpjwt\", Object.values(AWS.config.credentials.params.Logins)[0]);\n    if (params.body != null) {\n      params.body = JSON.stringify(params.body);\n    }\n    return fetch(url, params);\n  }),\n  cdn: LL(function(blob) {\n    var S3, id, queryExisting;\n    S3 = new AWS.S3({\n      params: {\n        Bucket: \"whimsy-fs\"\n      }\n    });\n    S3.config.credentials = AWS.config.credentials;\n    id = AWS.config.credentials.identityId;\n    queryExisting = function(sha) {\n      return fetch(\"https://whimsy.space/cdn/\" + sha, {\n        method: 'HEAD'\n      }).then(function(response) {\n        return response.status === 200;\n      });\n    };\n    return urlSafeSHA256(blob).then(function(sha) {\n      return queryExisting(sha).then(function(found) {\n        if (found) {\n          return sha;\n        }\n        return S3.putObject({\n          Key: \"incoming/\" + id + \"/\" + sha,\n          ContentType: blob.type,\n          Body: blob\n        }).promise().then(function() {\n          return new Promise(function(resolve, reject) {\n            var check, n, timeout;\n            timeout = 1000;\n            n = 0;\n            check = function() {\n              n += 1;\n              if (n <= 10) {\n                return queryExisting(sha).then(function(found) {\n                  if (found) {\n                    return resolve(sha);\n                  } else {\n                    return setTimeout(function() {\n                      return check();\n                    }, timeout);\n                  }\n                });\n              } else {\n                return reject();\n              }\n            };\n            return check();\n          });\n        });\n      });\n    });\n  }),\n  ws: function() {\n    var url;\n    url = new URL(\"wss://ws.whimsy.space/\");\n    url.searchParams.append(\"idpjwt\", Object.values(AWS.config.credentials.params.Logins)[0]);\n    return new WebSocket(url);\n  },\n  ready: LL(function() {\n    return AWS;\n  })\n};\n"},"lib/bindable":{"content":"var remove,\n  __slice = [].slice;\n\nmodule.exports = function(I, self) {\n  var eventCallbacks;\n  if (I == null) {\n    I = {};\n  }\n  if (self == null) {\n    self = {};\n  }\n  eventCallbacks = {};\n  Object.assign(self, {\n    on: function(event, callback) {\n      eventCallbacks[event] || (eventCallbacks[event] = []);\n      eventCallbacks[event].push(callback);\n      return self;\n    },\n    off: function(event, callback) {\n      if (event) {\n        eventCallbacks[event] || (eventCallbacks[event] = []);\n        if (callback) {\n          remove(eventCallbacks[event], callback);\n        } else {\n          eventCallbacks[event] = [];\n        }\n      }\n      return self;\n    },\n    trigger: function() {\n      var event, parameters;\n      event = arguments[0], parameters = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      (eventCallbacks[\"*\"] || []).forEach(function(callback) {\n        return callback.apply(self, [event].concat(parameters));\n      });\n      if (event !== \"*\") {\n        (eventCallbacks[event] || []).forEach(function(callback) {\n          return callback.apply(self, parameters);\n        });\n      }\n      return self;\n    }\n  });\n  return self;\n};\n\nremove = function(array, value) {\n  var index;\n  index = array.indexOf(value);\n  if (index >= 0) {\n    return array.splice(index, 1)[0];\n  }\n};\n"},"lib/core":{"content":"\n/*\nModel\n=====\n\nThe `Model` module provides helper methods to compose nested data models.\n */\nvar Model, Observable, defaults, extend, getValue, isFn, setValue,\n  __slice = [].slice;\n\nObservable = require(\"./observable\");\n\nmodule.exports = Model = function(I, self) {\n  if (I == null) {\n    I = {};\n  }\n  if (self == null) {\n    self = {};\n  }\n  Object.assign(self, {\n\n    /*\n    `I` holds the instance state. It is generally considered private, but access\n    is available for debugging and other purposes.\n     */\n    I: I,\n\n    /*\n    Extends this object with methods from the passed in object. A shortcut for Object.extend(self, methods)\n    \n    >     I =\n    >       x: 30\n    >       y: 40\n    >       maxSpeed: 5\n    >\n    >     # we are using extend to give player\n    >     # additional methods that Model doesn't have\n    >     player = Model(I).extend\n    >       increaseSpeed: ->\n    >         I.maxSpeed += 1\n    >\n    >     player.increaseSpeed()\n     */\n    extend: function() {\n      var objects;\n      objects = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return Object.assign.apply(Object, [self].concat(__slice.call(objects)));\n    },\n\n    /*\n    Includes a module in this object. A module is a constructor that takes two parameters, `I` and `self`\n    \n    >     myObject = Model()\n    >     myObject.include(Bindable)\n    \n    >     # now you can bind handlers to functions\n    >     myObject.bind \"someEvent\", ->\n    >       alert(\"wow. that was easy.\")\n     */\n    include: function() {\n      var Module, modules, _i, _len;\n      modules = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      for (_i = 0, _len = modules.length; _i < _len; _i++) {\n        Module = modules[_i];\n        if (Module.length === 1) {\n          Module(self);\n        } else {\n          Module(I, self);\n        }\n      }\n      return self;\n    },\n\n    /*\n    Bind a data model getter/setter to an attribute. The data model is bound directly to\n    the attribute and must be directly convertible to and from JSON.\n     */\n    attrData: function(name, DataModel) {\n      I[name] = DataModel(I[name]);\n      return Object.defineProperty(self, name, {\n        get: function() {\n          return I[name];\n        },\n        set: function(value) {\n          return I[name] = DataModel(value);\n        }\n      });\n    },\n\n    /*\n    Observe any number of attributes as observables. For each attribute name passed in we expose a public getter/setter method and listen to changes when the value is set.\n     */\n    attrObservable: function() {\n      var names;\n      names = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      names.forEach(function(name) {\n        self[name] = Observable(I[name]);\n        return self[name].observe(function(newValue) {\n          return I[name] = newValue;\n        });\n      });\n      return self;\n    },\n\n    /*\n    Observe an attribute as a model. Treats the attribute given as an Observable\n    model instance exposing a getter/setter method of the same name. The Model\n    constructor must be passed explicitly.\n     */\n    attrModel: function(name, Model) {\n      var model;\n      model = Model(I[name]);\n      self[name] = Observable(model);\n      self[name].observe(function(newValue) {\n        return I[name] = newValue.I;\n      });\n      return self;\n    },\n\n    /*\n    Observe an attribute as an array of sub-models. This is the same as `attrModel`\n    except the attribute is expected to be an array of models rather than a single one.\n     */\n    attrModels: function(name, Model) {\n      var models;\n      models = (I[name] || []).map(function(x) {\n        return Model(x);\n      });\n      self[name] = Observable(models);\n      self[name].observe(function(newValue) {\n        return I[name] = newValue.map(function(instance) {\n          return instance.I;\n        });\n      });\n      return self;\n    },\n\n    /*\n    Delegate methods to another target. Makes it easier to compose rather than extend.\n     */\n    delegate: function() {\n      var names, to, _arg, _i;\n      names = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), _arg = arguments[_i++];\n      to = _arg.to;\n      return names.forEach(function(name) {\n        return Object.defineProperty(self, name, {\n          get: function() {\n            var receiver;\n            receiver = getValue(self, to);\n            return receiver[name];\n          },\n          set: function(value) {\n            var receiver;\n            receiver = getValue(self, to);\n            return setValue(receiver, name, value);\n          }\n        });\n      });\n    },\n\n    /*\n    The JSON representation is kept up to date via the observable properites and resides in `I`.\n     */\n    toJSON: function() {\n      return I;\n    }\n  });\n  return self;\n};\n\nisFn = function(x) {\n  return typeof x === 'function';\n};\n\ngetValue = function(receiver, property) {\n  if (isFn(receiver[property])) {\n    return receiver[property]();\n  } else {\n    return receiver[property];\n  }\n};\n\nsetValue = function(receiver, property, value) {\n  var target;\n  target = receiver[property];\n  if (isFn(target)) {\n    return target.call(receiver, value);\n  } else {\n    return receiver[property] = value;\n  }\n};\n\ndefaults = function() {\n  var name, object, objects, target, _i, _len;\n  target = arguments[0], objects = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n  for (_i = 0, _len = objects.length; _i < _len; _i++) {\n    object = objects[_i];\n    for (name in object) {\n      if (!target.hasOwnProperty(name)) {\n        target[name] = object[name];\n      }\n    }\n  }\n  return target;\n};\n\nextend = Object.assign;\n\nObject.assign(Model, {\n  Observable: Observable,\n  defaults: defaults,\n  extend: extend\n});\n"},"lib/exp/core-state":{"content":"\n/*\nNOTE: This is experimenting with passing a single `self` reference rather than\n`I`, `self` as parameters. I don't think it is better, but it was worth\ncomparing.\n\nCore\n====\n\n`Core` provides helper methods to compose nested data models. It handles\ndata persistence and state binding. It provides common helpers and extensions\nto expand an object with modules.\n\nBy providing a common way to bind state and compose data we can use Core as a\ncommon building block for many types of objects.\n */\nvar Model, Observable, defaults, extend, getValue, isFn, setValue,\n  __slice = [].slice;\n\nObservable = require(\"../observable\");\n\nmodule.exports = Model = function(self) {\n  if (self == null) {\n    self = {};\n  }\n  defaults(self, {\n    __state: {}\n  });\n  extend(self, {\n\n    /*\n    Extends this object with methods from the passed in object. A shortcut for Object.extend(self, methods)\n    \n    >     I =\n    >       x: 30\n    >       y: 40\n    >       maxSpeed: 5\n    >\n    >     # we are using extend to give player\n    >     # additional methods that Model doesn't have\n    >     player = Model(I).extend\n    >       increaseSpeed: ->\n    >         I.maxSpeed += 1\n    >\n    >     player.increaseSpeed()\n     */\n    extend: function() {\n      var objects;\n      objects = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return extend.apply(null, [self].concat(__slice.call(objects)));\n    },\n\n    /*\n    Includes a module in this object. A module is a constructor that takes one \n    parameter `self`. It extends the object with any additional behavior.\n    \n    >     myObject = Model()\n    >     myObject.include(Bindable)\n    \n    >     # now you can bind handlers to functions\n    >     myObject.bind \"someEvent\", ->\n    >       alert(\"wow. that was easy.\")\n     */\n    include: function() {\n      var Module, modules, _i, _len;\n      modules = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      for (_i = 0, _len = modules.length; _i < _len; _i++) {\n        Module = modules[_i];\n        Module(self);\n      }\n      return self;\n    },\n\n    /*\n    Bind a data model getter/setter to an attribute. The data model is bound directly to\n    the attribute and must be directly convertible to and from JSON.\n     */\n    attrData: function(name, DataModel) {\n      self.__state[name] = DataModel(self.__state[name]);\n      return Object.defineProperty(self, name, {\n        get: function() {\n          return self.__state[name];\n        },\n        set: function(value) {\n          return self.__state[name] = DataModel(value);\n        }\n      });\n    },\n\n    /*\n    Observe any number of attributes as observables. For each attribute name passed in we expose a public getter/setter method and listen to changes when the value is set.\n     */\n    attrObservable: function() {\n      var names;\n      names = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      names.forEach(function(name) {\n        self[name] = Observable(self.__state[name]);\n        return self[name].observe(function(newValue) {\n          return self.__state[name] = newValue;\n        });\n      });\n      return self;\n    },\n\n    /*\n    Observe an attribute as a model. Treats the attribute given as an Observable\n    model instance exposing a getter/setter method of the same name. The Model\n    constructor must be passed explicitly.\n     */\n    attrModel: function(name, Model) {\n      var model;\n      model = Model({\n        __state: self.__state[name]\n      });\n      self[name] = Observable(model);\n      self[name].observe(function(newValue) {\n        return self.__state[name] = newValue.__state;\n      });\n      return self;\n    },\n\n    /*\n    Observe an attribute as an array of sub-models. This is the same as `attrModel`\n    except the attribute is expected to be an array of models rather than a single one.\n     */\n    attrModels: function(name, Model) {\n      var models;\n      models = (self.__state[name] || []).map(function(x) {\n        return Model({\n          __state: x\n        });\n      });\n      self[name] = Observable(models);\n      self[name].observe(function(newValue) {\n        return self.__state[name] = newValue.map(function(instance) {\n          return instance.__state;\n        });\n      });\n      return self;\n    },\n\n    /*\n    Delegate methods to another target. Makes it easier to compose rather than extend.\n     */\n    delegate: function() {\n      var names, to, _arg, _i;\n      names = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), _arg = arguments[_i++];\n      to = _arg.to;\n      return names.forEach(function(name) {\n        return Object.defineProperty(self, name, {\n          get: function() {\n            var receiver;\n            receiver = getValue(self, to);\n            return receiver[name];\n          },\n          set: function(value) {\n            var receiver;\n            receiver = getValue(self, to);\n            return setValue(receiver, name, value);\n          }\n        });\n      });\n    },\n\n    /*\n    The JSON representation is kept up to date via the observable properites and resides in `I`.\n     */\n    toJSON: function() {\n      return self.__state;\n    }\n  });\n  return self;\n};\n\nisFn = function(x) {\n  return typeof x === 'function';\n};\n\ngetValue = function(receiver, property) {\n  if (isFn(receiver[property])) {\n    return receiver[property]();\n  } else {\n    return receiver[property];\n  }\n};\n\nsetValue = function(receiver, property, value) {\n  var target;\n  target = receiver[property];\n  if (isFn(target)) {\n    return target.call(receiver, value);\n  } else {\n    return receiver[property] = value;\n  }\n};\n\ndefaults = function() {\n  var name, object, objects, target, _i, _len;\n  target = arguments[0], objects = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n  for (_i = 0, _len = objects.length; _i < _len; _i++) {\n    object = objects[_i];\n    for (name in object) {\n      if (!target.hasOwnProperty(name)) {\n        target[name] = object[name];\n      }\n    }\n  }\n  return target;\n};\n\nextend = Object.assign;\n\nObject.assign(Model, {\n  Observable: Observable,\n  defaults: defaults,\n  extend: extend\n});\n"},"lib/exports":{"content":"var Postmaster, Runtime, system, version;\n\nversion = require(\"../pixie\").version;\n\nPostmaster = require(\"./postmaster\");\n\nRuntime = require(\"./runtime\");\n\nmodule.exports = system = {\n  app: {\n    Base: function() {\n      throw new Error(\"app.Base can't be called until after system.launch\");\n    }\n  },\n  acct: require(\"./acct/index\"),\n  aws: require(\"./aws/index\"),\n  fs: require(\"./fs/index\"),\n\n  /*\n  Launch the system client, attach `system` and `application` globals, send\n  ready message, invoke callback.\n  \n  Once we launch system becomes a global and is extended with\n   */\n  launch: function(opts, fn) {\n    if (typeof opts === 'function') {\n      fn = opts;\n      opts = {};\n    }\n    if (opts.debug) {\n      opts.logger = console;\n    }\n    Object.assign(global, Runtime(system, opts));\n    if ((typeof window !== \"undefined\" && window !== null) && Postmaster.dominant()) {\n      window.addEventListener('unload', function() {\n        return system.host.unload();\n      });\n    }\n    return system.host.ready().then(function(hostConfig) {\n      return Object.assign(system.config, {\n        host: hostConfig\n      });\n    })[\"finally\"](function() {\n      return fn(system.config);\n    });\n  },\n  pkg: require(\"./pkg/index\"),\n  ui: require(\"./ui/index\"),\n  util: require(\"./util/index\"),\n  version: version\n};\n"},"lib/extensions":{"content":"var deprecationWarning, promiseReader, readAsArrayBuffer, readAsDataURL, readAsJSON, readAsText, _base, _base1, _base2, _base3, _base4, _base5;\n\ndeprecationWarning = require(\"./util/index\").deprecationWarning;\n\npromiseReader = function(file, method) {\n  return new Promise(function(resolve, reject) {\n    var reader;\n    reader = new FileReader;\n    reader.onload = function() {\n      return resolve(reader.result);\n    };\n    reader.onerror = reject;\n    return reader[method](file);\n  });\n};\n\nreadAsText = function() {\n  return promiseReader(this, \"readAsText\");\n};\n\nreadAsArrayBuffer = function() {\n  return promiseReader(this, \"readAsArrayBuffer\");\n};\n\nreadAsDataURL = function() {\n  return promiseReader(this, \"readAsDataURL\");\n};\n\nreadAsJSON = function() {\n  return this.text().then(JSON.parse);\n};\n\nObject.assign(Blob.prototype, {\n  readAsText: deprecationWarning(\"blob.readAsText -> blob.text\", readAsText),\n  readAsArrayBuffer: deprecationWarning(\"blob.readAsArrayBuffer -> blob.arrayBuffer\", readAsArrayBuffer),\n  readAsDataURL: deprecationWarning(\"blob.readAsDataURL -> blob.dataURL\", readAsDataURL),\n  readAsJSON: deprecationWarning(\"blob.readAsJSON -> blob.json\", readAsJSON)\n});\n\nif ((_base = Blob.prototype).arrayBuffer == null) {\n  _base.arrayBuffer = readAsArrayBuffer;\n}\n\nif ((_base1 = Blob.prototype).dataURL == null) {\n  _base1.dataURL = readAsDataURL;\n}\n\nif ((_base2 = Blob.prototype).json == null) {\n  _base2.json = readAsJSON;\n}\n\nif ((_base3 = Blob.prototype).text == null) {\n  _base3.text = readAsText;\n}\n\nBlob.prototype.download = function(path) {\n  var a, url;\n  url = URL.createObjectURL(this);\n  a = document.createElement(\"a\");\n  a.href = url;\n  a.style.display = \"none\";\n  a.download = path;\n  document.body.appendChild(a);\n  a.click();\n  a.remove();\n  return URL.revokeObjectURL(url);\n};\n\nImage.fromBlob = function(blob) {\n  var url;\n  url = URL.createObjectURL(blob);\n  return new Promise(function(resolve, reject) {\n    var img;\n    img = new Image;\n    img.onload = function() {\n      URL.revokeObjectURL(url);\n      return resolve(img);\n    };\n    img.onerror = function(e) {\n      URL.revokeObjectURL(url);\n      return reject(e);\n    };\n    return img.src = url;\n  });\n};\n\nif (JSON.toBlob == null) {\n  JSON.toBlob = function(object, mime) {\n    if (mime == null) {\n      mime = \"application/json\";\n    }\n    return new Blob([JSON.stringify(object)], {\n      type: \"\" + mime + \"; charset=utf-8\"\n    });\n  };\n}\n\nif ((_base4 = HTMLCollection.prototype).forEach == null) {\n  _base4.forEach = Array.prototype.forEach;\n}\n\nif ((_base5 = FileList.prototype).forEach == null) {\n  _base5.forEach = Array.prototype.forEach;\n}\n"},"lib/fs/dexie":{"content":"var Bindable, DexieFSDB, FolderEntry;\n\nBindable = require(\"../bindable\");\n\nFolderEntry = function(path, prefix) {\n  return {\n    folder: true,\n    path: prefix + path,\n    relativePath: path\n  };\n};\n\nDexieFSDB = function(dbName) {\n  var db;\n  if (dbName == null) {\n    dbName = 'fs';\n  }\n  db = new Dexie(dbName);\n  db.version(1).stores({\n    files: 'path, blob, size, type, createdAt, updatedAt'\n  });\n  return db;\n};\n\nmodule.exports = function(dbName) {\n  var Files, db, notify, self;\n  if (dbName == null) {\n    dbName = 'fs';\n  }\n  db = DexieFSDB(dbName);\n  Files = db.files;\n  notify = function(eventType, path) {\n    return function(result) {\n      self.trigger(eventType, path);\n      return result;\n    };\n  };\n  self = {\n    read: function(path) {\n      return Files.get(path).then(function(result) {\n        return result != null ? result.blob : void 0;\n      }).then(notify(\"read\", path));\n    },\n    write: function(path, blob) {\n      var now;\n      if (!(blob instanceof Blob)) {\n        throw new Error(\"Can only write blobs to the file system\");\n      }\n      now = +(new Date);\n      return Files.put({\n        path: path,\n        blob: blob,\n        size: blob.size,\n        type: blob.type,\n        createdAt: now,\n        updatedAt: now\n      }).then(notify(\"write\", path));\n    },\n    \"delete\": function(path) {\n      return Files[\"delete\"](path).then(notify(\"delete\", path));\n    },\n    list: function(dir) {\n      return Files.where(\"path\").startsWith(dir).toArray().then(function(files) {\n        var folderPaths, folders;\n        folderPaths = {};\n        files = files.filter(function(file) {\n          var folderPath;\n          file.relativePath = file.path.replace(dir, \"\");\n          if (file.relativePath.match(/\\//)) {\n            folderPath = file.relativePath.replace(/\\/.*$/, \"/\");\n            folderPaths[folderPath] = true;\n          } else {\n            return file;\n          }\n        });\n        folders = Object.keys(folderPaths).map(function(folderPath) {\n          return FolderEntry(folderPath, dir);\n        });\n        return folders.concat(files);\n      });\n    }\n  };\n  return Bindable(void 0, self);\n};\n"},"lib/fs/index":{"content":"var DexieFS, MountFS, PkgFS, S3FS;\n\nMountFS = require(\"./mount\");\n\nDexieFS = require(\"./dexie\");\n\nPkgFS = require(\"./pkg\");\n\nS3FS = require(\"./s3\");\n\nmodule.exports = Object.assign({\n  Dexie: DexieFS,\n  Mount: MountFS,\n  Package: PkgFS,\n  S3: S3FS\n}, require(\"./util\"));\n"},"lib/fs/mount":{"content":"var Bindable, Ergonomics,\n  __slice = [].slice;\n\nBindable = require(\"../bindable\");\n\nErgonomics = require(\"./util\").Ergonomics;\n\nmodule.exports = function() {\n  var findMountPathsFor, longestToShortest, mountPaths, mounts, proxyToMount, self;\n  mounts = {};\n  mountPaths = [];\n  longestToShortest = function(a, b) {\n    return b.length - a.length;\n  };\n  findMountPathsFor = function(path) {\n    return mountPaths.filter(function(p) {\n      return path.startsWith(p);\n    });\n  };\n  proxyToMount = function(method) {\n    return function() {\n      var mount, mountPath, params, path, subsystemPath;\n      path = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      mountPaths = findMountPathsFor(path);\n      if (!mountPaths.length) {\n        throw new Error(\"No mounted filesystem for \" + path);\n      }\n      mountPath = mountPaths[0];\n      mount = mounts[mountPath].subsystem;\n      subsystemPath = path.replace(mountPath, \"/\");\n      if (method === \"list\") {\n        return mount[method].apply(mount, [subsystemPath].concat(__slice.call(params))).then(function(entries) {\n          return entries.map(function(entry) {\n            return Object.assign({}, entry, {\n              path: entry.path.replace(\"/\", mountPath)\n            });\n          });\n        });\n      } else if (method === \"read\") {\n        return mount[method].apply(mount, [subsystemPath].concat(__slice.call(params))).then(function(blob) {\n          if (blob) {\n            blob.path = path;\n            return blob;\n          }\n        });\n      } else {\n        return mount[method].apply(mount, [subsystemPath].concat(__slice.call(params)));\n      }\n    };\n  };\n  self = {\n    read: proxyToMount(\"read\"),\n    write: proxyToMount(\"write\"),\n    \"delete\": proxyToMount(\"delete\"),\n    list: proxyToMount(\"list\"),\n    clearCache: function() {\n      return Object.keys(mounts).forEach(function(key) {\n        var _base;\n        return typeof (_base = mounts[key].subsystem).clearCache === \"function\" ? _base.clearCache() : void 0;\n      });\n    },\n    mount: function(folderPath, subsystem) {\n      var h, handler, s, _ref;\n      handler = function(eventName, path) {\n        return self.trigger(eventName, path.replace(\"/\", folderPath));\n      };\n      if (mounts[folderPath]) {\n        _ref = mounts[folderPath], s = _ref.subsystem, h = _ref.handler;\n        s.off(\"*\", h);\n      }\n      subsystem.on(\"*\", handler);\n      mounts[folderPath] = {\n        subsystem: subsystem,\n        handler: handler\n      };\n      mountPaths.push(folderPath);\n      mountPaths.sort(longestToShortest);\n      return self;\n    }\n  };\n  Bindable(void 0, self);\n  Ergonomics(self);\n  return self;\n};\n"},"lib/fs/pkg":{"content":"var Bindable, FolderEntry, noop, sourcePath, withoutAllExtensions;\n\nBindable = require(\"../bindable\");\n\nmodule.exports = function(pkg, opts) {\n  var compile, compileAndWrite, notify, persist, self;\n  if (opts == null) {\n    opts = {};\n  }\n  notify = function(eventType, path) {\n    return function(result) {\n      self.trigger(eventType, path);\n      return result;\n    };\n  };\n  persist = opts.persist || noop;\n  compile = opts.compile || function() {\n    return Promise.resolve();\n  };\n  compileAndWrite = function(path, blob) {\n    var writeCompiled, writeSource;\n    writeSource = blob.text().then(function(text) {\n      var srcPath;\n      srcPath = sourcePath(path);\n      return pkg.source[srcPath] = {\n        content: text,\n        type: blob.type || \"\",\n        path: srcPath\n      };\n    });\n    blob.path = path;\n    writeCompiled = compile(blob).then(function(compiledSource) {\n      if (typeof compiledSource === \"string\") {\n        return pkg.distribution[withoutAllExtensions(sourcePath(path))] = {\n          content: compiledSource\n        };\n      } else {\n        return console.warn(\"Can't package files like \" + path + \" yet\", compiledSource);\n      }\n    });\n    return Promise.all([writeSource, writeCompiled]).then(persist);\n  };\n  self = {\n    read: function(path) {\n      var blob, content, entry, type;\n      entry = pkg.source[sourcePath(path)];\n      if (!entry) {\n        throw new Error(\"File not found at: \" + path);\n      }\n      content = entry.content, type = entry.type;\n      if (type == null) {\n        type = \"\";\n      }\n      blob = new Blob([content], {\n        type: type\n      });\n      return Promise.resolve(blob).then(notify(\"read\", path));\n    },\n    write: function(path, blob) {\n      return compileAndWrite(path, blob).then(notify(\"write\", path));\n    },\n    \"delete\": function(path) {\n      return Promise.resolve().then(function() {\n        return delete pkg.source[sourcePath(path)];\n      }).then(notify(\"delete\", path));\n    },\n    list: function(dir) {\n      var sourceDir;\n      sourceDir = sourcePath(dir);\n      return Promise.resolve().then(function() {\n        return Object.keys(pkg.source).filter(function(path) {\n          return path.indexOf(sourceDir) === 0;\n        }).map(function(path) {\n          return {\n            path: \"/\" + path,\n            relativePath: path.replace(sourceDir, \"\"),\n            type: pkg.source[path].type || \"\"\n          };\n        });\n      }).then(function(files) {\n        var folderPaths, folders;\n        folderPaths = {};\n        files = files.filter(function(file) {\n          var folderPath;\n          if (file.relativePath.match(/\\//)) {\n            folderPath = file.relativePath.replace(/\\/.*$/, \"/\");\n            folderPaths[folderPath] = true;\n          } else {\n            return file;\n          }\n        });\n        folders = Object.keys(folderPaths).map(function(folderPath) {\n          return FolderEntry(folderPath, dir);\n        });\n        return folders.concat(files);\n      }).then(notify(\"list\", dir));\n    }\n  };\n  return Bindable(void 0, self);\n};\n\nFolderEntry = function(path, prefix) {\n  return {\n    folder: true,\n    path: prefix + path,\n    relativePath: path\n  };\n};\n\nsourcePath = function(path) {\n  return path.replace(/^\\//, \"\");\n};\n\nwithoutAllExtensions = function(path) {\n  return path.replace(/\\.[^\\/]*$/, \"\");\n};\n\nnoop = function() {};\n"},"lib/fs/s3":{"content":"var Bindable, delimiter, deprecationWarning, pinvoke, promiseChoke, _ref,\n  __slice = [].slice;\n\nBindable = require(\"../bindable\");\n\n_ref = require(\"../util/index\"), deprecationWarning = _ref.deprecationWarning, promiseChoke = _ref.promiseChoke;\n\npinvoke = function() {\n  var method, object, params;\n  object = arguments[0], method = arguments[1], params = 3 <= arguments.length ? __slice.call(arguments, 2) : [];\n  return new Promise(function(resolve, reject) {\n    return object[method].apply(object, __slice.call(params).concat([function(err, result) {\n      if (err) {\n        reject(err);\n        return;\n      }\n      return resolve(result);\n    }]));\n  });\n};\n\ndelimiter = \"/\";\n\nmodule.exports = function(id, bucket, refreshCredentials) {\n  var FileEntry, FolderEntry, deleteFromS3, fetchFileMeta, fetchMeta, getRemote, list, localCache, metaCache, notify, refreshCredentialsPromise, self, uploadToS3;\n  if (refreshCredentials == null) {\n    refreshCredentials = function() {\n      return Promise.reject(new Error(\"No method given to refresh credentials automatically\"));\n    };\n  }\n  refreshCredentialsPromise = Promise.resolve();\n  (function(oldPromiseInvoke) {\n    return pinvoke = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return refreshCredentialsPromise.then(function() {\n        return oldPromiseInvoke.apply(null, args);\n      })[\"catch\"](function(e) {\n        if (e.code === \"CredentialsError\") {\n          console.info(\"Refreshing credentials after CredentialsError\", e);\n          refreshCredentialsPromise = refreshCredentials();\n          return refreshCredentialsPromise.then(function() {\n            return oldPromiseInvoke.apply(null, args);\n          });\n        } else {\n          throw e;\n        }\n      });\n    };\n  })(pinvoke);\n  localCache = {};\n  metaCache = {};\n  uploadToS3 = function(bucket, key, file, options) {\n    var cacheControl;\n    if (options == null) {\n      options = {};\n    }\n    cacheControl = options.cacheControl;\n    if (cacheControl == null) {\n      cacheControl = 0;\n    }\n    localCache[key] = file;\n    metaCache[key] = {\n      ContentType: file.type,\n      LastModified: new Date\n    };\n    return pinvoke(bucket, \"putObject\", {\n      Key: key,\n      ContentType: file.type,\n      Body: file,\n      CacheControl: \"max-age=\" + cacheControl\n    });\n  };\n  getRemote = function(bucket, key) {\n    var cachedItem;\n    cachedItem = localCache[key];\n    if (cachedItem) {\n      if (cachedItem instanceof Blob) {\n        return Promise.resolve(cachedItem);\n      } else {\n        return Promise.reject(cachedItem);\n      }\n    }\n    return pinvoke(bucket, \"getObject\", {\n      Key: key\n    }).then(function(data) {\n      var Body, ContentType;\n      Body = data.Body, ContentType = data.ContentType;\n      return new Blob([Body], {\n        type: ContentType\n      });\n    }).then(function(data) {\n      return localCache[key] = data;\n    })[\"catch\"](function(e) {\n      localCache[key] = e;\n      throw e;\n    });\n  };\n  deleteFromS3 = function(bucket, key) {\n    localCache[key] = new Error(\"Not Found\");\n    delete metaCache[key];\n    return pinvoke(bucket, \"deleteObject\", {\n      Key: key\n    });\n  };\n  list = promiseChoke(function(dir) {\n    var prefix;\n    prefix = \"\" + id + dir;\n    return pinvoke(bucket, \"listObjects\", {\n      Prefix: prefix,\n      Delimiter: delimiter\n    }).then(function(result) {\n      var results;\n      results = result.CommonPrefixes.map(function(p) {\n        return FolderEntry(p.Prefix, id, prefix);\n      }).concat(result.Contents.map(function(o) {\n        return FileEntry(o, id, prefix, bucket);\n      })).map(function(entry) {\n        return fetchMeta(entry, bucket);\n      });\n      return Promise.all(results);\n    });\n  });\n  fetchFileMeta = function(key, bucket) {\n    var cachedItem;\n    cachedItem = metaCache[key];\n    if (cachedItem) {\n      return Promise.resolve(cachedItem);\n    }\n    return pinvoke(bucket, \"headObject\", {\n      Key: key\n    }).then(function(result) {\n      metaCache[key] = result;\n      return result;\n    });\n  };\n  fetchMeta = function(entry, bucket) {\n    return Promise.resolve().then(function() {\n      if (entry.folder) {\n        return entry;\n      }\n      return fetchFileMeta(entry.remotePath, bucket).then(function(meta) {\n        entry.type = meta.ContentType;\n        entry.updatedAt = new Date(meta.LastModified);\n        return entry;\n      });\n    });\n  };\n  notify = function(eventType, path) {\n    return function(result) {\n      self.trigger(eventType, path);\n      return result;\n    };\n  };\n  FolderEntry = function(path, id, prefix) {\n    return {\n      folder: true,\n      path: path.replace(id, \"\"),\n      relativePath: path.replace(prefix, \"\"),\n      remotePath: path\n    };\n  };\n  FileEntry = function(object, id, prefix, bucket) {\n    var entry, path;\n    path = object.Key;\n    entry = {\n      path: path.replace(id, \"\"),\n      relativePath: path.replace(prefix, \"\"),\n      remotePath: path,\n      size: object.Size\n    };\n    return entry;\n  };\n  return self = Object.assign(Bindable(), {\n    clearCache: function() {\n      localCache = {};\n      return metaCache = {};\n    },\n    read: function(path) {\n      var key;\n      if (!path.startsWith(delimiter)) {\n        path = delimiter + path;\n      }\n      key = \"\" + id + path;\n      return getRemote(bucket, key).then(notify(\"read\", path));\n    },\n    write: function(path, blob, options) {\n      var key;\n      if (!path.startsWith(delimiter)) {\n        path = delimiter + path;\n      }\n      key = \"\" + id + path;\n      return uploadToS3(bucket, key, blob, options).then(notify(\"write\", path));\n    },\n    \"delete\": function(path) {\n      var key;\n      if (!path.startsWith(delimiter)) {\n        path = delimiter + path;\n      }\n      key = \"\" + id + path;\n      return deleteFromS3(bucket, key).then(notify(\"delete\", path));\n    },\n    list: function(dir) {\n      if (dir == null) {\n        dir = \"/\";\n      }\n      if (!dir.startsWith(delimiter)) {\n        dir = \"\" + delimiter + dir;\n      }\n      if (!dir.endsWith(delimiter)) {\n        dir = \"\" + dir + delimiter;\n      }\n      return list(dir).then(notify(\"list\", dir));\n    }\n  });\n};\n"},"lib/fs/util":{"content":"\n/*\nUtility methods for manipulating and normalizing file system paths.\n */\nvar absolutizePath, allDirectories, baseName, extensionFor, mimes, normalizePath, normalizePath2, separator, textMediaType,\n  __slice = [].slice;\n\nseparator = \"/\";\n\nnormalizePath = function(path) {\n  return path.replace(/\\/+/g, separator).replace(/\\/[^/]*\\/\\.\\.(\\/|$)/g, separator).replace(/\\/(\\.(\\/|$))*/g, separator);\n};\n\nnormalizePath2 = function(path) {\n  var stack;\n  stack = [];\n  path.split(separator).forEach(function(part) {\n    switch (part) {\n      case \".\":\n      case \"\":\n        break;\n      case \"..\":\n        if (stack.length) {\n          return stack.pop();\n        } else {\n          throw new Error(\"No upper directory when normalizing '\" + path + \"'\");\n        }\n        break;\n      default:\n        return stack.push(part);\n    }\n  });\n  if (path.startsWith('/')) {\n    stack.unshift('');\n  } else if (path.startsWith('./')) {\n    stack.unshift('.');\n  }\n  if (path.match(/\\/\\.{0,2}$/)) {\n    stack.push('');\n  }\n  return stack.join(separator);\n};\n\nabsolutizePath = function(base, relativePath, preventEscape) {\n  var path;\n  if (preventEscape == null) {\n    preventEscape = true;\n  }\n  if (!base.startsWith(separator)) {\n    throw new Error(\"base path must be absolute\");\n  }\n  if (!base.endsWith(separator)) {\n    throw new Error(\"base path must be a directory\");\n  }\n  path = normalizePath(\"\" + base + relativePath);\n  if (preventEscape) {\n    if (!path.startsWith(normalizePath(base))) {\n      throw new Error(\"path escaped base directory (too many ../)\");\n    }\n  }\n  return path;\n};\n\nallDirectories = /^.*\\//;\n\nbaseName = function(path) {\n  return path.replace(allDirectories, \"\");\n};\n\nextensionFor = function(path) {\n  var result;\n  result = baseName(path).match(/\\.([^.]+)$/);\n  if (result) {\n    return result[1];\n  } else {\n    return \"\";\n  }\n};\n\nmimes = {\n  css: \"text/css\",\n  html: \"text/html\",\n  js: \"text/javascript\",\n  json: \"application/json\",\n  md: \"text/markdown\"\n};\n\ntextMediaType = function(path) {\n  var extension, type;\n  extension = extensionFor(path);\n  type = mimes[extension] || \"text/plain\";\n  return \"\" + type + \"; charset=utf-8\";\n};\n\nmodule.exports = {\n  absolutizePath: absolutizePath,\n  baseDirectory: function(absolutePath) {\n    var _ref;\n    if (absolutePath == null) {\n      absolutePath = \"/\";\n    }\n    return (_ref = absolutePath.match(allDirectories)) != null ? _ref[0] : void 0;\n  },\n  baseName: baseName,\n  extensionFor: extensionFor,\n  fileSeparator: separator,\n  isRelativePath: function(path) {\n    return !!path.match(/^.?.\\//);\n  },\n  normalizePath: normalizePath,\n  normalizePath2: normalizePath2,\n  Ergonomics: function(fs) {\n    (function(write) {\n      return fs.write = function() {\n        var args, blob, path, stringOrBlob;\n        path = arguments[0], stringOrBlob = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];\n        if (typeof stringOrBlob === \"string\") {\n          blob = new Blob([stringOrBlob], {\n            type: textMediaType(path)\n          });\n        } else {\n          blob = stringOrBlob;\n        }\n        return write.call.apply(write, [fs, path, blob].concat(__slice.call(args)));\n      };\n    })(fs.write);\n    return fs;\n  },\n  separator: separator,\n  textMediaType: textMediaType,\n  withoutExtension: function(path) {\n    return path.replace(/\\.[^\\.\\/]*$/, \"\");\n  },\n  withoutAllExtensions: function(path) {\n    return path.replace(/\\.[^\\/]*$/, \"\");\n  }\n};\n"},"lib/indent-parse":{"content":"var parse, top;\n\ntop = function(stack) {\n  return stack[stack.length - 1];\n};\n\nparse = function(source) {\n  var depth, indentation, stack;\n  stack = [[]];\n  indentation = /^(  )*/;\n  depth = 0;\n  source.split(\"\\n\").forEach(function(line, lineNumber) {\n    var current, items, match, newDepth, prev, text;\n    match = line.match(indentation)[0];\n    text = line.replace(match, \"\");\n    newDepth = match.length / 2;\n    if (!text.trim().length) {\n      return;\n    }\n    current = text;\n    if (newDepth > depth) {\n      if (newDepth !== depth + 1) {\n        throw new Error(\"Unexpected indentation on line \" + lineNumber);\n      }\n      items = [];\n      prev = top(stack);\n      prev.push([prev.pop(), items]);\n      stack.push(items);\n    } else if (newDepth < depth) {\n      stack = stack.slice(0, newDepth + 1);\n    }\n    depth = newDepth;\n    return top(stack).push(current);\n  });\n  return stack[0];\n};\n\nmodule.exports = parse;\n"},"lib/jadelet-parser":{"content":"(function(create, rules) {\n  create(create, rules);\n}(function(create, rules) {\n  var RE_FLAGS, decompile, fail, failExpected, failHintRegex, failIndex, fns, generate, getValue, hToS, invoke, loc, mapValue, maxFailPos, noteName, parse, preComputedRules, precompileHandler, precompute, precomputeRule, prettyPrint, toS, tokenHandler, validate, _names;\n  failExpected = Array(16);\n  failIndex = 0;\n  failHintRegex = /\\S+|[^\\S]+|$/y;\n  maxFailPos = 0;\n  fail = function(pos, expected) {\n    if (pos < maxFailPos) {\n      return;\n    }\n    if (pos > maxFailPos) {\n      maxFailPos = pos;\n      failIndex = 0;\n    }\n    failExpected[failIndex++] = expected;\n  };\n  RE_FLAGS = \"uy\";\n  prettyPrint = function(v) {\n    var name, pv, s;\n    pv = v instanceof RegExp ? (s = v.toString(), s.slice(0, s.lastIndexOf('/') + 1)) : typeof v === \"string\" ? v === \"\" ? \"EOF\" : JSON.stringify(v) : v;\n    if (name = _names.get(v)) {\n      return \"\" + name + \" \" + pv;\n    } else {\n      return pv;\n    }\n  };\n  _names = new Map;\n  noteName = function(name, value) {\n    if (name) {\n      _names.set(value, name);\n    }\n    return value;\n  };\n  preComputedRules = null;\n  precomputeRule = function(rule, out, name, compile) {\n    var arg, data, handler, op, placeholder, result;\n    if (Array.isArray(rule)) {\n      op = rule[0], arg = rule[1], handler = rule[2];\n      result = [\n        fns[op], (function() {\n          switch (op) {\n            case \"/\":\n            case \"S\":\n              return arg.map(function(x) {\n                return precomputeRule(x, null, name, compile);\n              });\n            case \"*\":\n            case \"+\":\n            case \"?\":\n            case \"!\":\n            case \"&\":\n              return precomputeRule(arg, null, name + op, compile);\n            case \"R\":\n              return noteName(name, RegExp(arg, RE_FLAGS));\n            case \"L\":\n              return noteName(name, JSON.parse(\"\\\"\" + arg + \"\\\"\"));\n            default:\n              throw new Error(\"Don't know how to pre-compute \" + (JSON.stringify(op)));\n          }\n        })(), compile(handler, op, name)\n      ];\n      if (out) {\n        out[0] = result[0];\n        out[1] = result[1];\n        out[2] = result[2];\n        return out;\n      }\n      return result;\n    } else {\n      if (preComputedRules[rule]) {\n        return preComputedRules[rule];\n      } else {\n        preComputedRules[rule] = placeholder = out || [];\n        data = rules[rule];\n        if (data == null) {\n          throw new Error(\"No rule with name \" + (JSON.stringify(rule)));\n        }\n        return precomputeRule(data, placeholder, rule, compile);\n      }\n    }\n  };\n  getValue = function(x) {\n    return x.value;\n  };\n  precompileHandler = function(handler, op) {\n    var fn;\n    if (handler != null ? handler.f : void 0) {\n      fn = Function(\"$loc\", \"$0\", \"$1\", \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\", \"$9\", handler.f);\n      if (op === \"S\") {\n        return function(s) {\n          return fn.apply(null, [s.loc, s.value].concat(s.value));\n        };\n      } else if (op === \"R\") {\n        return function(s) {\n          return fn.apply(null, [s.loc].concat(s.value));\n        };\n      } else {\n        return function(s) {\n          return fn(s.loc, s.value, s.value);\n        };\n      }\n    } else {\n      if (op === \"R\") {\n        if (handler != null) {\n          return function(s) {\n            return mapValue(handler, s.value);\n          };\n        } else {\n          return function(s) {\n            return s.value[0];\n          };\n        }\n      } else if (op === \"S\") {\n        if (handler != null) {\n          return function(s) {\n            return mapValue(handler, [s.value].concat(s.value));\n          };\n        } else {\n          return function(s) {\n            return s.value;\n          };\n        }\n      } else {\n        return function(s) {\n          return mapValue(handler, s.value);\n        };\n      }\n    }\n  };\n  precompute = function(rules, compile) {\n    var first;\n    preComputedRules = {};\n    first = Object.keys(rules)[0];\n    preComputedRules[first] = precomputeRule(first, null, first, compile);\n    return preComputedRules;\n  };\n  invoke = function(state, data) {\n    var arg, fn, mapping, result;\n    fn = data[0], arg = data[1], mapping = data[2];\n    result = fn(state, arg);\n    if (mapping == null) {\n      mapping = getValue;\n    }\n    if (result) {\n      result.value = mapping(result);\n    }\n    return result;\n  };\n  mapValue = function(mapping, value) {\n    switch (typeof mapping) {\n      case \"number\":\n        return value[mapping];\n      case \"string\":\n        return mapping;\n      case \"object\":\n        if (Array.isArray(mapping)) {\n          return mapping.map(function(n) {\n            return mapValue(n, value);\n          });\n        } else {\n          throw new Error(\"non-array object mapping\");\n        }\n        break;\n      case \"undefined\":\n        return value;\n      default:\n        throw new Error(\"Unknown mapping type\");\n    }\n  };\n  fns = {\n    L: function(state, str) {\n      var input, length, pos;\n      input = state.input, pos = state.pos;\n      length = str.length;\n      if (input.substr(pos, length) === str) {\n        return {\n          loc: {\n            pos: pos,\n            length: length\n          },\n          pos: pos + length,\n          value: str\n        };\n      } else {\n        return fail(pos, str);\n      }\n    },\n    R: function(state, regExp) {\n      var input, l, m, pos, v;\n      input = state.input, pos = state.pos;\n      regExp.lastIndex = state.pos;\n      if (m = input.match(regExp)) {\n        v = m[0];\n      }\n      if (v != null) {\n        l = v.length;\n        return {\n          loc: {\n            pos: pos,\n            length: l\n          },\n          pos: pos + l,\n          value: m\n        };\n      } else {\n        return fail(pos, regExp);\n      }\n    },\n    S: function(state, terms) {\n      var i, input, l, pos, r, results, s, value;\n      input = state.input, pos = state.pos;\n      results = [];\n      s = pos;\n      i = 0;\n      l = terms.length;\n      while (true) {\n        r = invoke({\n          input: input,\n          pos: pos\n        }, terms[i++]);\n        if (r) {\n          pos = r.pos, value = r.value;\n          results.push(value);\n        } else {\n          return;\n        }\n        if (i >= l) {\n          break;\n        }\n      }\n      return {\n        loc: {\n          pos: s,\n          length: pos - s\n        },\n        pos: pos,\n        value: results\n      };\n    },\n    \"/\": function(state, terms) {\n      var i, l, r;\n      i = 0;\n      l = terms.length;\n      while (true) {\n        r = invoke(state, terms[i++]);\n        if (r) {\n          return r;\n        }\n        if (i >= l) {\n          break;\n        }\n      }\n    },\n    \"?\": function(state, term) {\n      return invoke(state, term) || state;\n    },\n    \"*\": function(state, term) {\n      var input, pos, prevPos, r, results, s, value;\n      input = state.input, pos = state.pos;\n      s = pos;\n      results = [];\n      while (true) {\n        prevPos = pos;\n        r = invoke({\n          input: input,\n          pos: pos\n        }, term);\n        if (r == null) {\n          break;\n        }\n        pos = r.pos, value = r.value;\n        if (pos === prevPos) {\n          break;\n        } else {\n          results.push(value);\n        }\n      }\n      return {\n        loc: {\n          pos: s,\n          length: pos - s\n        },\n        pos: pos,\n        value: results\n      };\n    },\n    \"+\": function(state, term) {\n      var first, input, pos, rest, s;\n      input = state.input, s = state.pos;\n      first = invoke(state, term);\n      if (first == null) {\n        return;\n      }\n      pos = first.pos;\n      pos = (rest = invoke({\n        input: input,\n        pos: pos\n      }, [fns[\"*\"], term])).pos;\n      rest.value.unshift(first.value);\n      return {\n        loc: {\n          pos: s,\n          length: pos - s\n        },\n        value: rest.value,\n        pos: pos\n      };\n    },\n    \"!\": function(state, term) {\n      var newState;\n      newState = invoke(state, term);\n      if (newState != null) {\n\n      } else {\n        return state;\n      }\n    },\n    \"&\": function(state, term) {\n      var newState;\n      newState = invoke(state, term);\n      if (newState.pos === state.pos) {\n\n      } else {\n        return state;\n      }\n    }\n  };\n  loc = function(input, pos) {\n    var column, line, rawPos, _ref;\n    rawPos = pos;\n    _ref = input.split(/\\n|\\r\\n|\\r/).reduce(function(_arg, line) {\n      var col, l, row;\n      row = _arg[0], col = _arg[1];\n      l = line.length + 1;\n      if (pos > l) {\n        pos -= l;\n        return [row + 1, 1];\n      } else if (pos >= 0) {\n        col += pos;\n        pos = -1;\n        return [row, col];\n      } else {\n        return [row, col];\n      }\n    }, [1, 1]), line = _ref[0], column = _ref[1];\n    return \"\" + line + \":\" + column;\n  };\n  validate = function(input, result, _arg) {\n    var expectations, filename, hint, l;\n    filename = _arg.filename;\n    if ((result != null) && result.pos === input.length) {\n      return result.value;\n    }\n    expectations = Array.from(new Set(failExpected.slice(0, failIndex)));\n    l = loc(input, maxFailPos);\n    if ((result != null) && result.pos > maxFailPos) {\n      l = loc(input, result.pos);\n      throw new Error(\"Unconsumed input at \" + l + \"\\n\\n\" + (input.slice(result.pos)) + \"\\n\");\n    } else if (expectations.length) {\n      failHintRegex.lastIndex = maxFailPos;\n      hint = input.match(failHintRegex)[0];\n      if (hint.length) {\n        hint = prettyPrint(hint);\n      } else {\n        hint = \"EOF\";\n      }\n      throw new Error(\"\" + filename + \":\" + l + \" Failed to parse\\nExpected:\\n\\t\" + (expectations.map(prettyPrint).join(\"\\n\\t\")) + \"\\nFound: \" + hint);\n    } else {\n      throw new Error(\"Unconsumed input at \" + l + \"\\n\\n\" + (input.slice(result.pos)) + \"\\n\");\n    }\n  };\n  parse = function(input, opts) {\n    var result, state;\n    if (opts == null) {\n      opts = {};\n    }\n    if (typeof input !== \"string\") {\n      throw new Error(\"Input must be a string\");\n    }\n    if (opts.filename == null) {\n      opts.filename = \"[stdin]\";\n    }\n    failIndex = 0;\n    maxFailPos = 0;\n    state = {\n      input: input,\n      pos: 0\n    };\n    if (opts.tokenize) {\n      precompute(rules, tokenHandler);\n    }\n    result = invoke(state, Object.values(preComputedRules)[0]);\n    return validate(input, result, opts);\n  };\n  tokenHandler = function(handler, op, name) {\n    return function(_arg) {\n      var value;\n      value = _arg.value;\n      if (value == null) {\n        return value;\n      }\n      switch (op) {\n        case \"S\":\n          return {\n            type: name,\n            value: value.filter(function(v) {\n              return v != null;\n            }).reduce(function(a, b) {\n              return a.concat(b);\n            }, [])\n          };\n        case \"L\":\n        case \"R\":\n          return {\n            type: name,\n            value: value\n          };\n        case \"*\":\n        case \"+\":\n          return {\n            type: op,\n            value: value\n          };\n        case \"?\":\n        case \"/\":\n          return value;\n        case \"!\":\n        case \"&\":\n          return {\n            type: op + name,\n            value: value\n          };\n      }\n    };\n  };\n  generate = function(rules, vivify) {\n    var m, src;\n    src = \"(function(create, rules) {\\n  create(create, rules);\\n}(\" + (create.toString()) + \", \" + (JSON.stringify(rules)) + \"));\\n\";\n    if (vivify) {\n      m = {};\n      Function(\"module\", src)(m);\n      return m.exports;\n    } else {\n      return src;\n    }\n  };\n  hToS = function(h) {\n    if (h == null) {\n      return \"\";\n    }\n    return \" -> \" + (function() {\n      switch (typeof h) {\n        case \"number\":\n          return h;\n        case \"string\":\n          return JSON.stringify(h);\n        case \"object\":\n          if (Array.isArray(h)) {\n            return JSON.stringify(h);\n          } else {\n            return \"\\n\" + (h.f.replace(/^|\\n/g, \"$&    \"));\n          }\n      }\n    })();\n  };\n  toS = function(rule, depth) {\n    var f, h, terms;\n    if (depth == null) {\n      depth = 0;\n    }\n    if (Array.isArray(rule)) {\n      f = rule[0];\n      h = rule[2];\n      switch (f) {\n        case \"*\":\n        case \"+\":\n        case \"?\":\n          return toS(rule[1], depth + 1) + f + hToS(h);\n        case \"&\":\n        case \"!\":\n          return f + toS(rule[1], depth + 1);\n        case \"L\":\n          return '\"' + rule[1] + '\"' + hToS(h);\n        case \"R\":\n          return '/' + rule[1] + '/' + hToS(h);\n        case \"S\":\n          terms = rule[1].map(function(i) {\n            return toS(i, depth + 1);\n          });\n          if (depth < 1) {\n            return terms.join(\" \") + hToS(h);\n          } else {\n            return \"( \" + terms.join(\" \") + \" )\";\n          }\n          break;\n        case \"/\":\n          terms = rule[1].map(function(i) {\n            return toS(i, depth && depth + 1);\n          });\n          if (depth === 0 && !h) {\n            return terms.join(\"\\n  \");\n          } else {\n            return \"( \" + terms.join(\" / \") + \" )\" + hToS(h);\n          }\n      }\n    } else {\n      return rule;\n    }\n  };\n  decompile = function(rules) {\n    return Object.keys(rules).map(function(name) {\n      var value;\n      value = toS(rules[name]);\n      return \"\" + name + \"\\n  \" + value + \"\\n\";\n    }).join(\"\\n\");\n  };\n  precompute(rules, precompileHandler);\n  return module.exports = {\n    decompile: decompile,\n    parse: parse,\n    generate: generate,\n    rules: rules\n  };\n}, {\"Template\":[\"S\",[[\"?\",\"__\"],[\"*\",\"Line\"]],{\"f\":\"var top = a => a[a.length-1];\\nfunction reduceLines(lines) {\\n  var depth = 0;\\n  var stack = [[]];\\n  var firstIndent = 0;\\n  lines.forEach( ([indent, line]) => {\\n    if (firstIndent === 0 && indent > depth + 1) {\\n      firstIndent = indent - 1;\\n    }\\n    indent = indent > firstIndent ? indent - firstIndent : indent;\\n    if (Array.isArray(line)) {\\n      line[1] = collectAttributes(line[1])\\n    }\\n    if (depth+1 === indent) {\\n      // We're adding to the content of the last element in the current stack\\n      stack.push(top(top(stack))[2])\\n    } else if ( indent > depth) {\\n      throw new Error(\\\"Indented too far\\\")\\n    } else if (indent < depth) {\\n      stack = stack.slice(0, indent + 1)\\n    }\\n    depth = indent\\n    top(stack).push(line)\\n  })\\n  return stack[0]\\n}\\nfunction collectAttributes(attributesArray) {\\n  return attributesArray.reduce((o, [key, value]) => {\\n    if (key === \\\"id\\\" || key === \\\"class\\\" || key === \\\"style\\\") {\\n      var p = o[key] || (o[key] = [])\\n      p.push(value)\\n    } else {\\n      o[key] = value\\n    }\\n    return o\\n  }, {})\\n}\\nfunction pretty(lines) {\\n  return lines.map(line =>\\n    JSON.stringify(line)\\n  )\\n}\\nvar reduced = reduceLines($2);\\nif (reduced.length != 1) {\\n  throw new Error(\\\"Must have exactly one root node.\\\");\\n}\\nreturn reduced[0];\"}],\"Line\":[\"S\",[\"Indent\",\"LineBody\",\"EOS\"],[1,2]],\"LineBody\":[\"/\",[[\"S\",[\"Tag\",[\"?\",\"DeprecatedEquals\"],\"_\",\"RestOfLine\"],{\"f\":\"$1[2].push($4)\\nreturn $1\"}],[\"S\",[\"Tag\",[\"?\",\"_\"]],1],[\"S\",[[\"L\",\"|\"],[\"?\",[\"L\",\" \"]],\"RestOfLine\"],{\"f\":\"return $3 + \\\"\\\\n\\\";\"}],[\"S\",[[\"?\",[\"S\",[\"DeprecatedEquals\",\"_\"]]],\"RestOfLine\"],2]]],\"RestOfLine\":[\"R\",\"[^\\\\n\\\\r]*\",{\"f\":\"// TODO: Handle runs of text with bound content inside\\nif ($0.slice(0,1) === \\\"@\\\") {\\n  return {\\n    bind: $0.slice(1)\\n  }\\n} else {\\n  return $0\\n}\"}],\"DeprecatedEquals\":[\"L\",\"=\",{\"f\":\"console.warn(\\\"'= <content>' is deprecated, you can remove the '=' without issue.\\\")\"}],\"Tag\":[\"/\",[[\"S\",[\"TagName\",\"OptionalIds\",\"OptionalClasses\",\"OptionalAttributes\"],{\"f\":\"return [\\n  $1,\\n  $2.concat($3, $4),\\n  [],\\n]\"}],[\"S\",[\"Ids\",\"OptionalClasses\",\"OptionalAttributes\"],{\"f\":\"return [\\n  \\\"div\\\",\\n  $1.concat($2, $3),\\n  [],\\n]\"}],[\"S\",[\"Classes\",\"OptionalAttributes\"],{\"f\":\"return [\\n  \\\"div\\\",\\n  $1.concat($2),\\n  [],\\n]\"}]]],\"OptionalClasses\":[\"/\",[\"Classes\",[\"L\",\"\",{\"f\":\"return []\"}]]],\"Classes\":[\"+\",\"Class\"],\"Class\":[\"/\",[[\"S\",[[\"L\",\".\"],\"Identifier\"],{\"f\":\"return [\\\"class\\\", $2]\"}],[\"S\",[[\"L\",\".\"],[\"!\",\"Identifier\"]],{\"f\":\"throw \\\"Expected a class name\\\"\"}],\"IdError\"]],\"OptionalIds\":[\"?\",\"Ids\",{\"f\":\"return $1 || []\"}],\"Ids\":[\"S\",[\"Id\"],{\"f\":\"return [ $1 ]\"}],\"Id\":[\"/\",[[\"S\",[[\"L\",\"#\"],\"Identifier\"],{\"f\":\"return [\\\"id\\\", $2]\"}],[\"S\",[[\"L\",\"#\"],[\"!\",\"Identifier\"]],{\"f\":\"throw \\\"Expected an id name\\\"\"}]]],\"IdError\":[\"L\",\"#\",{\"f\":\"throw \\\"Ids must appear before classes and attributes. Elements can only have one id.\\\"\"}],\"ClassError\":[\"L\",\".\",{\"f\":\"throw \\\"Classes cannot appear after attributes.\\\"\"}],\"TagName\":\"Identifier\",\"OptionalAttributes\":[\"/\",[[\"S\",[[\"L\",\"(\"],[\"?\",\"__\"],[\"+\",\"Attribute\"],[\"L\",\")\"],[\"?\",\"IdError\"],[\"?\",\"ClassError\"]],{\"f\":\"return $3\"}],[\"L\",\"(\",{\"f\":\"throw \\\"Invalid attributes\\\"\"}],[\"L\",\"\",{\"f\":\"return []\"}]]],\"Attribute\":[\"/\",[[\"S\",[\"AtIdentifier\",[\"?\",\"__\"]],{\"f\":\"return [$1.bind, $1]\"}],[\"S\",[\"EqBinding\",[\"?\",\"__\"]],1],[\"S\",[\"Identifier\",[\"?\",\"__\"]],{\"f\":\"return [$1, \\\"\\\"]\"}]]],\"AtIdentifier\":[\"S\",[[\"L\",\"@\"],\"Identifier\"],{\"f\":\"return {\\n  bind: $2\\n}\"}],\"EqBinding\":[\"S\",[\"Identifier\",[\"L\",\"=\"],[\"/\",[\"AtIdentifier\",\"Value\"]]],[1,3]],\"Identifier\":[\"R\",\"[a-zA-Z][a-zA-Z0-9-]*\"],\"Indent\":[\"*\",[\"/\",[[\"L\",\"  \"],[\"L\",\"\\\\t\"]]],{\"f\":\"return $1.length\"}],\"_\":[\"R\",\"[ \\\\t]+\"],\"__\":[\"+\",[\"/\",[[\"R\",\"[ \\\\t]\"],\"EOL\"]]],\"Value\":[\"/\",[[\"S\",[[\"L\",\"\\\\\\\"\"],[\"*\",\"DoubleStringCharacter\"],[\"L\",\"\\\\\\\"\"]],{\"f\":\"return $2.join(\\\"\\\")\"}],[\"S\",[[\"L\",\"'\"],[\"*\",\"SingleStringCharacter\"],[\"L\",\"'\"]],{\"f\":\"return $2.join(\\\"\\\")\"}],\"Number\"]],\"DoubleStringCharacter\":[\"/\",[[\"S\",[[\"!\",[\"/\",[[\"L\",\"\\\\\\\"\"],[\"L\",\"\\\\\\\\\"]]]],[\"R\",\".\"]],2],[\"S\",[[\"L\",\"\\\\\\\\\"],\"EscapeSequence\"],2]]],\"SingleStringCharacter\":[\"/\",[[\"S\",[[\"!\",[\"/\",[[\"L\",\"'\"],[\"L\",\"\\\\\\\\\"]]]],[\"R\",\".\"]],2],[\"S\",[[\"L\",\"\\\\\\\\\"],\"EscapeSequence\"],2]]],\"EscapeSequence\":[\"/\",[[\"L\",\"'\"],[\"L\",\"\\\\\\\"\"],[\"L\",\"\\\\\\\\\"],[\"R\",\".\",{\"f\":\"return \\\"\\\\\\\\\\\" + $0\"}]]],\"Number\":[\"/\",[[\"R\",\"-?[0-9]+\\\\.[0-9]+\"],[\"R\",\"-?[0-9]+\"]]],\"EOS\":[\"/\",[[\"S\",[[\"+\",[\"S\",[[\"?\",\"_\"],\"EOL\"]]],\"_\",\"EOF\"]],[\"+\",[\"S\",[[\"?\",\"_\"],\"EOL\"]]],\"EOF\"]],\"EOL\":[\"/\",[[\"L\",\"\\\\r\\\\n\"],[\"L\",\"\\\\n\"],[\"L\",\"\\\\r\"]]],\"EOF\":[\"!\",[\"R\",\"[\\\\s\\\\S]\"]]}));\n"},"lib/jadelet":{"content":"var Jadelet, Observable, append, attachCleaner, bindEvent, bindObservable, bindSplat, bindValue, dispose, elementCleaners, elementRefCounts, eventNames, forEach, get, isEvent, isObject, isString, observeAttribute, observeContent, parser, release, remove, render, retain, splat;\n\nObservable = require(\"./observable\");\n\nforEach = Array.prototype.forEach;\n\nelementCleaners = new WeakMap;\n\nelementRefCounts = new WeakMap;\n\nretain = function(element) {\n  var count;\n  count = elementRefCounts.get(element) || 0;\n  elementRefCounts.set(element, count + 1);\n};\n\nrelease = function(element) {\n  var count;\n  count = elementRefCounts.get(element) || 0;\n  count--;\n  if (count > 0) {\n    elementRefCounts.set(element, count);\n  } else {\n    elementRefCounts[\"delete\"](element);\n    dispose(element);\n  }\n};\n\ndispose = function(element) {\n  var children, _ref;\n  children = element.children;\n  if (children != null) {\n    forEach.call(children, dispose);\n  }\n  if ((_ref = elementCleaners.get(element)) != null) {\n    _ref.forEach(function(cleaner) {\n      cleaner();\n      elementCleaners[\"delete\"](element);\n    });\n  }\n};\n\nattachCleaner = function(element, cleaner) {\n  var cleaners;\n  if (typeof cleaner !== 'function') {\n    throw new Error(\"whoops\");\n  }\n  cleaners = elementCleaners.get(element);\n  if (cleaners) {\n    cleaners.push(cleaner);\n  } else {\n    elementCleaners.set(element, [cleaner]);\n  }\n};\n\neventNames = /^on(touch|animation|transition)(start|iteration|move|end|cancel)$/;\n\nisEvent = function(name, element) {\n  return name.match(eventNames) || name in element;\n};\n\nobserveAttribute = function(element, context, name, value) {\n  var bind;\n  switch (name) {\n    case \"id\":\n      bindSplat(element, context, value, function(ids) {\n        var length;\n        length = ids.length;\n        if (length) {\n          element.id = ids[length - 1];\n        } else {\n          element.removeAttribute(\"id\");\n        }\n      });\n      break;\n    case \"class\":\n      bindSplat(element, context, value, function(classes) {\n        var className;\n        className = classes.join(\" \");\n        if (className) {\n          element.className = className;\n        } else {\n          element.removeAttribute(\"class\");\n        }\n      });\n      break;\n    case \"style\":\n      bindSplat(element, context, value, function(styles) {\n        element.removeAttribute(\"style\");\n        styles.forEach(function(style) {\n          if (isObject(style)) {\n            return Object.assign(element.style, style);\n          } else {\n            return element.setAttribute(\"style\", style);\n          }\n        });\n      });\n      break;\n    case \"value\":\n      bindValue(element, value, context);\n      break;\n    case \"checked\":\n      if (value && isObject(value)) {\n        bind = value.bind;\n        element.onchange = function() {\n          if (typeof context[bind] === \"function\") {\n            context[bind](element.checked);\n          }\n        };\n      }\n      bindObservable(element, value, context, function(newValue) {\n        element.checked = newValue;\n      });\n      break;\n    default:\n      if (isEvent(\"on\" + name, element)) {\n        bindEvent(element, name, value.bind, context);\n      } else {\n        bindObservable(element, value, context, function(newValue) {\n          if ((newValue != null) && newValue !== false) {\n            element.setAttribute(name, newValue);\n          } else {\n            element.removeAttribute(name);\n          }\n        });\n      }\n  }\n};\n\nbindObservable = function(element, value, context, update) {\n  var bind, observable;\n  if (isString(value)) {\n    return update(value);\n  } else if (typeof value === 'function') {\n    observable = Observable(function() {\n      update(value.call(context));\n    });\n  } else {\n    bind = value.bind;\n    observable = Observable(function() {\n      update(get(context[bind], context));\n    });\n  }\n  if (observable._observableDependencies.size === 0) {\n    return;\n  }\n  attachCleaner(element, observable.releaseDependencies);\n};\n\nbindValue = function(element, value, context) {\n  var bind;\n  if (value && typeof value === \"object\") {\n    bind = value.bind;\n    element.oninput = element.onchange = function() {\n      if (typeof context[bind] === \"function\") {\n        context[bind](element.value);\n      }\n    };\n  }\n  bindObservable(element, value, context, function(newValue) {\n    if (element.value !== newValue) {\n      element.value = newValue;\n    }\n  });\n};\n\nbindEvent = function(element, name, binding, context) {\n  var handler;\n  handler = context[binding];\n  if (typeof handler === 'function') {\n    element.addEventListener(name, handler.bind(context));\n  }\n};\n\nbindSplat = function(element, context, sources, update) {\n  bindObservable(element, (function() {\n    return splat(sources, context);\n  }), context, update);\n};\n\nobserveContent = function(element, context, contentArray, namespace) {\n  var count, tracker;\n  tracker = [];\n  count = 0;\n  contentArray.forEach(function(astNode, index) {\n    var length, previousLength;\n    tracker[index] = count;\n    if (Array.isArray(astNode)) {\n      element.appendChild(render(astNode, context, namespace));\n      count++;\n    } else if (isString(astNode)) {\n      element.appendChild(document.createTextNode(astNode));\n      count++;\n    } else if (isObject(astNode)) {\n      length = previousLength = 0;\n      bindObservable(element, astNode, context, function(value) {\n        var beforeTarget, child, delta, i, pos, toRelease;\n        previousLength = length;\n        pos = tracker[index];\n        beforeTarget = element.childNodes[pos + length];\n        toRelease = new Array(length);\n        i = 0;\n        while (i < length) {\n          child = element.childNodes[pos];\n          element.removeChild(child);\n          toRelease[i] = child;\n          i++;\n        }\n        length = append(element, value, beforeTarget);\n        i = 0;\n        while (i < previousLength) {\n          child = toRelease[i];\n          release(child);\n          i++;\n        }\n        delta = length - previousLength;\n        i = index + 1;\n        while (i < tracker.length) {\n          tracker[i] += delta;\n          i++;\n        }\n      });\n      count += length;\n    } else {\n      throw new Error(\"oof\");\n    }\n  });\n};\n\nappend = function(element, item, beforeTarget) {\n  var el;\n  if (item == null) {\n    return 0;\n  } else if (Array.isArray(item)) {\n    return item.map(function(item) {\n      return append(element, item, beforeTarget);\n    }).reduce(function(a, b) {\n      return a + b;\n    }, 0);\n  } else if (item instanceof Node) {\n    retain(item);\n    element.insertBefore(item, beforeTarget);\n  } else if ((el = item.element) instanceof Node) {\n    retain(el);\n    element.insertBefore(el, beforeTarget);\n  } else {\n    element.insertBefore(document.createTextNode(item), beforeTarget);\n  }\n  return 1;\n};\n\nremove = function(element, child) {\n  element.removeChild(child);\n  return release(child);\n};\n\nisObject = function(x) {\n  return typeof x === \"object\";\n};\n\nisString = function(x) {\n  return typeof x === \"string\";\n};\n\nsplat = function(sources, context) {\n  return sources.map(function(source) {\n    if (isString(source)) {\n      return source;\n    } else {\n      return get(context[source.bind], context);\n    }\n  }).reduce(function(a, b) {\n    return a.concat(b);\n  }, []).filter(function(x) {\n    return x != null;\n  });\n};\n\nget = function(x, context) {\n  if (typeof x === 'function') {\n    return x.call(context);\n  } else {\n    return x;\n  }\n};\n\nrender = function(astNode, context, namespace) {\n  var attributes, children, element, tag;\n  if (context == null) {\n    context = {};\n  }\n  tag = astNode[0], attributes = astNode[1], children = astNode[2];\n  if (tag === \"svg\" && !namespace) {\n    namespace = \"http://www.w3.org/2000/svg\";\n  }\n  if (namespace) {\n    element = document.createElementNS(namespace, tag);\n  } else {\n    element = document.createElement(tag);\n  }\n  observeContent(element, context, children, namespace);\n  Object.keys(attributes).forEach(function(name) {\n    observeAttribute(element, context, name, attributes[name]);\n  });\n  return element;\n};\n\nparser = require(\"./jadelet-parser\");\n\nmodule.exports = Jadelet = {\n  compile: function(source, opts) {\n    var ast, exports, runtime;\n    if (opts == null) {\n      opts = {};\n    }\n    ast = Jadelet.parse(source);\n    runtime = opts.runtime || \"system.ui.Jadelet\";\n    exports = opts.exports || \"module.exports\";\n    return \"\" + exports + \" = \" + runtime + \".exec(\" + (JSON.stringify(ast)) + \");\";\n  },\n  parse: parser.parse,\n  parser: parser,\n  exec: function(ast) {\n    if (typeof ast === \"function\") {\n      return ast;\n    }\n    if (typeof ast === \"string\") {\n      ast = Jadelet.parse(ast);\n    }\n    return function(context) {\n      return render(ast, context);\n    };\n  },\n  Observable: Observable,\n  _elementCleaners: elementCleaners,\n  dispose: dispose,\n  retain: retain,\n  release: release\n};\n"},"lib/mousetrap":{"content":"/* mousetrap v1.6.3 craig.is/killing/mice */\r\n(function(q,u,c){function v(a,b,g){a.addEventListener?a.addEventListener(b,g,!1):a.attachEvent(\"on\"+b,g)}function z(a){if(\"keypress\"==a.type){var b=String.fromCharCode(a.which);a.shiftKey||(b=b.toLowerCase());return b}return n[a.which]?n[a.which]:r[a.which]?r[a.which]:String.fromCharCode(a.which).toLowerCase()}function F(a){var b=[];a.shiftKey&&b.push(\"shift\");a.altKey&&b.push(\"alt\");a.ctrlKey&&b.push(\"ctrl\");a.metaKey&&b.push(\"meta\");return b}function w(a){return\"shift\"==a||\"ctrl\"==a||\"alt\"==a||\r\n\"meta\"==a}function A(a,b){var g,d=[];var e=a;\"+\"===e?e=[\"+\"]:(e=e.replace(/\\+{2}/g,\"+plus\"),e=e.split(\"+\"));for(g=0;g<e.length;++g){var m=e[g];B[m]&&(m=B[m]);b&&\"keypress\"!=b&&C[m]&&(m=C[m],d.push(\"shift\"));w(m)&&d.push(m)}e=m;g=b;if(!g){if(!p){p={};for(var c in n)95<c&&112>c||n.hasOwnProperty(c)&&(p[n[c]]=c)}g=p[e]?\"keydown\":\"keypress\"}\"keypress\"==g&&d.length&&(g=\"keydown\");return{key:m,modifiers:d,action:g}}function D(a,b){return null===a||a===u?!1:a===b?!0:D(a.parentNode,b)}function d(a){function b(a){a=\r\na||{};var b=!1,l;for(l in p)a[l]?b=!0:p[l]=0;b||(x=!1)}function g(a,b,t,f,g,d){var l,E=[],h=t.type;if(!k._callbacks[a])return[];\"keyup\"==h&&w(a)&&(b=[a]);for(l=0;l<k._callbacks[a].length;++l){var c=k._callbacks[a][l];if((f||!c.seq||p[c.seq]==c.level)&&h==c.action){var e;(e=\"keypress\"==h&&!t.metaKey&&!t.ctrlKey)||(e=c.modifiers,e=b.sort().join(\",\")===e.sort().join(\",\"));e&&(e=f&&c.seq==f&&c.level==d,(!f&&c.combo==g||e)&&k._callbacks[a].splice(l,1),E.push(c))}}return E}function c(a,b,c,f){k.stopCallback(b,\r\nb.target||b.srcElement,c,f)||!1!==a(b,c)||(b.preventDefault?b.preventDefault():b.returnValue=!1,b.stopPropagation?b.stopPropagation():b.cancelBubble=!0)}function e(a){\"number\"!==typeof a.which&&(a.which=a.keyCode);var b=z(a);b&&(\"keyup\"==a.type&&y===b?y=!1:k.handleKey(b,F(a),a))}function m(a,g,t,f){function h(c){return function(){x=c;++p[a];clearTimeout(q);q=setTimeout(b,1E3)}}function l(g){c(t,g,a);\"keyup\"!==f&&(y=z(g));setTimeout(b,10)}for(var d=p[a]=0;d<g.length;++d){var e=d+1===g.length?l:h(f||\r\nA(g[d+1]).action);n(g[d],e,f,a,d)}}function n(a,b,c,f,d){k._directMap[a+\":\"+c]=b;a=a.replace(/\\s+/g,\" \");var e=a.split(\" \");1<e.length?m(a,e,b,c):(c=A(a,c),k._callbacks[c.key]=k._callbacks[c.key]||[],g(c.key,c.modifiers,{type:c.action},f,a,d),k._callbacks[c.key][f?\"unshift\":\"push\"]({callback:b,modifiers:c.modifiers,action:c.action,seq:f,level:d,combo:a}))}var k=this;a=a||u;if(!(k instanceof d))return new d(a);k.target=a;k._callbacks={};k._directMap={};var p={},q,y=!1,r=!1,x=!1;k._handleKey=function(a,\r\nd,e){var f=g(a,d,e),h;d={};var k=0,l=!1;for(h=0;h<f.length;++h)f[h].seq&&(k=Math.max(k,f[h].level));for(h=0;h<f.length;++h)f[h].seq?f[h].level==k&&(l=!0,d[f[h].seq]=1,c(f[h].callback,e,f[h].combo,f[h].seq)):l||c(f[h].callback,e,f[h].combo);f=\"keypress\"==e.type&&r;e.type!=x||w(a)||f||b(d);r=l&&\"keydown\"==e.type};k._bindMultiple=function(a,b,c){for(var d=0;d<a.length;++d)n(a[d],b,c)};v(a,\"keypress\",e);v(a,\"keydown\",e);v(a,\"keyup\",e)}if(q){var n={8:\"backspace\",9:\"tab\",13:\"enter\",16:\"shift\",17:\"ctrl\",\r\n18:\"alt\",20:\"capslock\",27:\"esc\",32:\"space\",33:\"pageup\",34:\"pagedown\",35:\"end\",36:\"home\",37:\"left\",38:\"up\",39:\"right\",40:\"down\",45:\"ins\",46:\"del\",91:\"meta\",93:\"meta\",224:\"meta\"},r={106:\"*\",107:\"+\",109:\"-\",110:\".\",111:\"/\",186:\";\",187:\"=\",188:\",\",189:\"-\",190:\".\",191:\"/\",192:\"`\",219:\"[\",220:\"\\\\\",221:\"]\",222:\"'\"},C={\"~\":\"`\",\"!\":\"1\",\"@\":\"2\",\"#\":\"3\",$:\"4\",\"%\":\"5\",\"^\":\"6\",\"&\":\"7\",\"*\":\"8\",\"(\":\"9\",\")\":\"0\",_:\"-\",\"+\":\"=\",\":\":\";\",'\"':\"'\",\"<\":\",\",\">\":\".\",\"?\":\"/\",\"|\":\"\\\\\"},B={option:\"alt\",command:\"meta\",\"return\":\"enter\",\r\nescape:\"esc\",plus:\"+\",mod:/Mac|iPod|iPhone|iPad/.test(navigator.platform)?\"meta\":\"ctrl\"},p;for(c=1;20>c;++c)n[111+c]=\"f\"+c;for(c=0;9>=c;++c)n[c+96]=c.toString();d.prototype.bind=function(a,b,c){a=a instanceof Array?a:[a];this._bindMultiple.call(this,a,b,c);return this};d.prototype.unbind=function(a,b){return this.bind.call(this,a,function(){},b)};d.prototype.trigger=function(a,b){if(this._directMap[a+\":\"+b])this._directMap[a+\":\"+b]({},a);return this};d.prototype.reset=function(){this._callbacks={};\r\nthis._directMap={};return this};d.prototype.stopCallback=function(a,b){if(-1<(\" \"+b.className+\" \").indexOf(\" mousetrap \")||D(b,this.target))return!1;if(\"composedPath\"in a&&\"function\"===typeof a.composedPath){var c=a.composedPath()[0];c!==a.target&&(b=c)}return\"INPUT\"==b.tagName||\"SELECT\"==b.tagName||\"TEXTAREA\"==b.tagName||b.isContentEditable};d.prototype.handleKey=function(){return this._handleKey.apply(this,arguments)};d.addKeycodes=function(a){for(var b in a)a.hasOwnProperty(b)&&(n[b]=a[b]);p=null};\r\nd.init=function(){var a=d(u),b;for(b in a)\"_\"!==b.charAt(0)&&(d[b]=function(b){return function(){return a[b].apply(a,arguments)}}(b))};d.init();\"undefined\"!==typeof module&&module.exports&&(module.exports=d);\"function\"===typeof define&&define.amd&&define(function(){return d})}})(\"undefined\"!==typeof window?window:null,\"undefined\"!==typeof window?document:null);\n"},"lib/observable":{"content":"\n/*\nObservable\n==========\n\n`Observable` allows for observing arrays, functions, and objects.\n\nFunction dependencies are automagically observed.\n\nStandard array methods are proxied through to the underlying array.\n */\n\"use strict\";\nvar Observable, PROXY_LENGTH, copy, last, magicDependency, noop, remove,\n  __slice = [].slice;\n\nmodule.exports = Observable = function(value, context) {\n  var changed, fn, listeners, notify, self;\n  if (typeof (value != null ? value.observe : void 0) === \"function\") {\n    return value;\n  }\n  listeners = [];\n  notify = function(newValue) {\n    self._value = newValue;\n    return copy(listeners).forEach(function(listener) {\n      return listener(newValue);\n    });\n  };\n  if (typeof value === 'function') {\n    fn = value;\n    self = function() {\n      magicDependency(self);\n      return value;\n    };\n    self.releaseDependencies = function() {\n      var _ref;\n      return (_ref = self._observableDependencies) != null ? _ref.forEach(function(observable) {\n        return observable.stopObserving(changed);\n      }) : void 0;\n    };\n    changed = function() {\n      var observableDependencies;\n      observableDependencies = new Set;\n      global.OBSERVABLE_ROOT_HACK.push(observableDependencies);\n      try {\n        value = fn.call(context);\n      } finally {\n        global.OBSERVABLE_ROOT_HACK.pop();\n      }\n      self.releaseDependencies();\n      self._observableDependencies = observableDependencies;\n      observableDependencies.forEach(function(observable) {\n        return observable.observe(changed);\n      });\n      return notify(value);\n    };\n    changed();\n  } else {\n    self = function(newValue) {\n      if (arguments.length > 0) {\n        if (value !== newValue) {\n          value = newValue;\n          notify(newValue);\n        }\n      } else {\n        magicDependency(self);\n      }\n      return value;\n    };\n    self.releaseDependencies = noop;\n    self._value = value;\n  }\n  if (Array.isArray(value)) {\n    [\"concat\", \"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function(method) {\n      return self[method] = function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        magicDependency(self);\n        return value[method].apply(value, args);\n      };\n    });\n    [\"pop\", \"push\", \"reverse\", \"shift\", \"splice\", \"sort\", \"unshift\"].forEach(function(method) {\n      return self[method] = function() {\n        var args, returnValue;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        returnValue = value[method].apply(value, args);\n        notify(value);\n        return returnValue;\n      };\n    });\n    if (PROXY_LENGTH) {\n      Object.defineProperty(self, 'length', {\n        get: function() {\n          magicDependency(self);\n          return value.length;\n        },\n        set: function(length) {\n          var returnValue;\n          returnValue = value.length = length;\n          notify(value);\n          return returnValue;\n        }\n      });\n    }\n    Object.assign(self, {\n      remove: function(object) {\n        var index, returnValue;\n        index = value.indexOf(object);\n        if (index >= 0) {\n          returnValue = value.splice(index, 1)[0];\n          notify(value);\n          return returnValue;\n        }\n      },\n      get: function(index) {\n        magicDependency(self);\n        return value[index];\n      },\n      first: function() {\n        magicDependency(self);\n        return value[0];\n      },\n      last: function() {\n        magicDependency(self);\n        return value[value.length - 1];\n      },\n      size: function() {\n        magicDependency(self);\n        return value.length;\n      }\n    });\n  }\n  Object.assign(self, {\n    listeners: listeners,\n    observe: function(listener) {\n      return listeners.push(listener);\n    },\n    stopObserving: function(fn) {\n      return remove(listeners, fn);\n    },\n    toggle: function() {\n      return self(!value);\n    },\n    increment: function(n) {\n      if (n == null) {\n        n = 1;\n      }\n      return self(Number(value) + n);\n    },\n    decrement: function(n) {\n      if (n == null) {\n        n = 1;\n      }\n      return self(Number(value) - n);\n    },\n    toString: function() {\n      return \"Observable(\" + value + \")\";\n    }\n  });\n  return self;\n};\n\nglobal.OBSERVABLE_ROOT_HACK = [];\n\nmagicDependency = function(self) {\n  var observerSet;\n  observerSet = last(global.OBSERVABLE_ROOT_HACK);\n  if (observerSet) {\n    return observerSet.add(self);\n  }\n};\n\nremove = function(array, value) {\n  var index;\n  index = array.indexOf(value);\n  if (index >= 0) {\n    return array.splice(index, 1)[0];\n  }\n};\n\ncopy = function(array) {\n  return array.concat([]);\n};\n\nlast = function(array) {\n  return array[array.length - 1];\n};\n\nnoop = function() {};\n\ntry {\n  Object.defineProperty((function() {}), 'length', {\n    get: noop,\n    set: noop\n  });\n  PROXY_LENGTH = true;\n} catch (_error) {\n  PROXY_LENGTH = false;\n}\n"},"lib/pkg/compilers":{"content":"var CompileError, compile, compilers, identity, lazyLoader;\n\nlazyLoader = require(\"../util/index\").lazyLoader;\n\nidentity = function(path, source) {\n  return source;\n};\n\nCompileError = function(message, location) {\n  this.location = location;\n  this.message = message;\n  return delete this.stack;\n};\n\nCompileError.prototype = Object.create(new Error);\n\ncompilers = {\n  css: identity,\n  html: identity,\n  js: identity,\n  coffee: lazyLoader([\"https://danielx.net/cdn/coffee-script/1.7.1.min.js\"])(function(path, source) {\n    var e, location, message;\n    try {\n      return CoffeeScript.compile(source, {\n        bare: true,\n        filename: path\n      });\n    } catch (_error) {\n      e = _error;\n      message = e.message, location = e.location;\n      if (location) {\n        throw new CompileError(message, {\n          row: location.first_line,\n          column: location.first_column,\n          text: message,\n          type: \"error\"\n        });\n      } else {\n        throw e;\n      }\n    }\n  }),\n  md: lazyLoader([\"https://danielx.net/cdn/marked/0.6.2.min.js\"])(function(path, source) {\n    return marked(source);\n  }),\n  styl: lazyLoader([\"https://danielx.net/cdn/stylus/0.54.5.min.js\"])(function(path, source) {\n    var column, e, match, message, row, _;\n    try {\n      return stylus.render(source, {\n        filename: path\n      });\n    } catch (_error) {\n      e = _error;\n      if (e.name === \"ParseError\") {\n        if (match = e.message.match(/^[^:]*:(\\d+):(\\d+)/)) {\n          _ = match[0], row = match[1], column = match[2];\n          message = e.message.split(\"\\n\")[8];\n          throw new CompileError(message, {\n            row: row - 298,\n            column: column,\n            text: message,\n            type: \"error\"\n          });\n        }\n      } else {\n        throw e;\n      }\n    }\n  })\n};\n\ncompile = function(path, source) {\n  var extension, extensionFor;\n  extensionFor = require(\"../fs/util\").extensionFor;\n  extension = extensionFor(path);\n  return Promise.resolve().then(function() {\n    var compiler;\n    if (compiler = compilers[extension]) {\n      return compiler(path, source);\n    } else {\n      throw new Error(\"Couldn't compile '\" + path + \"'. No compiler for '.\" + extension + \"'\");\n    }\n  });\n};\n\nmodule.exports = {\n  compile: compile,\n  CompileError: CompileError,\n  registerCompiler: function(ext, fn) {\n    return compilers[ext] = fn;\n  }\n};\n"},"lib/pkg/experimental":{"content":"var functionalize, keyString;\n\nkeyString = function(key) {\n  if (key.match(/^[A-Za-z]+[A-Za-z0-9]*$/)) {\n    return key;\n  } else {\n    return JSON.stringify(key);\n  }\n};\n\nfunctionalize = function(pkg) {\n  return \"{\" + keys(pkg).map(function(key) {\n    var v, value;\n    v = pkg[key];\n    if (key === \"distribution\") {\n      value = \"{\" + keys(v).map(function(path) {\n        return \"\" + (keyString(path)) + \":function(){\" + v[path].content + \"}\";\n      }).join(\",\\n\") + \"}\";\n    } else if (key === \"dependencies\") {\n      value = \"{\" + keys(v).map(function(dep) {\n        return \"\" + (keyString(dep)) + \":\" + (functionalize(v[dep]));\n      }).join(\",\\n\") + \"}\";\n    } else {\n      value = JSON.stringify(v, null, 2);\n    }\n    return \"\" + (keyString(key)) + \": \" + value;\n  }).join(\",\\n\") + \"}\";\n};\n"},"lib/pkg/index":{"content":"\n/*\n`pkg` holds utilities for bundling and launching packages as standalone blobs or\nin iframes.\n */\nvar crudeRequire, dependencyScripts, exec, htmlForPackage, htmlToBlob, latestRequire, lazyLoader, linkTag, metaTag, minifyPackage, remotePackageLauncher, systemWrap, uglifyLoaded,\n  __slice = [].slice;\n\nhtmlToBlob = function(htmlString) {\n  return new Blob([htmlString], {\n    type: \"text/html; charset=utf-8\"\n  });\n};\n\nmetaTag = function(name, content) {\n  return \"<meta name=\" + (JSON.stringify(name)) + \" content=\" + (JSON.stringify(content)) + \">\";\n};\n\nlinkTag = function(rel, href) {\n  return \"<link rel=\" + (JSON.stringify(rel)) + \" href=\" + (JSON.stringify(href)) + \">\";\n};\n\nlazyLoader = require(\"../util/index\").lazyLoader;\n\nuglifyLoaded = lazyLoader([\"https://danielx.net/cdn/uglify/3.0.0.min.js\"]);\n\nlatestRequire = require(\"./require\");\n\n\n/*\nConstruct an HTML file for the package.\n\nThe default behavior is to load the package's entry point but\nthat can be modified enter from any file in the package.\n\nIt also adds remote dependencies to the HTML head and wraps with\nthe system launch if present.\n\nThis is designed to be simple and general, any magic binding should happen in\nthe `!system` layer. Here we are only concerned with html tags and setting up\nthe package with `require`.\n\n`opts`\nadditionalDependencies: array of additional dependency scripts to include in\nthe html source. Useful for things like testing libraries, doc formatting, etc.\ncode: The code snippet to run, defaults to requiring the default package\nentry point.\nstylesheets: array of urls to add as stylesheet link tags\nsystemConfig: configuration parameters for the system runtime.\n */\n\nhtmlForPackage = function(pkg, opts) {\n  var code, config, description, iconURL, lang, langFragment, manifest, metas, progenitor, systemConfig, title, url, _ref;\n  if (opts == null) {\n    opts = {};\n  }\n  metas = ['<meta charset=\"utf-8\">', '<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">'];\n  config = pkg.config, progenitor = pkg.progenitor;\n  if (config == null) {\n    config = {};\n  }\n  code = opts.code, systemConfig = opts.systemConfig;\n  if (code == null) {\n    code = \"require('./\" + (pkg.entryPoint || \"main\") + \"');\";\n  }\n  code = systemWrap(pkg, code, systemConfig);\n  title = config.title, description = config.description, lang = config.lang, iconURL = config.iconURL, manifest = config.manifest;\n  if (lang) {\n    langFragment = \" lang=\" + (JSON.stringify(lang));\n  } else {\n    langFragment = \"\";\n  }\n  if (title) {\n    metas.push(\"<title>\" + title + \"</title>\");\n  }\n  if (description) {\n    metas.push(metaTag(\"description\", description.replace(\"\\n\", \" \")));\n  }\n  if (iconURL) {\n    metas.push(linkTag(\"shortcut icon\", iconURL));\n  }\n  if (manifest) {\n    metas.push(linkTag(\"manifest\", \"./manifest.webmanifest\"));\n  }\n  url = (_ref = pkg.progenitor) != null ? _ref.url : void 0;\n  if (url) {\n    metas.push(linkTag(\"progenitor\", url));\n  }\n  (pkg.stylesheets || []).concat(opts.stylesheets || []).forEach(function(href) {\n    return metas.push(linkTag(\"stylesheet\", href));\n  });\n  return htmlToBlob(\"<!DOCTYPE html>\\n<html\" + langFragment + \">\\n  <head>\\n    \" + (metas.join(\"\\n    \")) + \"\\n    \" + (dependencyScripts(opts.additionalDependencies, pkg.remoteDependencies)) + \"\\n  </head>\\n  <body>\\n    <script>\\n      \" + (latestRequire.packageWrapper(pkg, code)) + \"\\n    <\\/script>\\n  </body>\\n</html>\");\n};\n\ndependencyScripts = function(additionalDependencies, remoteDependencies) {\n  if (additionalDependencies == null) {\n    additionalDependencies = [];\n  }\n  if (remoteDependencies == null) {\n    remoteDependencies = [];\n  }\n  return additionalDependencies.concat(remoteDependencies).map(function(src) {\n    return \"<script src=\" + (JSON.stringify(src)) + \"><\\/script>\";\n  }).join(\"\\n\");\n};\n\nsystemWrap = function(pkg, code, opts) {\n  var _ref;\n  if (opts == null) {\n    opts = {};\n  }\n  if ((_ref = pkg.dependencies) != null ? _ref[\"!system\"] : void 0) {\n    return \"require(\\\"!system\\\").launch(\" + (JSON.stringify(opts)) + \", function(config) {\\n  \" + code + \"\\n});\";\n  } else {\n    return code;\n  }\n};\n\n\n/*\nExecute a source code program within an environment.\n */\n\nexec = function(program, env, context) {\n  var args, values;\n  if (env == null) {\n    env = {};\n  }\n  args = Object.keys(env);\n  values = args.map(function(name) {\n    return env[name];\n  });\n  return Function.apply(null, __slice.call(args).concat([program])).apply(context, values);\n};\n\n\n/*\nExecute a single source program with no dependencies and return what it exports.\n */\n\ncrudeRequire = function(program) {\n  var env;\n  env = {\n    module: {\n      exports: {}\n    }\n  };\n  exec(program, env, env.module);\n  return env.module.exports;\n};\n\nminifyPackage = uglifyLoaded(function(pkg, logger) {\n  var dist, initialSize;\n  initialSize = JSON.stringify(pkg).length;\n  pkg = Object.assign({}, pkg);\n  delete pkg.source;\n  dist = pkg.distribution = Object.assign({}, pkg.distribution);\n  Object.keys(dist).forEach(function(name) {\n    var code, file;\n    if (name.match(/^test\\/|\\/test\\//)) {\n      delete dist[name];\n    }\n    file = dist[name];\n    if (!file || !file.content) {\n      delete dist[name];\n      return;\n    }\n    code = UglifyJS.minify(file.content, {\n      toplevel: true\n    }).code;\n    if (code) {\n      return dist[name] = {\n        content: code\n      };\n    } else {\n      return delete dist[name];\n    }\n  });\n  return Promise.all(Object.keys(pkg.dependencies || {}).map(function(name) {\n    return minifyPackage(pkg.dependencies[name], logger).then(function(m) {\n      return pkg.dependencies[name] = m;\n    });\n  })).then(function() {\n    var minSize;\n    minSize = JSON.stringify(pkg).length;\n    if (logger != null) {\n      logger.log(\"Minified \" + pkg.config.name + \": \" + initialSize + \" -> \" + minSize + \" (\" + (((1 - minSize / initialSize) * 100).toFixed(1)) + \"% reduction)\");\n    }\n    return pkg;\n  });\n});\n\nmodule.exports = Object.assign({}, require(\"./compilers\"), {\n  crudeRequire: crudeRequire,\n  exec: exec,\n  htmlForPackage: htmlForPackage,\n  Require: require(\"./require\"),\n  jsForPackage: function(pkg, globalName, customCode) {\n    if (globalName == null) {\n      globalName = pkg.config.name;\n    }\n    if (customCode == null) {\n      customCode = \"\" + globalName + \" = require('./main')\";\n    }\n    return require.packageWrapper(pkg, customCode);\n  },\n  minify: minifyPackage,\n  ModLoader: require(\"./mod-loader\")\n});\n\nremotePackageLauncher = function(pkg, url) {\n  return \"xhr = new XMLHttpRequest;\\nurl = \" + (JSON.stringify(url)) + \";\\nxhr.open(\\\"GET\\\", url, true);\\nxhr.responseType = \\\"json\\\";\\nxhr.onload = function() {\\n  (function(PACKAGE) {\\n    var src = \" + (JSON.stringify(PACKAGE.dependencies.require.distribution.main.content)) + \";\\n    var Require = new Function(\\\"PACKAGE\\\", \\\"return \\\" + src)({distribution: {main: {content: src}}});\\n    var require = Require.generateFor(PACKAGE);\\n    require('./' + PACKAGE.entryPoint);\\n  })(xhr.response)\\n};\\nxhr.send();\";\n};\n"},"lib/pkg/require":{"content":"var annotateSourceURL, cacheFor, circularGuard, defaultEntryPoint, fileSeparator, generateRequireFn, global, isPackage, loadModule, loadPackage, loadPath, normalizePath, publicAPI, rootModule, startsWith,\n  __slice = [].slice;\n\nfileSeparator = '/';\n\nglobal = self;\n\ndefaultEntryPoint = \"main\";\n\ncircularGuard = {};\n\nrootModule = {\n  path: \"\"\n};\n\nloadPath = function(parentModule, pkg, path) {\n  var cache, localPath, module, normalizedPath;\n  if (startsWith(path, '/')) {\n    localPath = [];\n  } else {\n    localPath = parentModule.path.split(fileSeparator);\n  }\n  normalizedPath = normalizePath(path, localPath);\n  cache = cacheFor(pkg);\n  if (module = cache[normalizedPath]) {\n    if (module === circularGuard) {\n      throw \"Circular dependency detected when requiring \" + normalizedPath;\n    }\n  } else {\n    cache[normalizedPath] = circularGuard;\n    try {\n      cache[normalizedPath] = module = loadModule(pkg, normalizedPath);\n    } finally {\n      if (cache[normalizedPath] === circularGuard) {\n        delete cache[normalizedPath];\n      }\n    }\n  }\n  return module.exports;\n};\n\nnormalizePath = function(path, base) {\n  var piece, result;\n  if (base == null) {\n    base = [];\n  }\n  base = base.concat(path.split(fileSeparator));\n  result = [];\n  while (base.length) {\n    switch (piece = base.shift()) {\n      case \"..\":\n        result.pop();\n        break;\n      case \"\":\n      case \".\":\n        break;\n      default:\n        result.push(piece);\n    }\n  }\n  return result.join(fileSeparator);\n};\n\nloadPackage = function(pkg) {\n  var path;\n  path = pkg.entryPoint || defaultEntryPoint;\n  return loadPath(rootModule, pkg, path);\n};\n\nloadModule = function(pkg, path) {\n  var args, content, context, dirname, file, module, program, values;\n  if (!(file = pkg.distribution[path])) {\n    throw \"Could not find file at \" + path + \" in \" + pkg.name;\n  }\n  if ((content = file.content) == null) {\n    throw \"Malformed package. No content for file at \" + path + \" in \" + pkg.name;\n  }\n  program = content;\n  dirname = path.split(fileSeparator).slice(0, -1).join(fileSeparator);\n  module = {\n    path: dirname,\n    exports: {}\n  };\n  context = {\n    require: generateRequireFn(pkg, module),\n    global: global,\n    module: module,\n    exports: module.exports,\n    PACKAGE: pkg,\n    __filename: path,\n    __dirname: dirname\n  };\n  args = Object.keys(context);\n  values = args.map(function(name) {\n    return context[name];\n  });\n  Function.apply(null, __slice.call(args).concat([program])).apply(module, values);\n  return module;\n};\n\nisPackage = function(path) {\n  if (!(startsWith(path, fileSeparator) || startsWith(path, \".\" + fileSeparator) || startsWith(path, \"..\" + fileSeparator))) {\n    return path.split(fileSeparator)[0];\n  } else {\n    return false;\n  }\n};\n\ngenerateRequireFn = function(pkg, module) {\n  var fn;\n  if (module == null) {\n    module = rootModule;\n  }\n  if (pkg.name == null) {\n    pkg.name = \"ROOT\";\n  }\n  if (pkg.scopedName == null) {\n    pkg.scopedName = \"ROOT\";\n  }\n  fn = function(path) {\n    var otherPackage;\n    if (typeof path === \"object\") {\n      return loadPackage(path);\n    } else if (isPackage(path)) {\n      if (!(otherPackage = pkg.dependencies[path])) {\n        throw \"Package: \" + path + \" not found.\";\n      }\n      if (otherPackage.name == null) {\n        otherPackage.name = path;\n      }\n      if (otherPackage.scopedName == null) {\n        otherPackage.scopedName = \"\" + pkg.scopedName + \"/\" + path;\n      }\n      return loadPackage(otherPackage);\n    } else {\n      return loadPath(module, pkg, path);\n    }\n  };\n  fn.packageWrapper = publicAPI.packageWrapper;\n  fn.executePackageWrapper = publicAPI.executePackageWrapper;\n  return fn;\n};\n\npublicAPI = {\n  generateFor: generateRequireFn,\n  packageWrapper: function(pkg, code) {\n    return \";(function(PACKAGE) {\\n  var require = (function() {\\n    var src = \" + (JSON.stringify(PACKAGE.distribution[\"lib/pkg/require\"].content)) + \";\\n    var module = {};\\n    Function(\\\"PACKAGE\\\", \\\"module\\\", \\\"exports\\\", src)({\\n      distribution: {\\\"lib/pkg/require\\\": {content: src}}\\n    }, module, true);\\n\\n    return module.exports;\\n  }()).generateFor(PACKAGE);\\n  \" + code + \";\\n})(\" + (JSON.stringify(pkg, null, 2)) + \");\";\n  },\n  executePackageWrapper: function(pkg) {\n    return publicAPI.packageWrapper(pkg, \"require('./\" + pkg.entryPoint + \"')\");\n  },\n  loadPackage: loadPackage\n};\n\nif (typeof exports !== \"undefined\" && exports !== null) {\n  module.exports = publicAPI;\n} else {\n  global.Require = publicAPI;\n}\n\nstartsWith = function(string, prefix) {\n  return string.lastIndexOf(prefix, 0) === 0;\n};\n\ncacheFor = function(pkg) {\n  if (pkg.cache) {\n    return pkg.cache;\n  }\n  Object.defineProperty(pkg, \"cache\", {\n    value: {}\n  });\n  return pkg.cache;\n};\n\nannotateSourceURL = function(program, pkg, path) {\n  return \"\" + program + \"\\n//# sourceURL=\" + pkg.scopedName + \"/\" + path;\n};\n"},"lib/pkg/require2":{"content":"var create,\n  __slice = [].slice;\n\ncreate = function(create) {\n  var annotateSourceURL, cacheFor, circularGuard, defaultEntryPoint, fileSeparator, generateRequireFn, generateSrc, global, isPackage, loadModule, loadPackage, loadPath, normalizePath, publicAPI, rootModule, startsWith;\n  fileSeparator = '/';\n  global = self;\n  defaultEntryPoint = \"main\";\n  circularGuard = {};\n  rootModule = {\n    path: \"\"\n  };\n  loadPath = function(parentModule, pkg, path) {\n    var cache, localPath, module, normalizedPath;\n    if (startsWith(path, '/')) {\n      localPath = [];\n    } else {\n      localPath = parentModule.path.split(fileSeparator);\n    }\n    normalizedPath = normalizePath(path, localPath);\n    cache = cacheFor(pkg);\n    if (module = cache[normalizedPath]) {\n      if (module === circularGuard) {\n        throw \"Circular dependency detected when requiring \" + normalizedPath;\n      }\n    } else {\n      cache[normalizedPath] = circularGuard;\n      try {\n        cache[normalizedPath] = module = loadModule(pkg, normalizedPath);\n      } finally {\n        if (cache[normalizedPath] === circularGuard) {\n          delete cache[normalizedPath];\n        }\n      }\n    }\n    return module.exports;\n  };\n  normalizePath = function(path, base) {\n    var piece, result;\n    if (base == null) {\n      base = [];\n    }\n    base = base.concat(path.split(fileSeparator));\n    result = [];\n    while (base.length) {\n      switch (piece = base.shift()) {\n        case \"..\":\n          result.pop();\n          break;\n        case \"\":\n        case \".\":\n          break;\n        default:\n          result.push(piece);\n      }\n    }\n    return result.join(fileSeparator);\n  };\n  loadPackage = function(pkg) {\n    var path;\n    path = pkg.entryPoint || defaultEntryPoint;\n    return loadPath(rootModule, pkg, path);\n  };\n  loadModule = function(pkg, path) {\n    var args, content, context, dirname, file, module, program, values;\n    if (!(file = pkg.distribution[path])) {\n      throw \"Could not find file at \" + path + \" in \" + pkg.name;\n    }\n    if ((content = file.content) == null) {\n      throw \"Malformed package. No content for file at \" + path + \" in \" + pkg.name;\n    }\n    program = annotateSourceURL(content, pkg, path);\n    dirname = path.split(fileSeparator).slice(0, -1).join(fileSeparator);\n    module = {\n      path: dirname,\n      exports: {}\n    };\n    context = {\n      require: generateRequireFn(pkg, module),\n      global: global,\n      module: module,\n      exports: module.exports,\n      PACKAGE: pkg\n    };\n    args = Object.keys(context);\n    values = args.map(function(name) {\n      return context[name];\n    });\n    Function.apply(null, __slice.call(args).concat([program])).apply(module, values);\n    return module;\n  };\n  isPackage = function(path) {\n    if (!(startsWith(path, fileSeparator) || startsWith(path, \".\" + fileSeparator) || startsWith(path, \"..\" + fileSeparator))) {\n      return path.split(fileSeparator)[0];\n    } else {\n      return false;\n    }\n  };\n  generateRequireFn = function(pkg, module) {\n    var fn;\n    if (module == null) {\n      module = rootModule;\n    }\n    if (pkg.name == null) {\n      pkg.name = \"ROOT\";\n    }\n    if (pkg.scopedName == null) {\n      pkg.scopedName = \"ROOT\";\n    }\n    fn = function(path) {\n      var otherPackage;\n      if (typeof path === \"object\") {\n        return loadPackage(path);\n      } else if (isPackage(path)) {\n        if (!(otherPackage = pkg.dependencies[path])) {\n          throw \"Package: \" + path + \" not found.\";\n        }\n        if (otherPackage.name == null) {\n          otherPackage.name = path;\n        }\n        if (otherPackage.scopedName == null) {\n          otherPackage.scopedName = \"\" + pkg.scopedName + \"/\" + path;\n        }\n        return loadPackage(otherPackage);\n      } else {\n        return loadPath(module, pkg, path);\n      }\n    };\n    Object.assign(fn, publicAPI);\n    return fn;\n  };\n  startsWith = function(string, prefix) {\n    return string.lastIndexOf(prefix, 0) === 0;\n  };\n  cacheFor = function(pkg) {\n    if (pkg.cache) {\n      return pkg.cache;\n    }\n    Object.defineProperty(pkg, \"cache\", {\n      value: {}\n    });\n    return pkg.cache;\n  };\n  annotateSourceURL = function(program, pkg, path) {\n    return \"\" + program + \"\\n//# sourceURL=\" + pkg.scopedName + \"/\" + path;\n  };\n  generateSrc = function() {\n    var src;\n    return src = \"(function(create) {\\n  return create(create)\\n}(\" + (create.toString()) + \"))\\n\";\n  };\n  publicAPI = {\n    generateFor: generateRequireFn,\n    packageWrapper: function(pkg, code) {\n      var pkgStr;\n      pkgStr = JSON.stringify(pkg, null, 2);\n      return \"(function(PACKAGE) {\\n  var require = \" + (generateSrc()) + \".generateFor(PACKAGE);\\n  \" + code + \";\\n})(\" + pkgStr + \");\";\n    },\n    executePackageWrapper: function(pkg) {\n      return publicAPI.packageWrapper(pkg, \"require.loadPackage(PACKAGE)\");\n    },\n    loadPackage: loadPackage\n  };\n  if (typeof module !== \"undefined\" && module !== null) {\n    module.exports = publicAPI;\n  }\n  return publicAPI;\n};\n\ncreate(create);\n"},"lib/polyfill":{"content":"var endsWith, startsWith, _base, _base1;\n\nstartsWith = function(search, rawPos) {\n  var pos;\n  if (rawPos > 0) {\n    pos = rawPos | 0;\n  } else {\n    pos = 0;\n  }\n  return this.substring(pos, pos + search.length) === search;\n};\n\nendsWith = function(search, l) {\n  var length;\n  length = this.length;\n  if (l === void 0 || l > length) {\n    l = length;\n  }\n  return this.substring(l - search.length, l) === search;\n};\n\nif ((_base = String.prototype).endsWith == null) {\n  _base.endsWith = endsWith;\n}\n\nif ((_base1 = String.prototype).startsWith == null) {\n  _base1.startsWith = startsWith;\n}\n\nmodule.exports = {\n  startsWith: startsWith,\n  endsWith: endsWith\n};\n"},"lib/postmaster":{"content":"\n/*\n\nPostmaster wraps the `postMessage` API with promises.\n */\nvar Postmaster, ackTimeout, defaultReceiver, pmId,\n  __slice = [].slice;\n\ndefaultReceiver = self;\n\nackTimeout = 1000;\n\npmId = 0;\n\nmodule.exports = Postmaster = function(self) {\n  var clear, debug, dominant, info, listener, msgId, name, pendingResponses, receiver, send;\n  if (self == null) {\n    self = {};\n  }\n  name = \"\" + defaultReceiver.name + \"-\" + (++pmId);\n  info = function() {\n    var _ref;\n    return (_ref = self.logger).info.apply(_ref, [name].concat(__slice.call(arguments)));\n  };\n  debug = function() {\n    var _ref;\n    return (_ref = self.logger).debug.apply(_ref, [name].concat(__slice.call(arguments)));\n  };\n  dominant = Postmaster.dominant();\n  if (self.remoteTarget == null) {\n    self.remoteTarget = function() {\n      return dominant;\n    };\n  }\n  if (self.receiver == null) {\n    self.receiver = function() {\n      return defaultReceiver;\n    };\n  }\n  if (self.ackTimeout == null) {\n    self.ackTimeout = function() {\n      return ackTimeout;\n    };\n  }\n  if (self.delegate == null) {\n    self.delegate = self;\n  }\n  if (self.logger == null) {\n    self.logger = {\n      info: function() {},\n      debug: function() {}\n    };\n  }\n  if (self.targetOrigin == null) {\n    self.targetOrigin = \"*\";\n  }\n  if (self.token == null) {\n    self.token = Math.random();\n  }\n  send = function(data) {\n    var target;\n    target = self.remoteTarget();\n    if (self.token) {\n      data.token = self.token;\n    }\n    data.from = name;\n    if (!target) {\n      throw new Error(\"No remote target\");\n    }\n    info(\"->\", data);\n    if ((typeof Worker === \"undefined\" || Worker === null) || target instanceof Worker) {\n      target.postMessage(data);\n    } else {\n      target.postMessage(data, self.targetOrigin);\n    }\n  };\n  listener = function(event) {\n    var data, id, method, params, source, target, type, _ref;\n    data = event.data, source = event.source;\n    target = self.remoteTarget();\n    if (source === target || (source === void 0 && data.token === self.token)) {\n      event.stopImmediatePropagation();\n      info(\"<-\", data);\n      type = data.type, method = data.method, params = data.params, id = data.id;\n      switch (type) {\n        case \"ack\":\n          return (_ref = pendingResponses[id]) != null ? _ref.ack = true : void 0;\n        case \"response\":\n          return pendingResponses[id].resolve(data.result);\n        case \"error\":\n          return pendingResponses[id].reject(data.error);\n        case \"message\":\n          return Promise.resolve().then(function() {\n            var _ref1;\n            if (source) {\n              send({\n                type: \"ack\",\n                id: id\n              });\n            }\n            if (typeof self.delegate[method] === \"function\") {\n              return (_ref1 = self.delegate)[method].apply(_ref1, params);\n            } else {\n              throw new Error(\"`\" + method + \"` is not a function\");\n            }\n          }).then(function(result) {\n            if (source) {\n              return send({\n                type: \"response\",\n                id: id,\n                result: result\n              });\n            }\n          })[\"catch\"](function(error) {\n            var message;\n            if (typeof error === \"string\") {\n              message = error;\n            } else {\n              message = error.message;\n            }\n            if (source) {\n              return send({\n                type: \"error\",\n                id: id,\n                error: {\n                  message: message,\n                  stack: error.stack\n                }\n              });\n            }\n          });\n      }\n    } else {\n      return debug(\"DROP message\", event, \"source \" + (JSON.stringify(data.from)) + \" does not match target\");\n    }\n  };\n  receiver = self.receiver();\n  receiver.addEventListener(\"message\", listener);\n  self.dispose = function() {\n    receiver.removeEventListener(\"message\", listener);\n    return info(\"DISPOSE\");\n  };\n  pendingResponses = {};\n  msgId = 0;\n  clear = function(id) {\n    debug(\"CLEAR PENDING\", id);\n    clearTimeout(pendingResponses[id].timeout);\n    return delete pendingResponses[id];\n  };\n  self.send = function() {\n    var method, params;\n    method = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    return new Promise(function(resolve, reject) {\n      var ackWait, e, id, resp, timeout;\n      id = ++msgId;\n      ackWait = self.ackTimeout();\n      timeout = setTimeout(function() {\n        if (!resp.ack) {\n          info(\"TIMEOUT\", resp);\n          return resp.reject(new Error(\"No ack received within \" + ackWait));\n        }\n      }, ackWait);\n      debug(\"STORE PENDING\", id);\n      pendingResponses[id] = resp = {\n        timeout: timeout,\n        resolve: function(result) {\n          debug(\"RESOLVE\", id, result);\n          resolve(result);\n          return clear(id);\n        },\n        reject: function(error) {\n          debug(\"REJECT\", id, error);\n          reject(error);\n          return clear(id);\n        }\n      };\n      try {\n        send({\n          type: \"message\",\n          method: method,\n          params: params,\n          id: id\n        });\n      } catch (_error) {\n        e = _error;\n        setTimeout(function() {\n          return reject(e);\n        }, 0);\n      }\n    });\n  };\n  self.invokeRemote = function() {\n    console.warn(\"Postmaster#invokeRemote is deprecated. Use #send instead.\");\n    return self.send.apply(self, arguments);\n  };\n  info(\"INITIALIZE\");\n  return self;\n};\n\nPostmaster.dominant = function() {\n  if (typeof window !== \"undefined\" && window !== null) {\n    return opener || ((parent !== window) && parent) || void 0;\n  } else {\n    return self;\n  }\n};\n"},"lib/runtime":{"content":"var Observable, Postmaster, Runtime, Style, applyStyle, version, _ref,\n  __slice = [].slice;\n\nversion = require(\"../pixie\").version;\n\nPostmaster = require(\"./postmaster\");\n\n_ref = require(\"../lib/ui/index\"), applyStyle = _ref.applyStyle, Observable = _ref.Observable, Style = _ref.Style;\n\nRuntime = function(system, opts) {\n  var BaseApp, applicationProxy, applicationTarget, client, eventListeners, externalObservables, heldApplicationMessages, host, hostTarget, initializeOnZineOS, lastEventListenerId, polyfillForStandalone, postmaster, readyPromise, remoteExists;\n  if (opts == null) {\n    opts = {};\n  }\n  if (opts.applyStyle) {\n    applyStyle(Style.all, 'system');\n  }\n  if (opts.logger == null) {\n    opts.logger = {\n      info: function() {},\n      debug: function() {}\n    };\n  }\n  externalObservables = {};\n  heldApplicationMessages = [];\n  postmaster = Postmaster({\n    logger: opts.logger,\n    delegate: {\n      application: function() {\n        var args, method, _ref1;\n        method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n        if (applicationTarget.delegate) {\n          return (_ref1 = applicationTarget.delegate)[method].apply(_ref1, args);\n        } else {\n          return new Promise(function(resolve, reject) {\n            return heldApplicationMessages.push(function(delegate) {\n              var e;\n              try {\n                return resolve(delegate[method].apply(delegate, args));\n              } catch (_error) {\n                e = _error;\n                return reject(e);\n              }\n            });\n          });\n        }\n      },\n      updateSignal: function(name, newValue) {\n        return externalObservables[name](newValue);\n      },\n      fn: function(handlerId, args) {\n        return eventListeners[handlerId].apply(null, args);\n      }\n    }\n  });\n  remoteExists = postmaster.remoteTarget();\n  applicationTarget = {\n    observeSignal: function(name, handler) {\n      var observable;\n      observable = Observable();\n      externalObservables[name] = observable;\n      observable.observe(handler);\n      return postmaster.send(\"application\", \"observeSignal\", name).then(handler);\n    }\n  };\n  applicationProxy = new Proxy(applicationTarget, {\n    get: function(target, property, receiver) {\n      return target[property] || function() {\n        if (!remoteExists) {\n          return;\n        }\n        return postmaster.send.apply(postmaster, [\"application\", property].concat(__slice.call(arguments)));\n      };\n    },\n    set: function(target, property, value, receiver) {\n      if (property === \"delegate\") {\n        heldApplicationMessages.forEach(function(fn) {\n          return fn(value);\n        });\n        heldApplicationMessages = [];\n      }\n      target[property] = value;\n      return target[property];\n    }\n  });\n  lastEventListenerId = 0;\n  eventListeners = {};\n  readyPromise = null;\n  hostTarget = {\n    ready: function() {\n      if (readyPromise) {\n        return readyPromise;\n      }\n      if (remoteExists) {\n        return readyPromise = postmaster.send(\"ready\", {\n          ZineOSClient: version,\n          token: postmaster.token\n        }).then(function(hostConfig) {\n          var appData;\n          appData = hostConfig != null ? hostConfig.ZineOS : void 0;\n          if (appData) {\n            initializeOnZineOS(appData);\n          }\n          return hostConfig;\n        });\n      } else {\n        polyfillForStandalone();\n        return readyPromise = Promise.resolve({\n          standalone: true\n        });\n      }\n    },\n    on: function(eventName, handler) {\n      lastEventListenerId += 1;\n      eventListeners[lastEventListenerId] = handler;\n      return postmaster.send(\"system\", \"on\", eventName, lastEventListenerId);\n    },\n    off: function(eventName, handler) {\n      var handlerId;\n      handlerId = Object.keys(eventListeners).filter(function(id) {\n        return eventListeners[id] === handler;\n      })[0];\n      delete eventListeners[handlerId];\n      return postmaster.send(\"system\", \"off\", eventName, handlerId);\n    }\n  };\n  hostTarget.target = hostTarget;\n  polyfillForStandalone = function() {\n    return Object.assign(hostTarget, {\n      readFile: function(path) {\n        return fetch(path).then(function(response) {\n          var _ref1;\n          if ((200 <= (_ref1 = response.status) && _ref1 < 300)) {\n            return response.blob();\n          } else {\n            throw new Error(response.statusText);\n          }\n        });\n      },\n      writeFile: function(path, blob) {\n        return blob.download(path);\n      }\n    });\n  };\n  host = new Proxy(hostTarget, {\n    get: function(target, property, receiver) {\n      if (Object.prototype.hasOwnProperty.call(target, property)) {\n        return target[property];\n      } else {\n        return function() {\n          return postmaster.send.apply(postmaster, [\"system\", property].concat(__slice.call(arguments)));\n        };\n      }\n    }\n  });\n  initializeOnZineOS = function(_arg) {\n    var id;\n    id = _arg.id;\n    applicationTarget.id = id;\n    return document.addEventListener(\"mousedown\", function() {\n      return applicationProxy.raiseToTop()[\"catch\"](console.warn);\n    });\n  };\n  BaseApp = require(\"./app/index\")(host, applicationProxy);\n  client = {\n    postmaster: postmaster\n  };\n  Object.assign(system, {\n    app: {\n      Base: BaseApp\n    },\n    client: client,\n    config: {},\n    host: host,\n    readFile: function() {\n      return host.readFile.apply(host, arguments);\n    },\n    readTree: function() {\n      return host.readTree.apply(host, arguments);\n    },\n    writeFile: function() {\n      return host.writeFile.apply(host, arguments);\n    }\n  });\n  return {\n    application: applicationProxy,\n    system: system\n  };\n};\n\nmodule.exports = Runtime;\n"},"lib/test/app/index":{"content":"var AppGen, BaseApp, Observable, appProxyMock;\n\nObservable = require(\"/lib/ui/index\").Observable;\n\nAppGen = require(\"/lib/app/index\");\n\nappProxyMock = {};\n\nBaseApp = AppGen({}, appProxyMock);\n\ndescribe(\"App\", function() {\n  it(\"should provide a base app constructor\", function() {\n    return assert(BaseApp());\n  });\n  it(\"should work standalone\", function() {\n    return (function(oldSystem) {\n      global.system = {\n        config: {\n          standalone: true\n        }\n      };\n      assert(BaseApp());\n      return global.system = oldSystem;\n    })(system);\n  });\n  it(\"should add a hotkey\", function() {\n    var app, called, e;\n    app = BaseApp();\n    called = 0;\n    app.hotkey(\"a\", function(e) {\n      return called++;\n    });\n    e = new KeyboardEvent('keypress', {\n      keyCode: 97\n    });\n    document.dispatchEvent(e);\n    return assert.equal(called, 1);\n  });\n  it(\"should extend\", function() {\n    var app;\n    app = BaseApp();\n    app.extend({\n      cool: \"duder\"\n    });\n    return assert.equal(app.cool, \"duder\");\n  });\n  it(\"should include bindable\", function() {\n    var app;\n    app = BaseApp();\n    assert(app.on);\n    assert(app.off);\n    return assert(app.trigger);\n  });\n  it(\"should set title and icon\", function() {\n    var app, icon, saved, title;\n    saved = icon = title = null;\n    appProxyMock.title = function(_title) {\n      return title = _title;\n    };\n    appProxyMock.icon = function(_icon) {\n      return icon = _icon;\n    };\n    appProxyMock.saved = function(_saved) {\n      return saved = _saved;\n    };\n    app = BaseApp({\n      title: \"yolo\",\n      icon: \"R\",\n      saved: false\n    });\n    app.trigger('boot');\n    assert.equal(icon, \"R\");\n    assert.equal(title, \"yolo\");\n    return assert.equal(saved, false);\n  });\n  it(\"should pass on observable title changes\", function() {\n    var app, title;\n    title = null;\n    appProxyMock.title = function(_title) {\n      return title = _title;\n    };\n    app = BaseApp({\n      title: Observable(\"wat\")\n    });\n    app.trigger('boot');\n    assert.equal(title, \"wat\");\n    app.title(\"cool\");\n    return assert.equal(title, \"cool\");\n  });\n  return it(\"should apply app template by default on boot and remove on dispose\", function() {\n    var app;\n    app = BaseApp({\n      T: {\n        App: system.ui.Jadelet.exec(\"app Hello\")\n      },\n      menu: \"Hello\\n  Wat\"\n    });\n    app.trigger('boot');\n    assert(document.querySelector('app'));\n    app.trigger('dispose');\n    return assert(!document.querySelector('app'));\n  });\n});\n"},"lib/test/app/template-loader":{"content":"var TemplateLoader;\n\nrequire(\"/setup\");\n\nTemplateLoader = require(\"/lib/app/template-loader\");\n\ndescribe(\"template loader\", function() {\n  return it(\"should load templates\", function() {\n    var tl;\n    tl = TemplateLoader(PACKAGE);\n    return assert(tl.Progress);\n  });\n});\n"},"lib/test/assert":{"content":"\n"},"lib/test/aws/_lazy":{"content":"\n"},"lib/test/aws/cognito":{"content":"var Cognito, S3FS, cognito, config;\n\nCognito = require(\"/lib/aws/cognito\");\n\nconfig = PACKAGE.config.cognito;\n\ncognito = Cognito(config);\n\nS3FS = require(\"/lib/fs/s3\");\n\nmocha.setup({\n  globals: ['AWSCognito', 'AmazonCognitoIdentity', 'AWS']\n});\n\ndescribe(\"Cognito\", function() {\n  describe.skip(\"Remote calls\", function() {\n    it(\"should authenticate\", function() {\n      this.timeout(5000);\n      console.log(config);\n      return cognito.authenticate(\"daniel+test@danielx.net\", \"yo yo yo\");\n    });\n    return it(\"should reject with invalid password\", function(done) {\n      cognito.authenticate(\"daniel+test@danielx.net\", \"not the password\")[\"catch\"](function(e) {\n        assert.equal(e.code, \"NotAuthorizedException\");\n        assert.equal(e.statusCode, 400);\n        return done();\n      });\n    });\n  });\n  return it(\"shouldn't throw an error on logout even when sandboxed\", function() {\n    return cognito.logout();\n  });\n});\n\ndescribe.skip(\"S3FS\", function() {\n  return it(\"should auth with cognito and gate api requests to the same path\", function() {\n    this.timeout(5000);\n    return cognito.authenticate(\"daniel+test@danielx.net\", \"yo yo yo\").then(function() {\n      var bucket, fs, id, refreshCredentials;\n      id = AWS.config.credentials.identityId;\n      bucket = new AWS.S3({\n        params: {\n          Bucket: \"whimsy-fs\"\n        }\n      });\n      refreshCredentials = function() {\n        return cognito.cachedUser().then(function(AWS) {\n          return bucket.config.credentials = AWS.config.credentials;\n        })[\"catch\"](console.debug);\n      };\n      fs = S3FS(id, bucket, refreshCredentials);\n      fs.list(\"/\");\n      fs.list(\"/\");\n      fs.list(\"/\");\n      fs.list(\"/\");\n      fs.list(\"/\");\n      fs.list(\"/\");\n      fs.list(\"/\");\n      fs.list(\"/\");\n      fs.list(\"/\");\n      fs.list(\"/\");\n      fs.list(\"/\");\n      fs.list(\"/public\");\n      fs.list(\"/public\");\n      return fs.list(\"/public\");\n    });\n  });\n});\n"},"lib/test/aws/index":{"content":"var Cognito, api, cdn, cognito, config, ready, _ref;\n\nrequire(\"/lib/extensions\");\n\n_ref = require(\"/lib/aws/index\"), api = _ref.api, cdn = _ref.cdn, ready = _ref.ready;\n\nCognito = require(\"/lib/aws/cognito\");\n\nconfig = PACKAGE.config.cognito;\n\ncognito = Cognito(config);\n\nmocha.setup({\n  globals: ['AWSCognito', 'AmazonCognitoIdentity', 'AWS']\n});\n\ndescribe.skip(\"AWS\", function() {\n  it(\"cdn\", function() {\n    var blob;\n    this.timeout(30000);\n    blob = new Blob([\"heyy234\"], {\n      type: \"text/plain\"\n    });\n    return cognito.authenticate(\"daniel+test@danielx.net\", \"yo yo yo\").then(function() {\n      return cdn(blob);\n    });\n  });\n  it(\"api\", function() {\n    this.timeout(5000);\n    return cognito.authenticate(\"daniel+test@danielx.net\", \"yo yo yo\").then(function() {\n      return api(\"\");\n    });\n  });\n  return it(\"ready\", function() {\n    return ready();\n  });\n});\n"},"lib/test/bindable":{"content":"var Bindable, equal, ok, test,\n  __slice = [].slice;\n\ntest = it;\n\nok = assert;\n\nequal = assert.equal;\n\nBindable = require(\"../bindable\");\n\ndescribe(\"Bindable\", function() {\n  test(\"#on and #trigger\", function() {\n    var o;\n    o = Bindable();\n    o.on(\"test\", function() {\n      return ok(true);\n    });\n    return o.trigger(\"test\");\n  });\n  test(\"Multiple bindings\", function() {\n    var o;\n    o = Bindable();\n    o.on(\"test\", function() {\n      return ok(true);\n    });\n    o.on(\"test\", function() {\n      return ok(true);\n    });\n    return o.trigger(\"test\");\n  });\n  test(\"#trigger arguments\", function() {\n    var o, param1, param2;\n    o = Bindable();\n    param1 = \"the message\";\n    param2 = 3;\n    o.on(\"test\", function(p1, p2) {\n      equal(p1, param1);\n      return equal(p2, param2);\n    });\n    return o.trigger(\"test\", param1, param2);\n  });\n  test(\"#off\", function() {\n    var callback, o;\n    o = Bindable();\n    callback = function() {\n      return ok(false);\n    };\n    o.on(\"test\", callback);\n    o.off(\"test\", callback);\n    o.trigger(\"test\");\n    o.on(\"test\", callback);\n    o.off(\"test\");\n    return o.trigger(\"test\");\n  });\n  return test(\"* events\", function() {\n    var called, o;\n    o = Bindable();\n    called = 0;\n    o.on(\"*\", function() {\n      var event, rest;\n      event = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      called += 1;\n      if (called === 1) {\n        assert.equal(event, \"edit\");\n        assert.equal(rest[0], \"cool\");\n        return assert.equal(rest[1], 5);\n      }\n    });\n    o.trigger(\"edit\", \"cool\", 5);\n    return assert.equal(called, 1);\n  });\n});\n"},"lib/test/core":{"content":"var Model;\n\nModel = require(\"../core\");\n\ndescribe('Model', function() {\n  var Person;\n  Person = function(I) {\n    var person;\n    person = Model(I);\n    person.attrObservable('firstName', 'lastName', 'suffix');\n    person.fullName = function() {\n      return \"\" + (this.firstName()) + \" \" + (this.lastName()) + \" \" + (this.suffix());\n    };\n    return person;\n  };\n  it(\"#extend\", function() {\n    var o;\n    o = Model();\n    o.extend({\n      test: \"jawsome\"\n    });\n    return assert.equal(o.test, \"jawsome\");\n  });\n  it(\"#include\", function() {\n    var M, o, ret;\n    o = Model({\n      test: \"my_val\"\n    });\n    M = function(I, self) {\n      self.attrObservable(\"test\");\n      return self.extend({\n        test2: \"cool\"\n      });\n    };\n    ret = o.include(M);\n    assert.equal(ret, o, \"Should return self\");\n    assert.equal(o.test(), \"my_val\");\n    return assert.equal(o.test2, \"cool\");\n  });\n  it(\"#include multiple\", function() {\n    var M, M2, o;\n    o = Model({\n      test: \"my_val\"\n    });\n    M = function(I, self) {\n      return self.extend({\n        test2: \"cool\"\n      });\n    };\n    M2 = function(I, self) {\n      return self.extend({\n        test2: \"coolio\"\n      });\n    };\n    o.include(M, M2);\n    return assert.equal(o.test2, \"coolio\");\n  });\n  describe(\"#attrData\", function() {\n    var Point, pointProto;\n    pointProto = {\n      add: function(_arg) {\n        var x, y;\n        x = _arg.x, y = _arg.y;\n        this.x += x;\n        return this.y += y;\n      }\n    };\n    Point = function(_arg) {\n      var x, y;\n      x = _arg.x, y = _arg.y;\n      return Object.create(pointProto, {\n        x: {\n          value: x\n        },\n        y: {\n          value: y\n        }\n      });\n    };\n    return it(\"should expose a property mapping to the instance data\", function() {\n      var model;\n      model = Model({\n        position: {\n          x: 5,\n          y: 5\n        }\n      });\n      model.attrData(\"position\", Point);\n      assert(model.position.add);\n      model.position.x = 12;\n      assert.equal(model.position.x, model.I.position.x);\n      model.position = {\n        x: 9,\n        y: 6\n      };\n      assert.equal(model.position.y, 6);\n      return assert.equal(model.I.position.x, 9);\n    });\n  });\n  describe(\"#attrObservable\", function() {\n    it('should allow for observing of attributes', function() {\n      var model;\n      model = Model({\n        name: \"Duder\"\n      });\n      model.attrObservable(\"name\");\n      model.name(\"Dudeman\");\n      return assert.equal(model.name(), \"Dudeman\");\n    });\n    return it('should bind properties to observable attributes', function() {\n      var model;\n      model = Model({\n        name: \"Duder\"\n      });\n      model.attrObservable(\"name\");\n      model.name(\"Dudeman\");\n      assert.equal(model.name(), \"Dudeman\");\n      return assert.equal(model.name(), model.I.name);\n    });\n  });\n  describe(\"#attrModel\", function() {\n    it(\"should be a model instance\", function() {\n      var model;\n      model = Model({\n        person: {\n          firstName: \"Duder\",\n          lastName: \"Mannington\",\n          suffix: \"Jr.\"\n        }\n      });\n      model.attrModel(\"person\", Person);\n      return assert.equal(model.person().fullName(), \"Duder Mannington Jr.\");\n    });\n    it(\"should allow setting the associated model\", function() {\n      var model, otherPerson;\n      model = Model({\n        person: {\n          firstName: \"Duder\",\n          lastName: \"Mannington\",\n          suffix: \"Jr.\"\n        }\n      });\n      model.attrModel(\"person\", Person);\n      otherPerson = Person({\n        firstName: \"Mr.\",\n        lastName: \"Man\"\n      });\n      model.person(otherPerson);\n      return assert.equal(model.person().firstName(), \"Mr.\");\n    });\n    return it(\"shouldn't update the instance properties after it's been replaced\", function() {\n      var duder, model, otherPerson;\n      model = Model({\n        person: {\n          firstName: \"Duder\",\n          lastName: \"Mannington\",\n          suffix: \"Jr.\"\n        }\n      });\n      model.attrModel(\"person\", Person);\n      duder = model.person();\n      otherPerson = Person({\n        firstName: \"Mr.\",\n        lastName: \"Man\"\n      });\n      model.person(otherPerson);\n      duder.firstName(\"Joe\");\n      assert.equal(duder.I.firstName, \"Joe\");\n      return assert.equal(model.I.person.firstName, \"Mr.\");\n    });\n  });\n  describe(\"#attrModels\", function() {\n    it(\"should have an array of model instances\", function() {\n      var model;\n      model = Model({\n        people: [\n          {\n            firstName: \"Duder\",\n            lastName: \"Mannington\",\n            suffix: \"Jr.\"\n          }, {\n            firstName: \"Mr.\",\n            lastName: \"Mannington\",\n            suffix: \"Sr.\"\n          }\n        ]\n      });\n      model.attrModels(\"people\", Person);\n      return assert.equal(model.people()[0].fullName(), \"Duder Mannington Jr.\");\n    });\n    it(\"should track pushes\", function() {\n      var model;\n      model = Model({\n        people: [\n          {\n            firstName: \"Duder\",\n            lastName: \"Mannington\",\n            suffix: \"Jr.\"\n          }, {\n            firstName: \"Mr.\",\n            lastName: \"Mannington\",\n            suffix: \"Sr.\"\n          }\n        ]\n      });\n      model.attrModels(\"people\", Person);\n      model.people.push(Person({\n        firstName: \"JoJo\",\n        lastName: \"Loco\"\n      }));\n      assert.equal(model.people().length, 3);\n      return assert.equal(model.I.people.length, 3);\n    });\n    return it(\"should track pops\", function() {\n      var model;\n      model = Model({\n        people: [\n          {\n            firstName: \"Duder\",\n            lastName: \"Mannington\",\n            suffix: \"Jr.\"\n          }, {\n            firstName: \"Mr.\",\n            lastName: \"Mannington\",\n            suffix: \"Sr.\"\n          }\n        ]\n      });\n      model.attrModels(\"people\", Person);\n      model.people.pop();\n      assert.equal(model.people().length, 1);\n      return assert.equal(model.I.people.length, 1);\n    });\n  });\n  describe(\"#delegate\", function() {\n    it(\"should delegate to another method\", function() {\n      var model;\n      model = Model({\n        position: {\n          x: 1,\n          y: 2,\n          z: 3\n        }\n      });\n      model.attrObservable(\"position\");\n      model.delegate(\"x\", \"y\", \"z\", {\n        to: \"position\"\n      });\n      assert.equal(model.x, 1);\n      assert.equal(model.y, 2);\n      assert.equal(model.z, 3);\n      model.x = 5;\n      assert.equal(model.position().x, 5);\n      return assert.equal(model.I.position.x, 5);\n    });\n    it(\"should delegate to another property\", function() {\n      var model;\n      model = Model({\n        position: {\n          x: 1,\n          y: 2,\n          z: 3\n        }\n      });\n      model.position = model.I.position;\n      model.delegate(\"x\", \"y\", \"z\", {\n        to: \"position\"\n      });\n      assert.equal(model.x, 1);\n      assert.equal(model.y, 2);\n      assert.equal(model.z, 3);\n      model.x = 5;\n      assert.equal(model.position.x, 5);\n      return assert.equal(model.I.position.x, 5);\n    });\n    return it(\"should delegate to methods just fine\", function() {\n      var model;\n      model = Model({\n        size: {\n          width: 10,\n          height: 20\n        }\n      });\n      model.attrData(\"size\", function(_arg) {\n        var height, width;\n        width = _arg.width, height = _arg.height;\n        return {\n          width: function() {\n            return width;\n          },\n          height: function() {\n            return height;\n          }\n        };\n      });\n      model.delegate(\"width\", \"height\", {\n        to: \"size\"\n      });\n      assert.equal(model.width(), 10);\n      return assert.equal(model.height(), 20);\n    });\n  });\n  describe(\"#toJSON\", function() {\n    return it(\"should return an object appropriate for JSON serialization\", function() {\n      var model;\n      model = Model({\n        test: true\n      });\n      return assert(model.toJSON().test);\n    });\n  });\n  describe(\"#observeAll\", function() {\n    it(\"should observe all attributes of a simple model\");\n    (function() {\n      var model;\n      model = Model({\n        test: true,\n        yolo: \"4life\"\n      });\n      model.observeAll();\n      assert(model.test());\n      return assert.equal(model.yolo(), \"4life\");\n    });\n    return it(\"should camel case underscored names\");\n  });\n  describe(\".defaults\", function() {\n    return it(\"should expose defaults method\", function() {\n      return assert(Model.defaults);\n    });\n  });\n  return describe(\".extend\", function() {\n    return it(\"should expose extend method\", function() {\n      return assert(Model.extend);\n    });\n  });\n});\n"},"lib/test/exp/core-state":{"content":"var Core;\n\nCore = require(\"/lib/exp/core-state\");\n\ndescribe('Core', function() {\n  var Person;\n  Person = function(self) {\n    var person;\n    person = Core(self);\n    person.attrObservable('firstName', 'lastName', 'suffix');\n    person.fullName = function() {\n      return \"\" + (this.firstName()) + \" \" + (this.lastName()) + \" \" + (this.suffix());\n    };\n    return person;\n  };\n  it(\"#extend\", function() {\n    var o;\n    o = Core();\n    o.extend({\n      test: \"jawsome\"\n    });\n    return assert.equal(o.test, \"jawsome\");\n  });\n  it(\"#include\", function() {\n    var M, o, ret;\n    o = Core({\n      __state: {\n        test: \"my_val\"\n      }\n    });\n    M = function(self) {\n      return self.extend({\n        test2: \"cool\",\n        test: function() {\n          return self.__state.test;\n        }\n      });\n    };\n    ret = o.include(M);\n    assert.equal(ret, o, \"Should return self\");\n    assert.equal(o.test(), \"my_val\");\n    return assert.equal(o.test2, \"cool\");\n  });\n  it(\"#include multiple\", function() {\n    var M, M2, o;\n    o = Core({\n      test: \"my_val\"\n    });\n    M = function(self) {\n      return self.extend({\n        test2: \"cool\"\n      });\n    };\n    M2 = function(self) {\n      return self.extend({\n        test2: \"coolio\"\n      });\n    };\n    o.include(M, M2);\n    return assert.equal(o.test2, \"coolio\");\n  });\n  describe(\"#attrData\", function() {\n    var Point, pointProto;\n    pointProto = {\n      add: function(_arg) {\n        var x, y;\n        x = _arg.x, y = _arg.y;\n        this.x += x;\n        return this.y += y;\n      }\n    };\n    Point = function(_arg) {\n      var x, y;\n      x = _arg.x, y = _arg.y;\n      return Object.create(pointProto, {\n        x: {\n          value: x\n        },\n        y: {\n          value: y\n        }\n      });\n    };\n    return it(\"should expose a property mapping to the instance data\", function() {\n      var model;\n      model = Core({\n        __state: {\n          position: {\n            x: 5,\n            y: 5\n          }\n        }\n      });\n      model.attrData(\"position\", Point);\n      assert(model.position.add);\n      model.position.x = 12;\n      assert.equal(model.position.x, model.__state.position.x);\n      model.position = {\n        x: 9,\n        y: 6\n      };\n      assert.equal(model.position.y, 6);\n      return assert.equal(model.__state.position.x, 9);\n    });\n  });\n  describe(\"#attrObservable\", function() {\n    it('should allow for observing of attributes', function() {\n      var model;\n      model = Core({\n        name: \"Duder\"\n      });\n      model.attrObservable(\"name\");\n      model.name(\"Dudeman\");\n      return assert.equal(model.name(), \"Dudeman\");\n    });\n    return it('should bind properties to observable attributes', function() {\n      var model;\n      model = Core({\n        name: \"Duder\"\n      });\n      model.attrObservable(\"name\");\n      model.name(\"Dudeman\");\n      assert.equal(model.name(), \"Dudeman\");\n      return assert.equal(model.name(), model.__state.name);\n    });\n  });\n  describe(\"#attrModel\", function() {\n    it(\"should be a model instance\", function() {\n      var model;\n      model = Core({\n        __state: {\n          person: {\n            firstName: \"Duder\",\n            lastName: \"Mannington\",\n            suffix: \"Jr.\"\n          }\n        }\n      });\n      model.attrModel(\"person\", Person);\n      return assert.equal(model.person().fullName(), \"Duder Mannington Jr.\");\n    });\n    it(\"should allow setting the associated model\", function() {\n      var model, otherPerson;\n      model = Core({\n        __state: {\n          person: {\n            firstName: \"Duder\",\n            lastName: \"Mannington\",\n            suffix: \"Jr.\"\n          }\n        }\n      });\n      model.attrModel(\"person\", Person);\n      otherPerson = Person({\n        __state: {\n          firstName: \"Mr.\",\n          lastName: \"Man\"\n        }\n      });\n      model.person(otherPerson);\n      return assert.equal(model.person().firstName(), \"Mr.\");\n    });\n    return it(\"shouldn't update the instance properties after it's been replaced\", function() {\n      var duder, model, otherPerson;\n      model = Core({\n        __state: {\n          person: {\n            firstName: \"Duder\",\n            lastName: \"Mannington\",\n            suffix: \"Jr.\"\n          }\n        }\n      });\n      model.attrModel(\"person\", Person);\n      duder = model.person();\n      otherPerson = Person({\n        __state: {\n          firstName: \"Mr.\",\n          lastName: \"Man\"\n        }\n      });\n      model.person(otherPerson);\n      duder.firstName(\"Joe\");\n      assert.equal(duder.__state.firstName, \"Joe\");\n      return assert.equal(model.__state.person.firstName, \"Mr.\");\n    });\n  });\n  describe(\"#attrModels\", function() {\n    it(\"should have an array of model instances\", function() {\n      var model;\n      model = Core({\n        __state: {\n          people: [\n            {\n              firstName: \"Duder\",\n              lastName: \"Mannington\",\n              suffix: \"Jr.\"\n            }, {\n              firstName: \"Mr.\",\n              lastName: \"Mannington\",\n              suffix: \"Sr.\"\n            }\n          ]\n        }\n      });\n      model.attrModels(\"people\", Person);\n      return assert.equal(model.people()[0].fullName(), \"Duder Mannington Jr.\");\n    });\n    it(\"should track pushes\", function() {\n      var model;\n      model = Core({\n        __state: {\n          people: [\n            {\n              firstName: \"Duder\",\n              lastName: \"Mannington\",\n              suffix: \"Jr.\"\n            }, {\n              firstName: \"Mr.\",\n              lastName: \"Mannington\",\n              suffix: \"Sr.\"\n            }\n          ]\n        }\n      });\n      model.attrModels(\"people\", Person);\n      model.people.push(Person({\n        firstName: \"JoJo\",\n        lastName: \"Loco\"\n      }));\n      assert.equal(model.people().length, 3);\n      return assert.equal(model.__state.people.length, 3);\n    });\n    return it(\"should track pops\", function() {\n      var model;\n      model = Core({\n        __state: {\n          people: [\n            {\n              firstName: \"Duder\",\n              lastName: \"Mannington\",\n              suffix: \"Jr.\"\n            }, {\n              firstName: \"Mr.\",\n              lastName: \"Mannington\",\n              suffix: \"Sr.\"\n            }\n          ]\n        }\n      });\n      model.attrModels(\"people\", Person);\n      model.people.pop();\n      assert.equal(model.people().length, 1);\n      return assert.equal(model.__state.people.length, 1);\n    });\n  });\n  describe(\"#delegate\", function() {\n    it(\"should delegate to another method\", function() {\n      var model;\n      model = Core({\n        __state: {\n          position: {\n            x: 1,\n            y: 2,\n            z: 3\n          }\n        },\n        position: function() {\n          return model.__state.position;\n        }\n      });\n      model.delegate(\"x\", \"y\", \"z\", {\n        to: \"position\"\n      });\n      assert.equal(model.x, 1);\n      assert.equal(model.y, 2);\n      assert.equal(model.z, 3);\n      model.x = 5;\n      assert.equal(model.position().x, 5);\n      return assert.equal(model.__state.position.x, 5);\n    });\n    it(\"should delegate to another property\", function() {\n      var model;\n      model = Core({\n        __state: {\n          position: {\n            x: 1,\n            y: 2,\n            z: 3\n          }\n        }\n      });\n      model.position = model.__state.position;\n      model.delegate(\"x\", \"y\", \"z\", {\n        to: \"position\"\n      });\n      assert.equal(model.x, 1);\n      assert.equal(model.y, 2);\n      assert.equal(model.z, 3);\n      model.x = 5;\n      assert.equal(model.position.x, 5);\n      return assert.equal(model.__state.position.x, 5);\n    });\n    return it(\"should delegate to methods just fine\", function() {\n      var model;\n      model = Core({\n        __state: {\n          size: {\n            width: 10,\n            height: 20\n          }\n        }\n      });\n      model.attrData(\"size\", function(_arg) {\n        var height, width;\n        width = _arg.width, height = _arg.height;\n        return {\n          width: function() {\n            return width;\n          },\n          height: function() {\n            return height;\n          }\n        };\n      });\n      model.delegate(\"width\", \"height\", {\n        to: \"size\"\n      });\n      assert.equal(model.width(), 10);\n      return assert.equal(model.height(), 20);\n    });\n  });\n  describe(\"#toJSON\", function() {\n    return it(\"should return an object appropriate for JSON serialization\", function() {\n      var model;\n      model = Core({\n        __state: {\n          test: true\n        }\n      });\n      return assert(model.toJSON().test);\n    });\n  });\n  describe(\"#observeAll\", function() {\n    it(\"should observe all attributes of a simple model\");\n    (function() {\n      var model;\n      model = Core({\n        test: true,\n        yolo: \"4life\"\n      });\n      model.observeAll();\n      assert(model.test());\n      return assert.equal(model.yolo(), \"4life\");\n    });\n    return it(\"should camel case underscored names\");\n  });\n  describe(\".defaults\", function() {\n    return it(\"should expose defaults method\", function() {\n      return assert(Core.defaults);\n    });\n  });\n  return describe(\".extend\", function() {\n    return it(\"should expose extend method\", function() {\n      return assert(Core.extend);\n    });\n  });\n});\n"},"lib/test/exports":{"content":"var system;\n\nsystem = require(\"../exports\");\n\ndescribe(\"exports\", function() {\n  it(\"should provide fs\", function() {\n    assert(system.fs);\n    assert(system.fs.Dexie);\n    assert(system.fs.Mount);\n    assert(system.fs.Package);\n    assert(system.fs.S3);\n    return assert(system.aws.Cognito);\n  });\n  it(\"should provide acct.login\", function() {\n    return assert(system.acct.login);\n  });\n  it(\"should provide util\", function() {\n    return assert(system.util.Postmaster);\n  });\n  return it(\"should provide ui\", function() {\n    var Bindable, Drop, Jadelet, Observable, _ref;\n    _ref = system.ui, Bindable = _ref.Bindable, Drop = _ref.Drop, Jadelet = _ref.Jadelet, Observable = _ref.Observable;\n    assert(Bindable);\n    assert(Drop);\n    assert(Jadelet);\n    return assert.equal(typeof Observable, \"function\");\n  });\n});\n"},"lib/test/extensions":{"content":"require(\"../extensions\");\n\ndescribe(\"extensions\", function() {\n  describe(\"Blob\", function() {\n    it(\"should have promise convenience methods\", function() {\n      var b;\n      b = new Blob([\"{}\"]);\n      return b.arrayBuffer().then(function() {\n        return b.json();\n      }).then(function() {\n        return b.text();\n      }).then(function() {\n        return b.dataURL();\n      });\n    });\n    return it(\"should have download method\", function() {\n      return assert(Blob.prototype.download);\n    });\n  });\n  return it(\"should extend native APIs with extensions\", function() {\n    assert(FileList.prototype.forEach);\n    assert(HTMLCollection.prototype.forEach);\n    assert(Image.fromBlob);\n    return assert(JSON.toBlob);\n  });\n});\n"},"lib/test/fs/dexie":{"content":"var DexieFS;\n\nDexieFS = require(\"/lib/fs/dexie\");\n\ndescribe.skip(\"DexieFS\", function() {\n  return it(\"Should use indexeddb as a file system\", function() {\n    var dfs;\n    dfs = DexieFS(\"test\");\n    return dfs.write(\"/test.txt\", new Blob([\"heyy\"])).then(function() {\n      return dfs.read(\"/test.txt\");\n    });\n  });\n});\n"},"lib/test/fs/index":{"content":"\n"},"lib/test/fs/mount":{"content":"var Bindable, MountFS, PkgFS, testPkg, testPkg2;\n\nrequire(\"/setup\");\n\nBindable = require(\"/lib/bindable\");\n\nMountFS = require(\"/lib/fs/mount\");\n\nPkgFS = require(\"/lib/fs/pkg\");\n\ntestPkg = {\n  source: {\n    \"hello.coffee\": {\n      content: \"alert hello\"\n    },\n    \"test/wat.js\": {\n      content: \"assert(wat);\"\n    }\n  }\n};\n\ntestPkg2 = {\n  source: {\n    \"yo.coffee\": {\n      content: \"alert 'ayyy'\"\n    }\n  }\n};\n\ndescribe(\"Mount FS\", function() {\n  it(\"should mount a filesystem\", function() {\n    var fs;\n    fs = MountFS();\n    fs.mount(\"/pkg/\", PkgFS(testPkg));\n    return fs.read(\"/pkg/hello.coffee\").then(function(blob) {\n      return blob.text();\n    }).then(function(src) {\n      return assert.equal(src, \"alert hello\");\n    });\n  });\n  it(\"should mount on top of previous path\", function() {\n    var fs;\n    fs = MountFS();\n    fs.mount(\"/pkg/\", PkgFS(testPkg));\n    fs.mount(\"/pkg/\", PkgFS(testPkg2));\n    return fs.read(\"/pkg/yo.coffee\").then(function(blob) {\n      return blob.text();\n    }).then(function(src) {\n      assert.equal(src, \"alert 'ayyy'\");\n      return fs.list('/pkg/').then(function(files) {\n        assert.equal(files.length, 1);\n        assert.equal(files[0].path, \"/pkg/yo.coffee\");\n        fs.mount(\"/pkg/\", PkgFS(testPkg));\n        fs.mount(\"/pkg/\", PkgFS(testPkg));\n        return fs.list('/pkg/').then(function(files) {\n          assert.equal(files.length, 2);\n          return assert.equal(files[1].path, \"/pkg/hello.coffee\");\n        });\n      });\n    });\n  });\n  it(\"should accept text strings in write method and save them with the proper media type passing options through\", function() {\n    var file, fs, opt;\n    fs = MountFS();\n    file = void 0;\n    opt = void 0;\n    fs.mount(\"/pkg/\", {\n      write: function(path, blob, options) {\n        file = blob;\n        opt = options;\n        return Promise.resolve();\n      },\n      read: function(path) {\n        return Promise.resolve(file);\n      },\n      on: function() {}\n    });\n    return fs.write(\"/pkg/hey.js\", \"alert('hey');\", {\n      cacheControl: 86400\n    }).then(function() {\n      return fs.read(\"/pkg/hey.js\");\n    }).then(function(blob) {\n      assert.equal(blob.type, \"text/javascript; charset=utf-8\");\n      return assert.equal(opt.cacheControl, 86400);\n    });\n  });\n  it(\"should pass through calls to `clearCache`\", function() {\n    var called, fs, mock;\n    fs = MountFS();\n    called = false;\n    mock = {\n      clearCache: function() {\n        return called = true;\n      }\n    };\n    Bindable(null, mock);\n    fs.mount(\"/\", mock);\n    fs.clearCache();\n    return assert(called);\n  });\n  return it.skip(\"should list contents of mounted subfolders\", function() {\n    var fs, mock;\n    fs = MountFS();\n    mock = {\n      list: function() {\n        return Promise.resolve([\n          {\n            path: \"a.txt\"\n          }, {\n            path: \"b.txt\"\n          }\n        ]);\n      }\n    };\n    Bindable(null, mock);\n    fs.mount(\"/game/\", mock);\n    fs.mount(\"/\", mock);\n    return fs.list(\"/\").then(function(results) {\n      return assert.equal(results.length, 4);\n    });\n  });\n});\n"},"lib/test/fs/pkg":{"content":"var PkgFS, oldPersist, testPkg;\n\nPkgFS = require(\"/lib/fs/pkg\");\n\nrequire(\"/lib/extensions\");\n\ntestPkg = {\n  source: {\n    \"hello.coffee\": {\n      content: \"alert hello\"\n    },\n    \"test/wat.js\": {\n      content: \"assert(wat);\"\n    }\n  },\n  distribution: {}\n};\n\noldPersist = function(pkg) {\n  return system.writeFile(persistencePath, JSON.toBlob(pkg));\n};\n\ndescribe(\"Package FS\", function() {\n  it(\"should read files\", function() {\n    var pfs;\n    pfs = PkgFS(testPkg);\n    return pfs.read(\"hello.coffee\").then(function(blob) {\n      return blob.text();\n    }).then(function(src) {\n      return assert.equal(src, \"alert hello\");\n    });\n  });\n  return it(\"should write files\", function() {\n    var compile, compileCalled, content, persist, persistCalled, pfs;\n    persistCalled = false;\n    persist = function() {\n      return persistCalled = true;\n    };\n    compileCalled = false;\n    compile = function(blob) {\n      compileCalled = true;\n      return blob.text();\n    };\n    pfs = PkgFS(testPkg, {\n      persist: persist,\n      compile: compile\n    });\n    content = \"alert('hey');\";\n    return pfs.write(\"/yolo.js\", new Blob([content])).then(function() {\n      assert(compileCalled);\n      assert(persistCalled);\n      assert.equal(testPkg.source[\"yolo.js\"].content, content);\n      return assert.equal(testPkg.distribution[\"yolo\"].content, content);\n    });\n  });\n});\n"},"lib/test/fs/s3":{"content":"var S3FS, bucket;\n\nS3FS = require(\"/lib/fs/s3\");\n\nbucket = {\n  getObject: function(data, cb) {\n    return cb(null);\n  },\n  headObject: function(data, cb) {\n    return cb(null, {\n      ContentType: \"text/plain\",\n      LastModified: \"2021-05-05T01:00:46.000Z\"\n    });\n  },\n  putObject: function(data, cb) {\n    return cb(null);\n  },\n  listObjects: function(data, cb) {\n    return cb(null, {\n      CommonPrefixes: [],\n      Contents: [\n        {\n          Key: \"yo\",\n          Size: 3\n        }\n      ]\n    });\n  }\n};\n\ndescribe(\"S3FS\", function() {\n  return it(\"Should cache the proper date when writing then listing\", function() {\n    var fs, id, refreshCredentials;\n    id = \"wat\";\n    refreshCredentials = function() {};\n    fs = S3FS(id, bucket, refreshCredentials);\n    return fs.write(\"yo\", new Blob(['hey'])).then(function() {\n      return fs.list();\n    }).then(function(entries) {\n      return assert.notEqual(entries[0].updatedAt.toString(), \"Invalid Date\");\n    });\n  });\n});\n"},"lib/test/fs/util":{"content":"var absolutizePath, baseDirectory, extensionFor, isRelativePath, normalizePath, textMediaType, withoutAllExtensions, withoutExtension, _ref;\n\n_ref = require(\"/lib/fs/index\"), absolutizePath = _ref.absolutizePath, baseDirectory = _ref.baseDirectory, extensionFor = _ref.extensionFor, isRelativePath = _ref.isRelativePath, textMediaType = _ref.textMediaType, normalizePath = _ref.normalizePath, withoutExtension = _ref.withoutExtension, withoutAllExtensions = _ref.withoutAllExtensions;\n\ndescribe(\"fs\", function() {\n  return describe(\"util\", function() {\n    it(\"should absolutize paths\", function() {\n      assert.equal(absolutizePath(\"/Home/\", \"app.config\"), \"/Home/app.config\");\n      assert.equal(absolutizePath(\"/Home/\", \"something/../app.config\"), \"/Home/app.config\");\n      assert.equal(absolutizePath(\"/Home/\", \"/something/../app.config\"), \"/Home/app.config\");\n      assert.equal(absolutizePath(\"/Home//\", \"///./app.config\"), \"/Home/app.config\");\n      return assert.equal(absolutizePath(\"/Home/./\", \"///./app.config\"), \"/Home/app.config\");\n    });\n    it(\"should error when escaping base dir\", function() {\n      return assert.throws(function() {\n        return absolutizePath(\"/Home/\", \"../app.config\");\n      });\n    });\n    it(\"should normalize paths\", function() {\n      assert.equal(normalizePath(\"///./app.config\"), \"/app.config\");\n      assert.equal(normalizePath(\"/yolo/.././/./app.config\"), \"/app.config\");\n      assert.equal(normalizePath(\"yolo/rad/..//./app.config\"), \"yolo/app.config\");\n      assert.equal(normalizePath(\"/public/danielx.net/..\"), \"/public/\");\n      assert.equal(normalizePath(\"/public/danielx.net/.\"), \"/public/danielx.net/\");\n      return assert.equal(normalizePath(\"/public/..weird/danielx.net/\"), \"/public/..weird/danielx.net/\");\n    });\n    it(\"should normalize strage cases\", function() {\n      assert.equal(normalizePath(\"./\"), \"./\");\n      return assert.equal(normalizePath(\"./cool\"), \"./cool\");\n    });\n    it.skip(\"should throw an error when there is no parent directory\", function() {\n      assert.throws(function() {\n        return normalizePath(\"/../danielx.net/\");\n      });\n      assert.throws(function() {\n        return normalizePath(\"./..\");\n      });\n      return assert.throws(function() {\n        return normalizePath(\"/./..\");\n      });\n    });\n    it(\"should know relative paths\", function() {\n      assert.equal(isRelativePath(\"../yo.txt\"), true);\n      assert.equal(isRelativePath(\"./yo.md\"), true);\n      return assert.equal(isRelativePath(\"/Home/yo\"), false);\n    });\n    describe(\"baseDirectory\", function() {\n      it(\"should resolve base directories\", function() {\n        assert.equal(baseDirectory(\"/Home/\"), \"/Home/\");\n        assert.equal(baseDirectory(\"/Home/cool.gif\"), \"/Home/\");\n        return assert.equal(baseDirectory(\"folder/sub/cool.gif\"), \"folder/sub/\");\n      });\n      return it(\"should have base directory undefined if no folder\", function() {\n        return assert.equal(baseDirectory(\"just-a-file.js\"), void 0);\n      });\n    });\n    describe(\"extensionFor\", function() {\n      it(\"should give extensios\", function() {\n        assert.equal(extensionFor(\"home/rad.js\"), \"js\");\n        return assert.equal(extensionFor(\"home/rad.js.md\"), \"md\");\n      });\n      return it(\"should handle directories with a dot\", function() {\n        assert.equal(extensionFor(\"home.app/md\"), \"\");\n        return assert.equal(extensionFor(\"home.app/cool.md\"), \"md\");\n      });\n    });\n    describe(\"textMediaType\", function() {\n      return it(\"should return the proper mime types\", function() {\n        assert.equal(textMediaType(\"cool.html\"), \"text/html; charset=utf-8\");\n        assert.equal(textMediaType(\"sick.js\"), \"text/javascript; charset=utf-8\");\n        assert.equal(textMediaType(\"noice.json\"), \"application/json; charset=utf-8\");\n        assert.equal(textMediaType(\"rad.txt\"), \"text/plain; charset=utf-8\");\n        assert.equal(textMediaType(\"lit.md\"), \"text/markdown; charset=utf-8\");\n        assert.equal(textMediaType(\"yo.coffee\"), \"text/plain; charset=utf-8\");\n        assert.equal(textMediaType(\"style.styl\"), \"text/plain; charset=utf-8\");\n        return assert.equal(textMediaType(\"heyy.webm\"), \"text/plain; charset=utf-8\");\n      });\n    });\n    describe(\"withoutExtension\", function() {\n      return it(\"should remove extensions\", function() {\n        assert.equal(withoutExtension(\"cool/file.ab.c\"), \"cool/file.ab\");\n        assert.equal(withoutExtension(\"but.why/file.ab.c\"), \"but.why/file.ab\");\n        return assert.equal(withoutExtension(\"but.why/file\"), \"but.why/file\");\n      });\n    });\n    return describe(\"withoutAllExtensions\", function() {\n      return it(\"should remove extensions\", function() {\n        assert.equal(withoutAllExtensions(\"cool/file.ab.c\"), \"cool/file\");\n        assert.equal(withoutAllExtensions(\"but.why/file.ab.c\"), \"but.why/file\");\n        return assert.equal(withoutExtension(\"but.why/file\"), \"but.why/file\");\n      });\n    });\n  });\n});\n"},"lib/test/indent-parse":{"content":"\n"},"lib/test/jadelet":{"content":"var Jadelet, Observable, dispatchEvent, makeTemplate, parser, sampleTemplate;\n\nObservable = require(\"../observable\");\n\nJadelet = require(\"../jadelet\");\n\nparser = require(\"../jadelet-parser\");\n\nsampleTemplate = \"p\\n  a(@click wat=@cool @butts)\\n    @text\\n    span Cool\\n    @text2\";\n\nmakeTemplate = function(src) {\n  return Jadelet.exec(src);\n};\n\ndispatchEvent = function(element, eventName, options) {\n  if (options == null) {\n    options = {};\n  }\n  return element.dispatchEvent(new Event(eventName, options));\n};\n\n\n/*\nAST is a tree of objects like:\n\n    [tag, attributes, children]\n */\n\ndescribe(\"Jadelet Runtime\", function() {\n  it(\"should render\", function() {\n    var ast, model, p;\n    model = {\n      cool: \"radical\",\n      butts: function() {\n        return \"yolo\";\n      },\n      text: Observable([\"hollo world\", \" \", \"yo\", \" \", \"yo\"]),\n      text2: Observable([\"yo wat\"])\n    };\n    ast = parser.parse(sampleTemplate);\n    p = Jadelet.exec(ast)(model);\n    assert.equal(p.textContent, \"hollo world yo yoCoolyo wat\");\n    model.text(\"yolo \");\n    assert.equal(p.textContent, \"yolo Coolyo wat\");\n    model.text2(\"rad\");\n    return assert.equal(p.textContent, \"yolo Coolrad\");\n  });\n  it(\"should compile strings\", function() {\n    var el, template;\n    template = Jadelet.exec(\"h1 yolo\");\n    el = template();\n    return assert.equal(el.textContent, \"yolo\");\n  });\n  return it(\"should return functions passed to exec\", function() {\n    var el, template;\n    template = Jadelet.exec(Jadelet.exec(\"h1 yolo\"));\n    el = template();\n    return assert.equal(el.textContent, \"yolo\");\n  });\n});\n\ndescribe(\"Attributes\", function() {\n  it(\"should bind to the property with the same name\", function(done) {\n    var button, model, template;\n    template = makeTemplate(\"button(@click) Test\");\n    model = {\n      click: function() {\n        return done();\n      }\n    };\n    button = template(model);\n    return button.click();\n  });\n  it(\"should work with multiple attributes\", function() {\n    var button, model, template;\n    template = makeTemplate(\"button(before=\\\"low\\\" @type middle=\\\"mid\\\" @yolo after=\\\"hi\\\") Test\");\n    model = {\n      type: \"submit\",\n      yolo: \"Hello\"\n    };\n    button = template(model);\n    assert.equal(button.getAttribute(\"type\"), \"submit\");\n    return assert.equal(button.getAttribute(\"yolo\"), \"Hello\");\n  });\n  return it(\"shoud not be present when false or undefined\", function() {\n    var button, model, template;\n    template = makeTemplate(\"button(@disabled) Test\");\n    model = {\n      disabled: Observable(false)\n    };\n    button = template(model);\n    assert.equal(button.getAttribute(\"disabled\"), void 0);\n    model.disabled(true);\n    return assert.equal(button.getAttribute(\"disabled\"), \"true\");\n  });\n});\n\ndescribe(\"Checkbox\", function() {\n  var template;\n  template = makeTemplate(\"input(type='checkbox' checked=@checked)\");\n  it(\"should be checked\", function() {\n    var input, model;\n    model = {\n      checked: true\n    };\n    input = template(model);\n    return assert.equal(input.checked, true);\n  });\n  it(\"should not be checked\", function() {\n    var input, model;\n    model = {\n      checked: false\n    };\n    input = template(model);\n    return assert.equal(input.checked, false);\n  });\n  return it(\"should track changes in the observable\", function() {\n    var input, model;\n    model = {\n      checked: Observable(false)\n    };\n    input = template(model);\n    assert.equal(input.checked, false, \"Should not be checked\");\n    model.checked(true);\n    assert.equal(input.checked, true, \"Should be checked\");\n    model.checked(false);\n    assert.equal(input.checked, false, \"Should not be checked again\");\n    input.checked = true;\n    input.onchange();\n    assert.equal(model.checked(), true, \"Value of observable should be checked when input changes\");\n    input.checked = false;\n    input.onchange();\n    return assert.equal(model.checked(), false, \"Value of observable should be unchecked when input changes\");\n  });\n});\n\ndescribe(\"Classes\", function() {\n  it(\"should be bound in the context of the object\", function() {\n    var element, model, template;\n    template = makeTemplate(\".duder(class=@classes)\");\n    model = {\n      classes: function() {\n        return this.myClass();\n      },\n      myClass: function() {\n        return \"hats\";\n      }\n    };\n    element = template(model);\n    return assert(element.classList.contains(\"hats\"));\n  });\n  it(\"should handle observable arrays\", function() {\n    var element, model, template;\n    template = makeTemplate(\"div(class=@classes)\");\n    model = {\n      classes: Observable([\"a\", \"b\"])\n    };\n    element = template(model);\n    assert(element.classList.contains(\"a\"));\n    return assert(element.classList.contains(\"b\"));\n  });\n  it(\"should merge with literal classes\", function() {\n    var element, model, template;\n    template = makeTemplate(\".duder(class=@classes)\");\n    model = {\n      classes: Observable([\"a\", \"b\"])\n    };\n    element = template(model);\n    assert(element.classList.contains(\"a\"));\n    assert(element.classList.contains(\"b\"));\n    return assert(element.classList.contains(\"duder\"));\n  });\n  it(\"should not write `undefined` to the class\", function() {\n    var element, model, template;\n    template = makeTemplate(\".duder(class=@undefined)\");\n    model = {\n      undefined: void 0\n    };\n    element = template(model);\n    return assert(!element.classList.contains(\"undefined\"));\n  });\n  return it(\"should not have the class attribute if no classes\", function() {\n    var element, model, template;\n    template = makeTemplate(\"div(class=@undefined)\");\n    model = {\n      undefined: void 0\n    };\n    element = template(model);\n    return assert(!element.hasAttribute(\"class\"));\n  });\n});\n\ndescribe(\"Computed\", function() {\n  var template;\n  template = makeTemplate(\"div\\n  h2 @name\\n  input(value=@first)\\n  input(value=@last)\");\n  it(\"should compute automatically with the correct scope\", function() {\n    var element, model;\n    model = {\n      name: function() {\n        return this.first() + \" \" + this.last();\n      },\n      first: Observable(\"Mr.\"),\n      last: Observable(\"Doberman\")\n    };\n    element = template(model);\n    return assert.equal(element.querySelector(\"h2\").textContent, \"Mr. Doberman\");\n  });\n  return it(\"should work on special bindings\", function() {\n    var element, model;\n    template = makeTemplate(\"input(type='checkbox' checked=@checked)\");\n    model = {\n      checked: function() {\n        return this.name() === \"Duder\";\n      },\n      name: Observable(\"Mang\")\n    };\n    element = template(model);\n    assert.equal(element.checked, false);\n    model.name(\"Duder\");\n    return assert.equal(element.checked, true);\n  });\n});\n\ndescribe(\"Events\", function() {\n  it(\"should bind click to the object context\", function() {\n    var button, model, result, template;\n    template = makeTemplate(\"button(click=@click)\");\n    result = null;\n    model = {\n      name: Observable(\"Foobert\"),\n      click: function() {\n        return result = this.name();\n      }\n    };\n    button = template(model);\n    assert.equal(result, null);\n    button.click();\n    return assert.equal(result, \"Foobert\");\n  });\n  it(\"should not error on non-functions when binding events\", function() {\n    var button, model, template;\n    template = makeTemplate(\"button(@mouseenter @mouseleave)\");\n    model = {};\n    button = template(model);\n    dispatchEvent(button, \"mouseenter\");\n    dispatchEvent(button, \"mouseleave\");\n  });\n  it(\"doesn't late bind event functions\", function() {\n    var button, called, model, template;\n    template = makeTemplate(\"button(@click)\");\n    model = {};\n    button = template(model);\n    called = false;\n    model.click = function() {\n      return called = true;\n    };\n    dispatchEvent(button, \"click\");\n    return assert(!called);\n  });\n  it(\"should bind mouseenter and mouseleave events\", function() {\n    var button, model, result, template;\n    template = makeTemplate(\"button(@mouseenter @mouseleave)\");\n    result = null;\n    model = {\n      mouseenter: function() {\n        return result = 1;\n      },\n      mouseleave: function() {\n        return result = 2;\n      }\n    };\n    button = template(model);\n    assert.equal(result, null);\n    dispatchEvent(button, \"mouseenter\");\n    assert.equal(result, 1);\n    dispatchEvent(button, \"mouseleave\");\n    return assert.equal(result, 2);\n  });\n  it(\"shoud handle all touch events\", function() {\n    var called, canvas, eventFn, model, template;\n    template = makeTemplate(\"canvas(@touchstart @touchmove @touchend @touchcancel)\");\n    called = 0;\n    eventFn = function() {\n      return called += 1;\n    };\n    model = {\n      touchcancel: eventFn,\n      touchstart: eventFn,\n      touchmove: eventFn,\n      touchend: eventFn\n    };\n    canvas = template(model);\n    assert.equal(called, 0);\n    dispatchEvent(canvas, \"touchstart\");\n    assert.equal(called, 1);\n    dispatchEvent(canvas, \"touchmove\");\n    assert.equal(called, 2);\n    dispatchEvent(canvas, \"touchend\");\n    assert.equal(called, 3);\n    dispatchEvent(canvas, \"touchcancel\");\n    return assert.equal(called, 4);\n  });\n  return it(\"shoud handle all animation events\", function() {\n    var called, canvas, eventFn, model, template;\n    template = makeTemplate(\"div(@animationstart @animationiteration @animationend @transitionend)\");\n    called = 0;\n    eventFn = function() {\n      return called += 1;\n    };\n    model = {\n      animationstart: eventFn,\n      animationend: eventFn,\n      animationiteration: eventFn,\n      transitionend: eventFn\n    };\n    canvas = template(model);\n    assert.equal(called, 0);\n    dispatchEvent(canvas, \"animationstart\");\n    assert.equal(called, 1);\n    dispatchEvent(canvas, \"animationiteration\");\n    assert.equal(called, 2);\n    dispatchEvent(canvas, \"animationend\");\n    assert.equal(called, 3);\n    dispatchEvent(canvas, \"transitionend\");\n    return assert.equal(called, 4);\n  });\n});\n\ndescribe(\"ids\", function() {\n  it(\"should work with simple cases\", function() {\n    var element, template;\n    template = makeTemplate(\"h1#rad\");\n    element = template();\n    return assert.equal(element.id, \"rad\");\n  });\n  it(\"should be ok if empty\", function() {\n    var element, template;\n    template = makeTemplate(\"h1(id)\");\n    element = template();\n    return assert.equal(element.id, \"\");\n  });\n  it(\"should use the last valid id when multiple exist\", function() {\n    var element, template;\n    template = makeTemplate(\"h1#rad(id=\\\"cool\\\")\");\n    element = template();\n    return assert.equal(element.id, \"cool\");\n  });\n  it(\"should update the id if it's observable\", function() {\n    var element, model, template;\n    template = makeTemplate(\"h1(@id)\");\n    model = {\n      id: Observable(\"cool\")\n    };\n    element = template(model);\n    assert.equal(element.id, \"cool\");\n    model.id(\"wat\");\n    return assert.equal(element.id, \"wat\");\n  });\n  it(\"should update the last existing id if mixing literals and observables\", function() {\n    var element, model, template;\n    template = makeTemplate(\"h1#wat(@id id=@other)\");\n    model = {\n      id: Observable(\"cool\"),\n      other: Observable(\"other\")\n    };\n    element = template(model);\n    assert.equal(element.id, \"other\");\n    model.other(null);\n    assert.equal(element.id, \"cool\");\n    model.id(null);\n    return assert.equal(element.id, \"wat\");\n  });\n  return it(\"should be bound in the context of the object\", function() {\n    var element, model, template;\n    template = makeTemplate(\".duder(@id)\");\n    model = {\n      id: function() {\n        return this.myId();\n      },\n      myId: function() {\n        return \"hats\";\n      }\n    };\n    element = template(model);\n    return assert.equal(element.id, \"hats\");\n  });\n});\n\ndescribe(\"input\", function() {\n  var template;\n  template = makeTemplate(\"input(type=\\\"text\\\" @value)\");\n  it(\"should maintain caret position\", function() {\n    var input, model;\n    model = {\n      value: Observable(\"yolo\")\n    };\n    input = template(model);\n    input.focus();\n    input.selectionStart = 2;\n    assert.equal(input.selectionStart, 2);\n    input.value = \"yo2lo\";\n    input.selectionStart = 3;\n    assert.equal(input.selectionStart, 3);\n    input.onchange();\n    assert.equal(input.selectionStart, 3);\n    model.value(\"radical\");\n    return assert.equal(input.selectionStart, 7);\n  });\n  return it(\"should send updated value\", function() {\n    var input, model;\n    model = {\n      value: Observable(5)\n    };\n    input = template(model);\n    input.value = 50;\n    input.onchange();\n    return assert.equal(model.value(), \"50\");\n  });\n});\n\ndescribe(\"multiple bindings\", function() {\n  var model, template;\n  template = makeTemplate(\"div\\n  input(type=\\\"text\\\" @value)\\n  select(value=@value)\\n    @options\\n  hr\\n  input(type=\\\"range\\\" @value min=\\\"1\\\" @max)\\n  hr\\n  progress(@value @max)\");\n  model = {\n    max: 10,\n    value: Observable(5),\n    options: function() {\n      var _i, _ref, _results;\n      return (function() {\n        _results = [];\n        for (var _i = 1, _ref = this.max; 1 <= _ref ? _i <= _ref : _i >= _ref; 1 <= _ref ? _i++ : _i--){ _results.push(_i); }\n        return _results;\n      }).apply(this).map(function(v) {\n        var o;\n        o = document.createElement(\"option\");\n        o.value = v;\n        o.textContent = v;\n        return o;\n      });\n    }\n  };\n  return it(\"should be initialized to the right values\", function() {\n    var element, select;\n    element = template(model);\n    select = element.querySelector(\"select\");\n    [\"text\", \"range\"].forEach(function(type) {\n      return assert.equal(element.querySelector(\"input[type='\" + type + \"']\").value, 5);\n    });\n    assert.equal(element.querySelector(\"progress\").value, 5);\n    assert.equal(select.value, 5);\n    return [2, 7, 3, 8].forEach(function(value) {\n      model.value(value);\n      assert.equal(select.value, value);\n      [\"text\", \"range\"].forEach(function(type) {\n        return assert.equal(element.querySelector(\"input[type='\" + type + \"']\").value, value);\n      });\n      return assert.equal(element.querySelector(\"progress\").value, value);\n    });\n  });\n});\n\ndescribe(\"Primitives\", function() {\n  var template;\n  template = makeTemplate(\"div\\n  @string\\n  @boolean\\n  @number\\n  @array\");\n  return it(\"should render correctly\", function() {\n    var element, model;\n    model = {\n      string: \"hey\",\n      boolean: true,\n      number: 5,\n      array: [1, true, \"e\"]\n    };\n    element = template(model);\n    return assert.equal(element.textContent, \"heytrue51truee\");\n  });\n});\n\ndescribe(\"Random tags\", function() {\n  var model, template;\n  template = makeTemplate(\"div\\n  duder\\n  yolo(radical=\\\"true\\\")\\n  sandwiches(type=@type)\");\n  model = {\n    type: Observable(\"ham\")\n  };\n  it(\"should be have those tags and atrtibutes\", function() {\n    var element;\n    element = template(model);\n    assert(element.querySelector(\"duder\"));\n    assert(element.querySelector(\"yolo\").getAttribute(\"radical\"));\n    return assert.equal(element.querySelector(\"sandwiches\").getAttribute(\"type\"), \"ham\");\n  });\n  return it(\"should reflect changes in observables\", function() {\n    var element;\n    element = template(model);\n    assert.equal(element.querySelector(\"sandwiches\").getAttribute(\"type\"), \"ham\");\n    model.type(\"pastrami\");\n    return assert.equal(element.querySelector(\"sandwiches\").getAttribute(\"type\"), \"pastrami\");\n  });\n});\n\ndescribe(\"retain\", function() {\n  return it(\"should keep elements bound even when reused in the DOM\", function() {\n    var CanvasTemplate, EditorTemplate, canvasElement, canvasModel, editorElement, editorModel;\n    CanvasTemplate = makeTemplate(\"canvas(@width @height)\");\n    EditorTemplate = makeTemplate(\"editor\\n  @title\\n  @canvas\");\n    canvasModel = {\n      width: Observable(64),\n      height: Observable(64)\n    };\n    canvasElement = CanvasTemplate(canvasModel);\n    Jadelet.retain(canvasElement);\n    editorModel = {\n      title: Observable(\"yo\"),\n      canvas: canvasElement\n    };\n    editorElement = EditorTemplate(editorModel);\n    assert.equal(canvasElement.getAttribute('height'), 64);\n    canvasModel.height(48);\n    assert.equal(canvasElement.getAttribute('height'), 48);\n    editorModel.title(\"lo\");\n    canvasModel.height(32);\n    assert.equal(canvasElement.getAttribute('height'), 32);\n    return Jadelet.release(canvasElement);\n  });\n});\n\ndescribe(\"Styles\", function() {\n  it(\"should be bound in the context of the object\", function() {\n    var element, model, template;\n    template = makeTemplate(\"duder(@style)\");\n    model = {\n      style: function() {\n        return this.myStyle();\n      },\n      myStyle: function() {\n        return {\n          backgroundColor: \"red\"\n        };\n      }\n    };\n    element = template(model);\n    return assert.equal(element.style.backgroundColor, \"red\");\n  });\n  it(\"should remove styles when observables change\", function() {\n    var element, model, template;\n    template = makeTemplate(\"duder(@style)\");\n    model = {\n      style: Observable({\n        backgroundColor: \"red\"\n      })\n    };\n    element = template(model);\n    assert.equal(element.style.backgroundColor, \"red\");\n    model.style({\n      color: \"green\"\n    });\n    assert.equal(element.style.backgroundColor, \"\");\n    return assert.equal(element.style.color, \"green\");\n  });\n  it(\"should merge observable arrays of style mappings\", function() {\n    var element, model, template;\n    template = makeTemplate(\"div(style=@styles)\");\n    model = {\n      styles: Observable([\n        {\n          lineHeight: \"1.5em\",\n          height: \"30px\",\n          width: \"40px\"\n        }, {\n          color: \"green\",\n          lineHeight: null,\n          height: void 0,\n          width: \"50px\"\n        }\n      ])\n    };\n    element = template(model);\n    assert.equal(element.style.color, \"green\");\n    assert.equal(element.style.height, \"30px\");\n    assert.equal(element.style.lineHeight, \"\");\n    return assert.equal(element.style.width, \"50px\");\n  });\n  it(\"should work with plain style strings\", function() {\n    var element, model, template;\n    template = makeTemplate(\"div(@style)\");\n    model = {\n      style: \"background-color: orange;\\ncolor: blue;\"\n    };\n    element = template(model);\n    assert.equal(element.style.color, \"blue\");\n    return assert.equal(element.style.backgroundColor, \"orange\");\n  });\n  return it(\"should mix and match plain strings and objects\", function() {\n    var element, model, template;\n    template = makeTemplate(\"div(style=@rekt style=@styleString style=@styleObject)\");\n    model = {\n      rekt: {\n        height: \"20px\",\n        color: \"green\"\n      },\n      styleString: \"background-color: orange;\\ncolor: blue;\",\n      styleObject: function() {\n        return {\n          color: \"black\",\n          width: \"50px\"\n        };\n      }\n    };\n    element = template(model);\n    assert.equal(element.style.backgroundColor, \"orange\");\n    assert.equal(element.style.color, \"black\");\n    assert.equal(element.style.height, \"\");\n    return assert.equal(element.style.width, \"50px\");\n  });\n});\n\ndescribe(\"content arrays\", function() {\n  it(\"should render and update items\", function() {\n    var element, model, template;\n    template = makeTemplate(\"div\\n  @items\");\n    model = {\n      count: Observable(3),\n      items: function() {\n        var c, i, r;\n        c = this.count();\n        r = [];\n        i = 0;\n        while (i < c) {\n          i++;\n          r.push(document.createElement(\"p\"));\n        }\n        return r;\n      }\n    };\n    element = template(model);\n    assert.equal(element.children.length, 3);\n    model.count(5);\n    return assert.equal(element.children.length, 5);\n  });\n  return it(\"should keep them in order and not re-render excessively\", function() {\n    var element, firstA, model, template;\n    template = makeTemplate(\"div\\n  @items\\n  @otherItems\\n  hr\");\n    model = {\n      count: Observable(3),\n      otherCount: Observable(2),\n      items: function() {\n        var c, i, r;\n        c = this.count();\n        r = [];\n        i = 0;\n        while (i < c) {\n          i++;\n          r.push(document.createElement(\"p\"));\n        }\n        return r;\n      },\n      otherItems: function() {\n        var c, i, r;\n        c = this.otherCount();\n        r = [];\n        i = 0;\n        while (i < c) {\n          i++;\n          r.push(document.createElement(\"a\"));\n        }\n        return r;\n      }\n    };\n    element = template(model);\n    assert.equal(element.querySelectorAll('p').length, 3);\n    assert.equal(element.querySelectorAll('a').length, 2);\n    firstA = element.children[3];\n    model.count(0);\n    assert.equal(element.querySelectorAll('p').length, 0);\n    assert.equal(element.querySelectorAll('a').length, 2);\n    assert.equal(firstA, element.children[0]);\n    model.count(7);\n    assert.equal(element.querySelectorAll('p').length, 7);\n    assert.equal(element.querySelectorAll('a').length, 2);\n    assert.equal(firstA, element.children[7]);\n    model.otherCount(1);\n    return assert.notEqual(firstA, element.children[7]);\n  });\n});\n\ndescribe(\"subrender\", function() {\n  describe(\"rendering simple text\", function() {\n    var template;\n    template = makeTemplate(\"span.count @count\");\n    it(\"should render numbers as strings\", function() {\n      var element, model;\n      model = {\n        count: 5\n      };\n      element = template(model);\n      return assert.equal(element.textContent, \"5\");\n    });\n    return it(\"should update when observable changes\", function() {\n      var element, model;\n      model = {\n        count: Observable(5)\n      };\n      element = template(model);\n      assert.equal(element.textContent, \"5\");\n      model.count(2);\n      return assert.equal(element.textContent, \"2\");\n    });\n  });\n  describe(\"with root node\", function() {\n    var template;\n    template = makeTemplate(\"div\\n  @generateItem\");\n    it(\"should render elements in-line\", function() {\n      var element, model;\n      model = {\n        generateItem: function() {\n          return document.createElement(\"li\");\n        }\n      };\n      element = template(model);\n      return assert(element.querySelector(\"li\"));\n    });\n    it(\"should render lists of nodes\", function() {\n      var element, model;\n      model = {\n        generateItem: function() {\n          return [document.createElement(\"li\"), document.createElement(\"li\"), document.createElement(\"p\")];\n        }\n      };\n      element = template(model);\n      assert(element.querySelectorAll(\"li\").length, 2);\n      return assert(element.querySelectorAll(\"p\").length, 1);\n    });\n    it(\"should work with a node with children\", function() {\n      var element, model;\n      model = {\n        generateItem: function() {\n          var div;\n          div = document.createElement(\"div\");\n          div.innerHTML = \"<p>Yo</p><ol><li>Yolo</li><li>Broheim</li></ol>\";\n          return div;\n        }\n      };\n      element = template(model);\n      assert(element.querySelectorAll(\"li\").length, 2);\n      assert(element.querySelectorAll(\"p\").length, 1);\n      return assert(element.querySelectorAll(\"ol\").length, 1);\n    });\n    return it(\"should work with observables\", function() {\n      var element, model;\n      model = {\n        name: Observable(\"wat\"),\n        generateItem: function() {\n          var item;\n          item = document.createElement(\"li\");\n          item.textContent = this.name();\n          return item;\n        }\n      };\n      element = template(model);\n      assert.equal(element.querySelectorAll(\"li\").length, 1);\n      assert.equal(element.querySelector(\"li\").textContent, \"wat\");\n      model.name(\"yo\");\n      return assert.equal(element.querySelector(\"li\").textContent, \"yo\");\n    });\n  });\n  return describe(\"rendering subtemplates\", function() {\n    describe(\"mixing and matching\", function() {\n      var subtemplate, template;\n      subtemplate = makeTemplate(\"span Hello\");\n      template = makeTemplate(\"div\\n  a Radical\\n  |\\n  @subtemplate\\n  |\\n  @observable\\n  @nullable\");\n      return it(\"shouldn't lose any nodes\", function() {\n        var element, model;\n        model = {\n          observable: Observable(\"wat\"),\n          subtemplate: subtemplate,\n          nullable: null\n        };\n        element = template(model);\n        assert.equal(element.textContent, \"Radical\\nHello\\nwat\");\n        model.observable(\"duder\");\n        return assert.equal(element.textContent, \"Radical\\nHello\\nduder\");\n      });\n    });\n    return describe(\"mapping array to subtemplates\", function() {\n      var template;\n      template = makeTemplate(\"table\\n  @rows\");\n      it(\"should render subtemplates\", function() {\n        var element, model;\n        model = {\n          rows: function() {\n            return [\n              {\n                text: \"Wat\"\n              }, {\n                text: \"is\"\n              }, {\n                text: \"up\"\n              }\n            ].map(this.subtemplate);\n          },\n          subtemplate: makeTemplate(\"tr\\n  td @text\")\n        };\n        element = template(model);\n        return assert.equal(element.querySelectorAll(\"tr\").length, 3);\n      });\n      return it(\"should maintain observables in subtemplates\", function() {\n        var data, element, model;\n        data = Observable([\n          {\n            text: Observable(\"Wat\")\n          }, {\n            text: Observable(\"is\")\n          }, {\n            text: Observable(\"up\")\n          }\n        ]);\n        model = {\n          rows: function() {\n            return data.map(this.subtemplate);\n          },\n          subtemplate: makeTemplate(\"tr\\n  td @text\")\n        };\n        element = template(model);\n        assert.equal(element.querySelectorAll(\"tr\").length, 3);\n        assert.equal(element.querySelector(\"td\").textContent, \"Wat\");\n        data()[0].text(\"yo\");\n        assert.equal(element.querySelector(\"td\").textContent, \"yo\");\n        data.push({\n          text: Observable(\"dude\")\n        });\n        assert.equal(element.querySelectorAll(\"tr\").length, 4);\n        assert.equal(element.querySelector(\"td\").textContent, \"yo\");\n        data()[0].text(\"holla\");\n        return assert.equal(element.querySelector(\"td\").textContent, \"holla\");\n      });\n    });\n  });\n});\n\ndescribe(\"element properties\", function() {\n  return it(\"should use the element property of objects rendered\", function() {\n    var element, src, template;\n    src = \"ul\\n  @a\\n  @b\";\n    template = makeTemplate(src);\n    element = template({\n      a: {\n        element: document.createElement('a')\n      },\n      b: {\n        element: document.createElement('b')\n      }\n    });\n    assert(element.querySelector(\"a\"));\n    assert(element.querySelector(\"b\"));\n    return assert(!element.querySelector(\"c\"));\n  });\n});\n\ndescribe(\"cached retains\", function() {\n  return it(\"should not release elements that are consistent render to render\", function() {\n    var Container, Item, ItemView, cache, containerView, element, itemViews;\n    Container = makeTemplate(\"div\\n  @elements\");\n    Item = makeTemplate(\"input(@value)\");\n    ItemView = function(i) {\n      var item, view;\n      view = cache.get(i);\n      if (view) {\n        return view;\n      }\n      item = {\n        value: Observable(i)\n      };\n      view = {\n        item: item,\n        element: Item(item)\n      };\n      cache.set(i, view);\n      return view;\n    };\n    cache = new Map;\n    itemViews = [0, 1, 2].map(ItemView);\n    containerView = {\n      elements: Observable(itemViews)\n    };\n    element = Container(containerView);\n    assert.equal(element.children.length, 3);\n    containerView.elements()[0].item.value(100);\n    assert.equal(element.children[0].value, 100);\n    containerView.elements.push(ItemView(3));\n    assert.equal(element.children.length, 4);\n    containerView.elements()[0].item.value(200);\n    return assert.equal(element.children[0].value, 200);\n  });\n});\n\ndescribe(\"text\", function() {\n  return it(\"should preserve line breaks\", function() {\n    var element, src, template;\n    src = \"p\\n  | hello I am a cool paragraph\\n  | with lots of text and stuff\\n  | ain't it rad?\";\n    template = makeTemplate(src);\n    element = template();\n    return assert.equal(element.textContent, \"hello I am a cool paragraph\\nwith lots of text and stuff\\nain't it rad?\\n\");\n  });\n});\n\ndescribe(\"svg\", function() {\n  return it(\"should render svg\", function() {\n    var element, src, template;\n    src = \"section\\n  h2 svg test\\n  svg(width=100 height=100)\\n    circle(cx=80 cy=80 r=30 fill=\\\"red\\\")\\n  p awesome\";\n    template = makeTemplate(src);\n    element = template();\n    return assert.equal(element.querySelector('svg').namespaceURI, \"http://www.w3.org/2000/svg\");\n  });\n});\n\ndescribe(\"indentation\", function() {\n  return it(\"should work with somewhat flexible indentation for ease of use with template strings in js\", function() {\n    var T1, T2, el, indentedTemplate1, indentedTemplate2;\n    indentedTemplate1 = \"p\\n        a(@click) Cool\";\n    indentedTemplate2 = indentedTemplate1.replace(/^/, \"      \");\n    T1 = makeTemplate(indentedTemplate1);\n    T2 = makeTemplate(indentedTemplate2);\n    el = T1();\n    assert.equal(el.querySelector('a').textContent, \"Cool\");\n    el = T2();\n    return assert.equal(el.querySelector('a').textContent, \"Cool\");\n  });\n});\n\ndescribe(\"weird cases\", function() {\n  return it.skip(\"should handle weird templates\", function() {\n    return makeTemplate('.palette\\n  .primary.color\\n    - style = ->\\n      - c = editor.activeColor()\\n      - \"background-color: #{c}\"\\n    input(type=\"color\" value=@activeColor style=@activeColorStyle)\\n\\n  @swatchElements\\n  @opacityElement');\n  });\n});\n"},"lib/test/mousetrap":{"content":"\n"},"lib/test/observable":{"content":"var Observable;\n\nObservable = require(\"../observable\");\n\ndescribe('Observable', function() {\n  it('should create an observable for an object', function() {\n    var n, observable;\n    n = 5;\n    observable = Observable(n);\n    return assert.equal(observable(), n);\n  });\n  it('should fire events when setting', function() {\n    var observable, string;\n    string = \"yolo\";\n    observable = Observable(string);\n    observable.observe(function(newValue) {\n      return assert.equal(newValue, \"4life\");\n    });\n    return observable(\"4life\");\n  });\n  it(\"should not fire when setting to the same value\", function() {\n    var o;\n    o = Observable(5);\n    o.observe(function() {\n      return assert(false);\n    });\n    return o(5);\n  });\n  it('should be idempotent', function() {\n    var o;\n    o = Observable(5);\n    return assert.equal(o, Observable(o));\n  });\n  it(\"should have releaseDependencies as a noop because primitive observables don't have any dependencies\", function() {\n    var o;\n    o = Observable(5);\n    return o.releaseDependencies();\n  });\n  it(\"should provide an updating non-observing semi-private reference to value\", function() {\n    var o, o2, o3;\n    o = Observable(5);\n    assert.equal(o._value, 5);\n    o(7);\n    assert.equal(o._value, 7);\n    o2 = Observable(function() {\n      return o._value;\n    });\n    o3 = Observable(function() {\n      return o();\n    });\n    assert.equal(o2(), 7);\n    assert.equal(o3(), 7);\n    o(9);\n    assert.equal(o2(), 7);\n    assert.equal(o2._value, 7);\n    assert.equal(o3(), 9);\n    assert.equal(o3._value, 9);\n    return assert.equal(o._value, 9);\n  });\n  it(\"should allow for stopping observation\", function() {\n    var called, fn, observable;\n    observable = Observable(\"string\");\n    called = 0;\n    fn = function(newValue) {\n      called += 1;\n      return assert.equal(newValue, \"4life\");\n    };\n    observable.observe(fn);\n    observable(\"4life\");\n    observable.stopObserving(fn);\n    observable(\"wat\");\n    return assert.equal(called, 1);\n  });\n  it(\"should do nothing when removing a listener that's not present\", function() {\n    var observable;\n    observable = Observable(\"string\");\n    return observable.stopObserving(function() {});\n  });\n  it(\"should increment\", function() {\n    var observable;\n    observable = Observable(1);\n    observable.increment(5);\n    assert.equal(observable(), 6);\n    observable.increment();\n    assert.equal(observable(), 7);\n    observable.increment(0.05);\n    assert.equal(observable(), 7.05);\n    observable.increment(0.05);\n    return assert.equal(observable(), 7.10);\n  });\n  it(\"should decremnet\", function() {\n    var observable;\n    observable = Observable(1);\n    observable.decrement(5);\n    assert.equal(observable(), -4);\n    observable.decrement();\n    return assert.equal(observable(), -5);\n  });\n  it(\"should toggle\", function() {\n    var observable;\n    observable = Observable(false);\n    observable.toggle();\n    assert.equal(observable(), true);\n    observable.toggle();\n    return assert.equal(observable(), false);\n  });\n  it(\"should trigger when toggling\", function(done) {\n    var observable;\n    observable = Observable(true);\n    observable.observe(function(v) {\n      assert.equal(v, false);\n      return done();\n    });\n    return observable.toggle();\n  });\n  return it(\"should have a nice toString\", function() {\n    var observable;\n    observable = Observable(5);\n    return assert.equal(observable.toString(), \"Observable(5)\");\n  });\n});\n\ndescribe(\"Observable Array\", function() {\n  it(\"should proxy array methods\", function() {\n    var o;\n    o = Observable([5]);\n    return o.map(function(n) {\n      return assert.equal(n, 5);\n    });\n  });\n  it(\"should notify on mutation methods\", function(done) {\n    var o;\n    o = Observable([]);\n    o.observe(function(newValue) {\n      return assert.equal(newValue[0], 1);\n    });\n    o.push(1);\n    return done();\n  });\n  it(\"#get\", function() {\n    var o;\n    o = Observable([0, 1, 2, 3]);\n    return assert.equal(o.get(2), 2);\n  });\n  it(\"#first\", function() {\n    var o;\n    o = Observable([0, 1, 2, 3]);\n    return assert.equal(o.first(), 0);\n  });\n  it(\"#last\", function() {\n    var o;\n    o = Observable([0, 1, 2, 3]);\n    return assert.equal(o.last(), 3);\n  });\n  it(\"#remove\", function() {\n    var o;\n    o = Observable([0, 1, 2, 3]);\n    assert.equal(o.remove(2), 2);\n    assert.equal(o.length, 3);\n    assert.equal(o.remove(-5), void 0);\n    return assert.equal(o.length, 3);\n  });\n  it(\"#remove non-existent element\", function() {\n    var o;\n    o = Observable([1, 2, 3]);\n    return assert.equal(o.remove(0), void 0);\n  });\n  it(\"should proxy the length property\", function() {\n    var called, o;\n    o = Observable([1, 2, 3]);\n    assert.equal(o.length, 3);\n    called = false;\n    o.observe(function(value) {\n      assert.equal(value[0], 1);\n      assert.equal(value[1], void 0);\n      return called = true;\n    });\n    o.length = 1;\n    assert.equal(o.length, 1);\n    return assert.equal(called, true);\n  });\n  return it(\"should auto detect conditionals of length as a dependency\", function() {\n    var called, o, observableArray;\n    observableArray = Observable([1, 2, 3]);\n    o = Observable(function() {\n      if (observableArray.length > 5) {\n        return true;\n      } else {\n        return false;\n      }\n    });\n    assert.equal(o(), false);\n    called = 0;\n    o.observe(function() {\n      return called += 1;\n    });\n    observableArray.push(4, 5, 6);\n    return assert.equal(called, 1);\n  });\n});\n\ndescribe(\"Observable functions\", function() {\n  it(\"should compute dependencies\", function(done) {\n    var firstName, lastName, o;\n    firstName = Observable(\"Duder\");\n    lastName = Observable(\"Man\");\n    o = Observable(function() {\n      return \"\" + (firstName()) + \" \" + (lastName());\n    });\n    o.observe(function(newValue) {\n      assert.equal(newValue, \"Duder Bro\");\n      return done();\n    });\n    return lastName(\"Bro\");\n  });\n  it(\"should compute array#get as a dependency\", function() {\n    var observableArray, observableFn;\n    observableArray = Observable([0, 1, 2]);\n    observableFn = Observable(function() {\n      return observableArray.get(0);\n    });\n    assert.equal(observableFn(), 0);\n    observableArray([5]);\n    return assert.equal(observableFn(), 5);\n  });\n  it(\"should compute array#first as a dependency\", function() {\n    var observableArray, observableFn;\n    observableArray = Observable([0, 1, 2]);\n    observableFn = Observable(function() {\n      return observableArray.first() + 1;\n    });\n    assert.equal(observableFn(), 1);\n    observableArray([5]);\n    return assert.equal(observableFn(), 6);\n  });\n  it(\"should compute array#last as a dependency\", function() {\n    var observableArray, observableFn;\n    observableArray = Observable([0, 1, 2]);\n    observableFn = Observable(function() {\n      return observableArray.last();\n    });\n    assert.equal(observableFn(), 2);\n    observableArray.pop();\n    assert.equal(observableFn(), 1);\n    observableArray([5]);\n    return assert.equal(observableFn(), 5);\n  });\n  it(\"should compute array#size as a dependency\", function() {\n    var observableArray, observableFn;\n    observableArray = Observable([0, 1, 2]);\n    observableFn = Observable(function() {\n      return observableArray.size() * 2;\n    });\n    assert.equal(observableFn(), 6);\n    observableArray.pop();\n    assert.equal(observableFn(), 4);\n    observableArray.shift();\n    return assert.equal(observableFn(), 2);\n  });\n  it(\"should allow double nesting\", function(done) {\n    var bottom, middle, top;\n    bottom = Observable(\"rad\");\n    middle = Observable(function() {\n      return bottom();\n    });\n    top = Observable(function() {\n      return middle();\n    });\n    top.observe(function(newValue) {\n      assert.equal(newValue, \"wat\");\n      assert.equal(top(), newValue);\n      assert.equal(middle(), newValue);\n      return done();\n    });\n    return bottom(\"wat\");\n  });\n  it(\"should work with dynamic dependencies\", function() {\n    var dynamicObservable, observableArray;\n    observableArray = Observable([]);\n    dynamicObservable = Observable(function() {\n      return observableArray.filter(function(item) {\n        return item.age() > 3;\n      });\n    });\n    assert.equal(dynamicObservable().length, 0);\n    observableArray.push({\n      age: Observable(1)\n    });\n    observableArray()[0].age(5);\n    return assert.equal(dynamicObservable().length, 1);\n  });\n  it(\"should work with context\", function() {\n    var model;\n    model = {\n      a: Observable(\"Hello\"),\n      b: Observable(\"there\")\n    };\n    model.c = Observable(function() {\n      return \"\" + (this.a()) + \" \" + (this.b());\n    }, model);\n    assert.equal(model.c(), \"Hello there\");\n    model.b(\"world\");\n    return assert.equal(model.c(), \"Hello world\");\n  });\n  it(\"should be ok even if the function throws an exception\", function() {\n    assert.throws(function() {\n      var t;\n      return t = Observable(function() {\n        throw \"wat\";\n      });\n    });\n    return assert.equal(global.OBSERVABLE_ROOT_HACK.length, 0);\n  });\n  it(\"should work on an array dependency\", function() {\n    var last, o, oA;\n    oA = Observable([1, 2, 3]);\n    o = Observable(function() {\n      return oA()[0];\n    });\n    last = Observable(function() {\n      return oA()[oA().length - 1];\n    });\n    assert.equal(o(), 1);\n    oA.unshift(0);\n    assert.equal(o(), 0);\n    oA.push(4);\n    return assert.equal(last(), 4, \"Last should be 4\");\n  });\n  it(\"should work with multiple dependencies\", function() {\n    var checked, first, letter, second;\n    letter = Observable(\"A\");\n    checked = function() {\n      var l;\n      l = letter();\n      return this.name().indexOf(l) === 0;\n    };\n    first = {\n      name: Observable(\"Andrew\")\n    };\n    first.checked = Observable(checked, first);\n    second = {\n      name: Observable(\"Benjamin\")\n    };\n    second.checked = Observable(checked, second);\n    assert.equal(first.checked(), true);\n    assert.equal(second.checked(), false);\n    assert.equal(letter.listeners.length, 2);\n    letter(\"B\");\n    assert.equal(first.checked(), false);\n    return assert.equal(second.checked(), true);\n  });\n  it(\"shouldn't double count dependencies\", function() {\n    var count, dep, o;\n    dep = Observable(\"yo\");\n    o = Observable(function() {\n      dep();\n      dep();\n      return dep();\n    });\n    count = 0;\n    o.observe(function() {\n      return count += 1;\n    });\n    dep('heyy');\n    return assert.equal(count, 1);\n  });\n  it(\"should recompute the correct number of times\", function() {\n    var called, fn, items, joiner;\n    joiner = Observable(\",\");\n    items = Observable([\"A\", \"B\", \"C\"]);\n    called = 0;\n    fn = Observable(function() {\n      called += 1;\n      return items.join(joiner());\n    });\n    assert.equal(fn(), \"A,B,C\");\n    assert.equal(called, 1);\n    items.push(\"D\");\n    assert.equal(fn(), \"A,B,C,D\");\n    assert.equal(called, 2);\n    joiner(\".\");\n    assert.equal(fn(), \"A.B.C.D\");\n    assert.equal(called, 3);\n    items.push(\"E\");\n    assert.equal(fn(), \"A.B.C.D.E\");\n    return assert.equal(called, 4);\n  });\n  it(\"should work with nested observable construction\", function() {\n    var gen, o, o2;\n    gen = Observable(function() {\n      return Observable(\"Duder\");\n    });\n    o = gen();\n    o2 = gen();\n    assert.equal(o, o2);\n    assert.equal(o(), \"Duder\");\n    o(\"wat\");\n    return assert.equal(o(), \"wat\");\n  });\n  return it(\"should be scoped to optional context\", function(done) {\n    var model;\n    model = {\n      firstName: Observable(\"Duder\"),\n      lastName: Observable(\"Man\")\n    };\n    model.name = Observable(function() {\n      return \"\" + (this.firstName()) + \" \" + (this.lastName());\n    }, model);\n    model.name.observe(function(newValue) {\n      assert.equal(newValue, \"Duder Bro\");\n      return done();\n    });\n    return model.lastName(\"Bro\");\n  });\n});\n"},"lib/test/pkg/index":{"content":"var ModLoader, Require, compile, crudeRequire, exec, htmlForPackage, jsForPackage, minify, registerCompiler, testPkg, _ref;\n\n_ref = require(\"/lib/pkg/index\"), compile = _ref.compile, crudeRequire = _ref.crudeRequire, exec = _ref.exec, htmlForPackage = _ref.htmlForPackage, jsForPackage = _ref.jsForPackage, minify = _ref.minify, ModLoader = _ref.ModLoader, registerCompiler = _ref.registerCompiler, Require = _ref.Require;\n\nmocha.setup({\n  globals: ['CoffeeScript', 'marked', 'stylus', 'UglifyJS']\n});\n\ntestPkg = {\n  distribution: {\n    main: {\n      content: \"alert('heyy');\"\n    }\n  },\n  dependencies: {\n    \"!system\": PACKAGE\n  },\n  config: {\n    description: \"Yolo\"\n  }\n};\n\ndescribe(\"pkg\", function() {\n  describe(\"htmlForPackage\", function() {\n    return it(\"should blob up html\", function() {\n      var blob;\n      blob = htmlForPackage(testPkg);\n      return assert(blob instanceof Blob);\n    });\n  });\n  describe(\"compile\", function() {\n    it(\"should compile CoffeeScript by lazy loading compiler\", function() {\n      return compile(\"hello.coffee\", \"alert 'hello'\");\n    });\n    it(\"should 'compile' JavaScript\", function() {\n      var src;\n      src = \"alert('hello');\";\n      return compile(\"hello.js\", src).then(function(program) {\n        return assert.equal(program, src);\n      });\n    });\n    it(\"should compile markdown after lazy loading compiler\", function() {\n      return compile(\"TODO.md\", \"- [x] Lazy Load compilers\");\n    });\n    it(\"should compile stylus after lazy loading compiler\", function() {\n      return compile(\"yo.styl\", \"body\\n  background-color: green\");\n    });\n    it(\"should fail if no known compiler\", function() {\n      return compile(\"wat.doot\", \"\")[\"catch\"](function(e) {\n        return assert.equal(e.message, \"Couldn't compile 'wat.doot'. No compiler for '.doot'\");\n      });\n    });\n    return it(\"should register compilers\", function() {\n      registerCompiler(\"doot\", function() {\n        return \"doot\";\n      });\n      return compile(\"wat.doot\", \"\");\n    });\n  });\n  describe(\"exec\", function() {\n    it(\"should bind this\", function() {\n      var x, y;\n      x = {};\n      y = exec(\"return this\", null, x);\n      return assert.equal(x, y);\n    });\n    it(\"env is optional\", function() {\n      var r;\n      r = exec(\"return 5\");\n      return assert.equal(r, 5);\n    });\n    return it(\"should bind env values\", function() {\n      var r;\n      r = exec(\"return a + this\", {\n        a: 2\n      }, 3);\n      return assert.equal(r, 5);\n    });\n  });\n  describe(\"crudeRequire\", function() {\n    return it(\"should return what is exported\", function() {\n      var result;\n      result = crudeRequire(\"module.exports = \\\"cool\\\";\");\n      return assert.equal(result, \"cool\");\n    });\n  });\n  describe(\"Require\", function() {\n    return it(\"should be exported\", function() {\n      return assert(Require);\n    });\n  });\n  describe(\"jsForPackge\", function() {\n    return it(\"should generate a string of js\", function() {\n      var js;\n      js = jsForPackage(PACKAGE);\n      return assert(typeof js === 'string');\n    });\n  });\n  describe.skip(\"minify\", function() {\n    return it(\"makes packages smaller\", function() {\n      return minify(PACKAGE, console).then(console.log);\n    });\n  });\n  return describe(\"Mod Loader\", function() {\n    return it(\"should load remote modules\", function() {\n      return ModLoader;\n    });\n  });\n});\n"},"lib/test/pkg/require":{"content":"var latestRequire, requireSrc, sampleDir;\n\nrequireSrc = \"/lib/pkg/require2\";\n\nlatestRequire = require(requireSrc).generateFor(PACKAGE);\n\nsampleDir = \"/data/pkg/samples/\";\n\ndescribe(\"require\", function() {\n  it(\"should not exist globally\", function() {\n    return assert(!global.require);\n  });\n  it(\"should be able to require a file that exists with a relative path\", function() {\n    return assert(latestRequire(\"\" + sampleDir + \"terminal\"));\n  });\n  it(\"should get whatever the file exports\", function() {\n    return assert(latestRequire(\"\" + sampleDir + \"terminal\").something);\n  });\n  it(\"should not get something the file doesn't export\", function() {\n    return assert(!latestRequire(\"\" + sampleDir + \"terminal\").something2);\n  });\n  it(\"should throw a descriptive error when requring circular dependencies\", function() {\n    return assert.throws(function() {\n      return latestRequire(\"\" + sampleDir + \"circular\");\n    }, /circular/i);\n  });\n  it(\"should throw a descriptive error when requiring a package that doesn't exist\", function() {\n    return assert.throws(function() {\n      return latestRequire(\"does_not_exist\");\n    }, /not found/i);\n  });\n  it(\"should throw a descriptive error when requiring a relative path that doesn't exist\", function() {\n    return assert.throws(function() {\n      return latestRequire(\"/does_not_exist\");\n    }, /Could not find file/i);\n  });\n  it(\"should recover gracefully enough from requiring files that throw errors\", function() {\n    assert.throws(function() {\n      return latestRequire(\"\" + sampleDir + \"throws\");\n    });\n    return assert.throws(function() {\n      return latestRequire(\"\" + sampleDir + \"throws\");\n    }, function(err) {\n      return !/circular/i.test(err);\n    });\n  });\n  it(\"should cache modules\", function() {\n    var result;\n    result = latestRequire(\"\" + sampleDir + \"random\");\n    return assert.equal(latestRequire(\"\" + sampleDir + \"random\"), result);\n  });\n  it(\"should be able to require a JSON package object\", function() {\n    var SAMPLE_PACKAGE, result;\n    SAMPLE_PACKAGE = {\n      entryPoint: \"main\",\n      distribution: {\n        main: {\n          content: \"module.exports = require('./other')\"\n        },\n        other: {\n          content: \"module.exports = 'TEST'\"\n        }\n      }\n    };\n    result = latestRequire(SAMPLE_PACKAGE);\n    return assert.equal(\"TEST\", result);\n  });\n  return it(\"should be able to require something packaged with browserify\", function() {\n    return assert.equal(latestRequire(\"\" + sampleDir + \"browserified\"), \"coolio\");\n  });\n});\n\ndescribe(\"package wrapper\", function() {\n  it(\"should be able to generate a package wrapper recursively\", function() {\n    var pkgString;\n    pkgString = latestRequire.packageWrapper(PACKAGE, \"window.r = require\");\n    Function(pkgString)();\n    Function(r.packageWrapper(PACKAGE, \"window.r2 = require\"))();\n    Function(r2.packageWrapper(PACKAGE, \"window.r3 = require\"))();\n    assert(r2);\n    assert(r3);\n    delete r;\n    delete r2;\n    return delete r3;\n  });\n  return it(\"should be able to execute code in the package context\", function() {\n    var code;\n    code = latestRequire.packageWrapper(PACKAGE, \"window.test = require.packageWrapper(PACKAGE, 'alert(\\\"heyy\\\")');\");\n    Function(code)();\n    assert(window.test);\n    return delete window.test;\n  });\n});\n\ndescribe(\"public API\", function() {\n  mocha.setup({\n    globals: ['system', 'OBSERVABLE_ROOT_HACK']\n  });\n  return it(\"should be able to require a JSON package directly\", function() {\n    assert(require(requireSrc).loadPackage({\n      distribution: {\n        main: {\n          content: \"global.test2 = true\"\n        }\n      }\n    }));\n    assert(window.test2);\n    return delete window.test2;\n  });\n});\n\ndescribe(\"module context\", function() {\n  it(\"should know __dirname\", function() {\n    return assert.equal(\"lib/test/pkg\", __dirname);\n  });\n  it(\"should know __filename\", function() {\n    return assert(__filename);\n  });\n  return it(\"should know its package\", function() {\n    return assert(PACKAGE);\n  });\n});\n\ndescribe(\"malformed package\", function() {\n  var malformedPackage;\n  malformedPackage = {\n    distribution: {\n      yolo: \"No content!\"\n    }\n  };\n  return it(\"should throw an error when attempting to require a malformed file in a package distribution\", function() {\n    var r;\n    r = require(requireSrc).generateFor(malformedPackage);\n    return assert.throws(function() {\n      return r.require(\"yolo\");\n    }, function(err) {\n      return !/malformed/i.test(err);\n    });\n  });\n});\n\ndescribe(\"dependent packages\", function() {\n  it(\"should allow for arbitrary characters\", function() {\n    var r;\n    r = require(requireSrc).generateFor({\n      dependencies: {\n        \"#$!jadelet\": {\n          entryPoint: \"main\",\n          distribution: {\n            main: {\n              content: \"module.exports = 'ok';\"\n            }\n          }\n        }\n      }\n    });\n    return assert.equal(r(\"#$!jadelet\"), \"ok\");\n  });\n  PACKAGE.dependencies[\"test-package\"] = {\n    distribution: {\n      main: {\n        content: \"module.exports = PACKAGE.name\"\n      }\n    }\n  };\n  PACKAGE.dependencies[\"strange/name\"] = {\n    distribution: {\n      main: {\n        content: \"\"\n      }\n    }\n  };\n  it(\"should raise an error when requiring a package that doesn't exist\", function() {\n    return assert.throws(function() {\n      return latestRequire(\"nonexistent\");\n    }, function(err) {\n      return /nonexistent/i.test(err);\n    });\n  });\n  it(\"should be able to require a package that exists\", function() {\n    return assert(latestRequire(\"test-package\"));\n  });\n  it(\"Dependent packages should know their names when required\", function() {\n    return assert.equal(latestRequire(\"test-package\"), \"test-package\");\n  });\n  return it(\"should be able to require by pretty much any name\", function() {\n    return assert(latestRequire(\"strange/name\"));\n  });\n});\n"},"lib/test/polyfill":{"content":"var endsWith, startsWith, _ref;\n\n_ref = require(\"../polyfill\"), startsWith = _ref.startsWith, endsWith = _ref.endsWith;\n\ndescribe(\"Polyfill\", function() {\n  return describe(\"String\", function() {\n    it(\"startsWith\", function() {\n      assert(\"\".startsWith);\n      assert.equal(startsWith.call(\"abcd\", \"ab\"), true);\n      assert.equal(startsWith.call(\"abcd\", \"ab\", -1), true);\n      assert.equal(startsWith.call(\"abcd\", \"ab\", 0), true);\n      assert.equal(startsWith.call(\"abcd\", \"ab\", 1), false);\n      return assert.equal(startsWith.call(\"abcd\", \"b\", 1), true);\n    });\n    return it(\"endsWith\", function() {\n      assert(\"\".endsWith);\n      assert.equal(endsWith.call(\"abcd\", \"cd\"), true);\n      return assert.equal(endsWith.call(\"raddad\", \"rad\", 3), true);\n    });\n  });\n});\n"},"lib/test/postmaster":{"content":"var Postmaster, dataUrl, htmlContent, randId, scriptContent, srcUrl, testFrame;\n\nPostmaster = require(\"/lib/postmaster\");\n\nrandId = function() {\n  return Math.random().toString(36).substr(2);\n};\n\nscriptContent = function() {\n  var fn;\n  fn = function() {\n    var pm;\n    return pm = Postmaster({\n      delegate: {\n        echo: function(value) {\n          return value;\n        },\n        throws: function() {\n          throw new Error(\"This always throws\");\n        },\n        promiseFail: function() {\n          return Promise.reject(new Error(\"This is a failed promise\"));\n        },\n        send: function() {\n          return pm.send.apply(pm, arguments);\n        }\n      }\n    });\n  };\n  return \"(function() {\\nvar module = {};\\n(function() {\\n\" + PACKAGE.distribution[\"lib/postmaster\"].content + \";\\n})();\\nvar Postmaster = module.exports;\\n(\" + (fn.toString()) + \")();\\n})();\";\n};\n\nhtmlContent = function() {\n  return \"<html>\\n  <body>\\n    <script>\" + (scriptContent()) + \"<\\/script>\\n  </body>\\n</html>\";\n};\n\nsrcUrl = function() {\n  return URL.createObjectURL(new Blob([htmlContent()], {\n    type: \"text/html; charset=utf-8\"\n  }));\n};\n\ndataUrl = function() {\n  return \"data:text/html;base64,\" + (btoa(htmlContent()));\n};\n\ntestFrame = function(fn) {\n  var iframe, postmaster;\n  iframe = document.createElement('iframe');\n  iframe.name = \"iframe-\" + (randId());\n  iframe.src = srcUrl();\n  document.body.appendChild(iframe);\n  postmaster = Postmaster({\n    remoteTarget: function() {\n      return iframe.contentWindow;\n    }\n  });\n  iframe.addEventListener(\"load\", function() {\n    return fn(postmaster)[\"finally\"](function() {\n      iframe.remove();\n      return postmaster.dispose();\n    });\n  });\n};\n\ndescribe(\"Postmaster\", function() {\n  it.skip(\"should work with openened windows\", function(done) {\n    var childWindow, postmaster;\n    childWindow = window.open(srcUrl(), \"child-\" + (randId()), \"width=200,height=200\");\n    postmaster = Postmaster({\n      remoteTarget: function() {\n        return childWindow;\n      }\n    });\n    childWindow.addEventListener(\"load\", function() {\n      return postmaster.send(\"echo\", 5).then(function(result) {\n        return assert.equal(result, 5);\n      }).then(function() {\n        return done();\n      }, function(error) {\n        return done(error);\n      }).then(function() {\n        childWindow.close();\n        return postmaster.dispose();\n      });\n    });\n  });\n  it(\"should work with iframes\", function(done) {\n    testFrame(function(postmaster) {\n      return postmaster.send(\"echo\", 17).then(function(result) {\n        return assert.equal(result, 17);\n      }).then(done, done);\n    });\n  });\n  it(\"should handle the remote call throwing errors\", function(done) {\n    testFrame(function(postmaster) {\n      return postmaster.send(\"throws\").then(function() {\n        return done(new Error(\"Expected an error\"));\n      }, function(error) {\n        return done();\n      });\n    });\n  });\n  it(\"should throwing a useful error when the remote doesn't define the function\", function(done) {\n    testFrame(function(postmaster) {\n      return postmaster.send(\"undefinedFn\").then(function() {\n        return done(new Error(\"Expected an error\"));\n      }, function(error) {\n        return done();\n      });\n    });\n  });\n  it(\"should handle the remote call returning failed promises\", function(done) {\n    testFrame(function(postmaster) {\n      return postmaster.send(\"promiseFail\").then(function() {\n        return done(new Error(\"Expected an error\"));\n      }, function(error) {\n        return done();\n      });\n    });\n  });\n  it(\"should be able to go around the world\", function(done) {\n    testFrame(function(postmaster) {\n      postmaster.yolo = function(txt) {\n        return \"heyy \" + txt;\n      };\n      return postmaster.send(\"send\", \"yolo\", \"cool\").then(function(result) {\n        return assert.equal(result, \"heyy cool\");\n      }).then(function() {\n        return done();\n      }, function(error) {\n        return done(error);\n      });\n    });\n  });\n  it.skip(\"should work with web workers\", function(done) {\n    var blob, jsUrl, postmaster, worker;\n    blob = new Blob([scriptContent()], {\n      type: \"application/javascript\"\n    });\n    jsUrl = URL.createObjectURL(blob);\n    worker = new Worker(jsUrl);\n    postmaster = Postmaster({\n      remoteTarget: function() {\n        return worker;\n      },\n      receiver: function() {\n        return worker;\n      }\n    });\n    setTimeout(function() {\n      return postmaster.send(\"echo\", 17).then(function(result) {\n        return assert.equal(result, 17);\n      }).then(function() {\n        return done();\n      }, function(error) {\n        return done(error);\n      })[\"finally\"](function() {\n        return worker.terminate();\n      });\n    }, 100);\n  });\n  it(\"should fail quickly when contacting a window that doesn't support Postmaster\", function(done) {\n    var childWindow, iframe, postmaster;\n    iframe = document.createElement('iframe');\n    document.body.appendChild(iframe);\n    childWindow = iframe.contentWindow;\n    postmaster = Postmaster({\n      remoteTarget: function() {\n        return childWindow;\n      },\n      ackTimeout: function() {\n        return 30;\n      }\n    });\n    postmaster.send(\"echo\", 5)[\"catch\"](function(e) {\n      if (e.message.match(/no ack/i)) {\n        return done();\n      } else {\n        return done(1);\n      }\n    })[\"finally\"](function() {\n      iframe.remove();\n      return postmaster.dispose();\n    });\n  });\n  it(\"should return a rejected promise when unable to send to the target\", function(done) {\n    var postmaster;\n    postmaster = Postmaster({\n      remoteTarget: function() {\n        return null;\n      }\n    });\n    postmaster.send(\"yo\").then(function() {\n      return done((function() {\n        throw new Error(\"Expected an error\");\n      })());\n    }, function(e) {\n      assert.equal(e.message, \"No remote target\");\n      return done();\n    })[\"catch\"](done)[\"finally\"](function() {\n      return postmaster.dispose();\n    });\n  });\n  return it(\"should log\", function() {\n    var called, postmaster;\n    called = false;\n    postmaster = Postmaster({\n      logger: {\n        info: function() {\n          return called = true;\n        }\n      }\n    });\n    assert(called);\n    return postmaster.dispose();\n  });\n});\n"},"lib/test/runtime":{"content":"var SystemClient, nullLogger, systemG;\n\nmocha.globals(['OBSERVABLE_ROOT_HACK', \"application\"]);\n\nsystemG = require(\"/lib/exports\");\n\nSystemClient = require(\"../runtime\");\n\nnullLogger = {\n  info: function() {},\n  debug: function() {}\n};\n\ndescribe(\"Runtime\", function() {\n  it(\"should return system and application proxies\", function() {\n    var app, application, system, _ref;\n    _ref = SystemClient(systemG), system = _ref.system, application = _ref.application;\n    assert(system);\n    assert(application);\n    app = system.app.Base();\n    assert.equal(app.currentPath(), \"\");\n    assert.equal(app.saved(), true);\n    return system.client.postmaster.dispose();\n  });\n  it(\"should queue up messages until a delegate is assigned\", function() {\n    return new Promise(function(resolve, reject) {\n      var application, postmaster, system, _ref;\n      _ref = SystemClient(systemG), system = _ref.system, application = _ref.application;\n      postmaster = system.client.postmaster;\n      postmaster.delegate.application(\"test1\", \"yo\").then(function(c) {\n        return assert.equal(c, \"wat\");\n      });\n      postmaster.delegate.application(\"test2\", \"yo2\").then(function(d) {\n        assert.equal(d, \"heyy\");\n        return resolve();\n      });\n      application.delegate = {\n        test1: function(a) {\n          assert.equal(a, \"yo\");\n          return \"wat\";\n        },\n        test2: function(b) {\n          assert.equal(b, \"yo2\");\n          return \"heyy\";\n        }\n      };\n      return system.client.postmaster.dispose();\n    });\n  });\n  it(\"should connect when ready is called\", function(done) {\n    var application, system, _ref;\n    _ref = SystemClient(systemG, {}), system = _ref.system, application = _ref.application;\n    system.host.ready().then(function() {\n      done();\n      return system.client.postmaster.dispose();\n    });\n  });\n  return it(\"should launch with config\", function() {\n    return systemG.launch({}, function(config) {\n      return system.client.postmaster.dispose();\n    });\n  });\n});\n"},"lib/test/ui":{"content":"var AceEditor, ui;\n\nAceEditor = (ui = require(\"../ui/index\")).AceEditor;\n\ndescribe(\"ui\", function() {\n  return it(\"should provide an ace editor view\", function() {\n    var initSession, modeFor;\n    initSession = AceEditor.initSession, modeFor = AceEditor.modeFor;\n    assert(initSession);\n    assert(modeFor);\n    return assert.equal(modeFor(\"file.js\"), \"javascript\");\n  });\n});\n"},"lib/test/ui/index":{"content":"\n"},"lib/test/util/index":{"content":"var copyToClipboard, deprecationWarning, fuzzyMatch, groupBy, lazyLoader, promiseChoke, throttle, urlSafeSHA256, _ref;\n\nrequire(\"/lib/extensions\");\n\n_ref = require(\"/lib/util/index\"), copyToClipboard = _ref.copyToClipboard, deprecationWarning = _ref.deprecationWarning, fuzzyMatch = _ref.fuzzyMatch, groupBy = _ref.groupBy, lazyLoader = _ref.lazyLoader, promiseChoke = _ref.promiseChoke, throttle = _ref.throttle, urlSafeSHA256 = _ref.urlSafeSHA256;\n\ndescribe(\"util\", function() {\n  describe(\"copyToClipboard\", function() {\n    return it(\"should copy a string to system clipboard\", function() {\n      return copyToClipboard(\"yolo\");\n    });\n  });\n  describe(\"deprecationWarning\", function() {\n    return it(\"should display an error when calling a deprecated function\", function() {\n      var yolo;\n      yolo = function(x, y) {\n        return x + y;\n      };\n      yolo = deprecationWarning(\"util.yolo is deprecated use based.swag instead\", yolo);\n      return (function(warn) {\n        var called;\n        called = false;\n        console.warn = function(msg) {\n          called = true;\n          return assert.equal(msg, \"util.yolo is deprecated use based.swag instead\");\n        };\n        assert.equal(yolo(5, 3), 8);\n        console.warn = warn;\n        return assert(called);\n      })(console.warn);\n    });\n  });\n  describe(\"fuzzyMatch\", function() {\n    return it(\"should match fuzzily\", function() {\n      var result;\n      assert(fuzzyMatch(\"\", [\"\"]));\n      assert(fuzzyMatch(\"\", [\"a\"]));\n      assert(fuzzyMatch(\"a\", [\"a\"]));\n      result = fuzzyMatch(\"acd\", [\"a gcac\", \"a cool dog\", \"achieved\", \"yoro\", \"what act duder\"]);\n      return assert.equal(result.length, 3);\n    });\n  });\n  describe(\"groupBy\", function() {\n    return it(\"should group arrays by fn\", function() {\n      var a, result;\n      a = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n      result = groupBy(a, function(n) {\n        return n % 3;\n      });\n      assert.deepEqual(result[0], [3, 6, 9]);\n      assert.deepEqual(result[1], [1, 4, 7]);\n      return assert.deepEqual(result[2], [2, 5, 8]);\n    });\n  });\n  describe(\"lazyLoader\", function() {\n    return it(\"should lazy load\", function() {\n      var LL, a, b;\n      LL = lazyLoader([]);\n      a = function(x) {\n        return x;\n      };\n      b = LL(a);\n      return b(0).then(function(x) {\n        return assert.equal(x, 0);\n      });\n    });\n  });\n  describe(\"promiseChoke\", function() {\n    it(\"should limit promise returning function execution to one at a time\", function() {\n      var called, fn;\n      called = 0;\n      fn = promiseChoke(function() {\n        called++;\n        return new Promise(function(resolve) {\n          return setTimeout(resolve);\n        });\n      });\n      fn();\n      fn();\n      return fn().then(function() {\n        return assert.equal(called, 1);\n      });\n    });\n    it(\"should reset on error\", function() {\n      var called, fn;\n      called = 0;\n      fn = promiseChoke(function() {\n        called++;\n        return new Promise(function(resolve, reject) {\n          return setTimeout(reject);\n        });\n      });\n      fn();\n      fn();\n      return fn()[\"catch\"](function() {\n        assert.equal(called, 1);\n        return fn()[\"catch\"](function() {\n          return assert.equal(called, 2);\n        });\n      });\n    });\n    return it(\"should key off of first argument\", function() {\n      var called, fn;\n      called = 0;\n      fn = promiseChoke(function(x) {\n        called++;\n        return new Promise(function(resolve) {\n          return setTimeout(function() {\n            return resolve(x);\n          });\n        });\n      });\n      fn(1);\n      fn(2);\n      return fn(5).then(function(v) {\n        assert.equal(v, 5);\n        return assert.equal(called, 3);\n      });\n    });\n  });\n  describe(\"throttle\", function() {\n    return it(\"should be called no more than once per time block\", function(done) {\n      var called, f;\n      called = 0;\n      f = throttle(15, function() {\n        return called += 1;\n      });\n      f();\n      f();\n      f();\n      setTimeout(function() {\n        return f();\n      });\n      setTimeout(function() {\n        return f();\n      }, 5);\n      setTimeout(function() {\n        return f();\n      }, 10);\n      return setTimeout(function() {\n        if (called !== 2) {\n          return done(new Error(\"Should have been called twice\"));\n        } else {\n          return done();\n        }\n      }, 20);\n    });\n  });\n  return describe(\"urlSafeSHA256\", function() {\n    return it(\"should create a URL safe SHA256 for the blob\", function() {\n      return urlSafeSHA256(new Blob([\"yolo\"])).then(function(str) {\n        return assert.equal(str, \"MR_j_u0Wuc2N8PixUXvly4YEhwffSIm6jcN9TWiGbQI\");\n      });\n    });\n  });\n});\n"},"lib/ui/drop":{"content":"module.exports = function(element, handler) {\n  var cancel;\n  cancel = function(e) {\n    e.preventDefault();\n    return false;\n  };\n  element.addEventListener(\"dragover\", cancel);\n  element.addEventListener(\"dragenter\", cancel);\n  return element.addEventListener(\"drop\", function(e) {\n    return handler(e);\n  });\n};\n"},"lib/ui/index":{"content":"var ContextMenuView, Jadelet, MenuBarView, MenuItemView, MenuView, Modal, Observable, ProgressView, Style, TableView, WindowView, applyStyle;\n\nrequire(\"/setup\");\n\nJadelet = require(\"../jadelet\");\n\nObservable = require(\"../observable\");\n\nStyle = require(\"/style\");\n\nContextMenuView = require(\"/views/context-menu\");\n\nModal = require(\"/modal\");\n\nMenuView = require(\"/views/menu\");\n\nMenuBarView = require(\"/views/menu-bar\");\n\nMenuItemView = require(\"/views/menu-item\");\n\nProgressView = require(\"/views/progress\");\n\nTableView = require(\"/views/table\");\n\nWindowView = require(\"/views/window\");\n\napplyStyle = function(styleContent, className) {\n  var escapedName, style;\n  if (className) {\n    escapedName = CSS.escape(className);\n    style = document.head.querySelector(\"style.\" + escapedName) || document.createElement(\"style\");\n    style.className = className;\n  } else {\n    style = document.createElement(\"style\");\n  }\n  style.innerHTML = styleContent;\n  return document.head.appendChild(style);\n};\n\nmodule.exports = {\n  AceEditor: require(\"/views/ace-editor\"),\n  applyStyle: applyStyle,\n  Bindable: require(\"../bindable\"),\n  ContextMenu: ContextMenuView,\n  Drop: require(\"./drop\"),\n  FuzzyListView: require(\"/views/fuzzy-list\"),\n  Jadelet: Jadelet,\n  Jadelet2: {\n    compile: Jadelet.exec\n  },\n  Login: require(\"/views/login\"),\n  Modal: Modal,\n  Model: require(\"../core\"),\n  Menu: MenuView,\n  MenuBar: MenuBarView,\n  MenuItem: MenuItemView,\n  Observable: Observable,\n  Progress: ProgressView,\n  Style: {\n    all: Style\n  },\n  Table: TableView,\n  Util: {\n    parseMenu: require(\"../indent-parse\")\n  },\n  Window: WindowView\n};\n"},"lib/util/index":{"content":"var base64URLEncode, bufferToBase64, copyToClipboard, digest, escapeRegex, loadScripts, scoreMatch,\n  __slice = [].slice;\n\nloadScripts = function(urls) {\n  return urls.reduce(function(p, url) {\n    return p.then(function() {\n      var script;\n      if (document.querySelector(\"script[src=\" + (JSON.stringify(url)) + \"]\")) {\n        return Promise.resolve();\n      }\n      script = document.createElement(\"script\");\n      script.src = url;\n      document.body.appendChild(script);\n      return new Promise(function(resolve, reject) {\n        script.onload = resolve;\n        return script.onerror = reject;\n      });\n    });\n  }, Promise.resolve());\n};\n\n\n/*\nCopy a string to user's OS (win,mac,linux) clipboard.\n */\n\ncopyToClipboard = function(str) {\n  var el;\n  el = document.createElement('textarea');\n  el.value = str;\n  el.setAttribute('readonly', '');\n  el.style.position = 'absolute';\n  el.style.left = '-9999px';\n  document.body.appendChild(el);\n  el.select();\n  document.execCommand('copy');\n  return document.body.removeChild(el);\n};\n\nbufferToBase64 = function(buffer) {\n  return window.btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)));\n};\n\nbase64URLEncode = function(base64String) {\n  return base64String.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\");\n};\n\ndigest = function(data) {\n  return crypto.subtle.digest(\"SHA-256\", data);\n};\n\nescapeRegex = function(string) {\n  return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n};\n\nscoreMatch = function(match) {\n  var lastMatch, pos;\n  if (!match) {\n    return;\n  }\n  lastMatch = -1;\n  pos = 0;\n  return match.slice(1).reduce(function(score, s, i) {\n    var value;\n    if (s.length === 0) {\n      value = 0;\n    } else {\n      if (i % 2 === 0) {\n        value = -s.length;\n      } else {\n        if (pos === 1 + lastMatch) {\n          lastMatch = pos;\n          value = 8;\n        } else {\n          value = 2;\n        }\n      }\n    }\n    pos += s.length;\n    return score + value;\n  }, 0);\n};\n\nmodule.exports = {\n  copyToClipboard: copyToClipboard,\n  deprecationWarning: function(msg, fn) {\n    if (typeof msg === \"function\") {\n      fn = msg;\n      msg = \"DEPRECATED\";\n    }\n    return function() {\n      console.warn(msg);\n      return fn.apply(this, arguments);\n    };\n  },\n  escapeRegex: escapeRegex,\n  fuzzyMatch: function(term, items, asString) {\n    var re;\n    if (asString == null) {\n      asString = String;\n    }\n    re = RegExp(\"^\" + term.split(\"\").map(function(c) {\n      return \"([^\" + (escapeRegex(c)) + \"]*)(\" + (escapeRegex(c)) + \")\";\n    }).join('') + '(.*)$', \"i\");\n    return items.map(function(item) {\n      var match;\n      if (match = asString(item).match(re)) {\n        return [item, scoreMatch(match)];\n      }\n    }).filter(function(result) {\n      return result != null;\n    }).sort(function(a, b) {\n      return b[1] - a[1];\n    }).map(function(result) {\n      return result[0];\n    });\n  },\n  groupBy: function(array, fn) {\n    return array.reduce(function(result, item) {\n      var _name;\n      (result[_name = fn(item)] != null ? result[_name] : result[_name] = []).push(item);\n      return result;\n    }, {});\n  },\n  loadScripts: loadScripts,\n  lazyLoader: function(urls) {\n    var loadingDeps, _load;\n    loadingDeps = null;\n    _load = function() {\n      if (loadingDeps) {\n        return loadingDeps;\n      }\n      return loadingDeps = loadScripts(urls)[\"catch\"](function(e) {\n        console.error(e);\n        loadingDeps = null;\n        throw e;\n      });\n    };\n    return function(fn) {\n      return function() {\n        var args, context;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        context = this;\n        return _load().then(function() {\n          return fn.apply(context, args);\n        });\n      };\n    };\n  },\n  Postmaster: require(\"../postmaster\"),\n  promiseChoke: function(fn) {\n    var cache;\n    cache = {};\n    return function(key) {\n      var cached;\n      cached = cache[key];\n      if (cached) {\n        return cached;\n      }\n      return cache[key] = fn(key)[\"finally\"](function() {\n        return delete cache[key];\n      });\n    };\n  },\n  throttle: function(wait, func) {\n    var args, context, later, previous, result, timeout;\n    context = args = result = void 0;\n    timeout = null;\n    previous = 0;\n    later = function() {\n      previous = Date.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) {\n        return context = args = null;\n      }\n    };\n    return function() {\n      var now, remaining;\n      now = Date.now();\n      remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) {\n          context = args = null;\n        }\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  },\n  urlSafeSHA256: function(blob) {\n    return blob.arrayBuffer().then(digest).then(bufferToBase64).then(base64URLEncode);\n  }\n};\n"},"main":{"content":"require(\"./lib/polyfill\");\n\nrequire(\"./lib/extensions\");\n\nif (PACKAGE.name === \"ROOT\") {\n  require(\"./demo\");\n}\n\nmodule.exports = require(\"./lib/exports\");\n"},"modal":{"content":"\n/*\nModal\n\nDisplay modal alerts or dialogs.\n\nModal has promise returning equivalents of the native browser:\n\n- Alert\n- Confirm\n- Prompt\n\nThese accept the same arguments and return a promise fulfilled with\nthe same return value as the native methods.\n\nYou can display any element in the modal:\n\n    modal.show myElement\n */\nvar CancelButtonTemplate, FocusTrap, InputTemplate, Jadelet, Modal, ModalTemplate, PromptTemplate, cancellable, closeHandler, empty, formDataToObject, handle, modal, prompt, _ref;\n\nJadelet = require(\"./lib/jadelet\");\n\n_ref = require(\"./util\"), formDataToObject = _ref.formDataToObject, handle = _ref.handle, empty = _ref.empty;\n\nPromptTemplate = require(\"./templates/modal/prompt\");\n\nModalTemplate = require(\"./templates/modal\");\n\nCancelButtonTemplate = require(\"./templates/cancel-button\");\n\nInputTemplate = require(\"./templates/input\");\n\nmodal = ModalTemplate();\n\nFocusTrap = Jadelet.exec(\"span(@focus tabindex=0)\");\n\ncancellable = true;\n\nmodal.onclick = function(e) {\n  if (e.target === modal && cancellable) {\n    return Modal.hide();\n  }\n};\n\ndocument.addEventListener(\"keydown\", function(e) {\n  if (!e.defaultPrevented) {\n    if (e.key === \"Escape\" && Modal.visible() && cancellable) {\n      e.preventDefault();\n      return Modal.hide();\n    }\n  }\n});\n\ndocument.body.appendChild(modal);\n\ncloseHandler = null;\n\nprompt = function(params) {\n  return new Promise(function(resolve) {\n    var element, _ref1;\n    element = PromptTemplate(params);\n    Modal.show(element, {\n      cancellable: false,\n      closeHandler: resolve\n    });\n    return (_ref1 = element.querySelector(params.focus)) != null ? _ref1.focus() : void 0;\n  });\n};\n\nmodule.exports = Modal = {\n  show: function(element, options) {\n    if (modal.classList.contains(\"active\")) {\n      Modal.hide();\n    }\n    if (typeof options === \"function\") {\n      closeHandler = options;\n    } else {\n      closeHandler = options != null ? options.closeHandler : void 0;\n      if ((options != null ? options.cancellable : void 0) != null) {\n        cancellable = options.cancellable;\n      }\n    }\n    empty(modal).appendChild(element);\n    return modal.classList.add(\"active\");\n  },\n  hide: function(dataForHandler) {\n    if (typeof closeHandler === \"function\") {\n      closeHandler(dataForHandler);\n    }\n    modal.classList.remove(\"active\");\n    cancellable = true;\n    return empty(modal);\n  },\n  visible: function() {\n    return modal.classList.contains(\"active\");\n  },\n  alert: function(message) {\n    return prompt({\n      title: \"Alert\",\n      message: message,\n      focus: \"button\",\n      confirm: handle(function() {\n        return Modal.hide();\n      })\n    });\n  },\n  prompt: function(message, defaultValue, title) {\n    if (defaultValue == null) {\n      defaultValue = \"\";\n    }\n    if (title == null) {\n      title = \"Prompt\";\n    }\n    return prompt({\n      title: title,\n      message: message,\n      focus: \"input\",\n      inputElement: InputTemplate({\n        type: \"text\",\n        value: defaultValue\n      }),\n      cancelButton: CancelButtonTemplate({\n        cancel: handle(function() {\n          return Modal.hide(null);\n        })\n      }),\n      confirm: handle(function() {\n        return Modal.hide(modal.querySelector(\"input\").value);\n      })\n    });\n  },\n  confirm: function(message, title) {\n    if (title == null) {\n      title = \"Confirm\";\n    }\n    return prompt({\n      title: title,\n      message: message,\n      focus: \"button\",\n      cancelButton: CancelButtonTemplate({\n        cancel: handle(function() {\n          return Modal.hide(false);\n        })\n      }),\n      confirm: handle(function() {\n        return Modal.hide(true);\n      })\n    });\n  },\n  form: function(formElement, options) {\n    if (options == null) {\n      options = {};\n    }\n    cancellable = options.cancellable;\n    if (cancellable == null) {\n      cancellable = false;\n    }\n    return new Promise(function(resolve) {\n      var focusFirstElement, focusTrap, submitHandler;\n      submitHandler = handle(function(e) {\n        var formData, result;\n        formData = new FormData(formElement);\n        result = formDataToObject(formData);\n        return Modal.hide(result);\n      });\n      formElement.addEventListener(\"submit\", submitHandler);\n      focusFirstElement = function(e) {\n        var el;\n        el = formElement.querySelector(\"button,\\n[href],\\ninput,\\nselect,\\ntextarea,\\n[tabindex]:not([tabindex=\\\"-1\\\"])\");\n        if (el) {\n          if (e != null) {\n            e.preventDefault();\n          }\n          return el.focus();\n        }\n      };\n      Modal.show(formElement, {\n        cancellable: cancellable,\n        closeHandler: function(result) {\n          formElement.removeEventListener(\"submit\", submitHandler);\n          focusTrap.remove();\n          return resolve(result);\n        }\n      });\n      focusFirstElement();\n      focusTrap = FocusTrap({\n        focus: focusFirstElement\n      });\n      formElement.appendChild(focusTrap);\n    });\n  }\n};\n"},"pixie":{"content":"module.exports = {\n  \"name\": \"system\",\n  \"version\": \"0.5.3\",\n  \"publishPath\": \"/My Briefcase/public/danielx.net/\",\n  \"dependencies\": {},\n  \"remoteDependencies\": [\n    \"https://danielx.net/cdn/dexie/2.0.4.min.js\"\n  ],\n  \"cognito\": {\n    \"identityPoolId\": \"us-east-1:4fe22da5-bb5e-4a78-a260-74ae0a140bf9\",\n    \"poolData\": {\n      \"UserPoolId\": \"us-east-1_cfvrlBLXG\",\n      \"ClientId\": \"3fd84r6idec9iork4e9l43mp61\"\n    }\n  }\n};"},"plugin/prometheus-preview":{"content":"require(\"../setup\");\n"},"samples/notepad-menu":{"content":"module.exports = \"[F]ile\\n  [N]ew\\n  [O]pen\\n  [S]ave\\n  Save [A]s\\n  -\\n  Page Set[u]p\\n  [P]rint\\n  -\\n  E[x]it\\n[E]dit\\n  [U]ndo\\n  Redo\\n  -\\n  Cu[t]\\n  [C]opy\\n  [P]aste\\n  De[l]ete\\n  -\\n  [F]ind\\n  Find [N]ext\\n  [R]eplace\\n  [G]o To\\n  -\\n  Select [A]ll\\n  Time/[D]ate\\nF[o]rmat\\n  [W]ord Wrap\\n  [F]ont...\\n[V]iew\\n  [S]tatus Bar\\n[H]elp\\n  View [H]elp\\n  -\\n  [A]bout Notepad\";\n"},"samples/test-form":{"content":"module.exports = system.ui.Jadelet.exec([\"form\",{},[[\"h1\",{},[\"Cool Form Bro\"]],[\"p\",{},[[\"a\",{\"href\":\"https://yolo.biz\"},[\"Yolo\"]],[\"a\",{\"class\":[\"button\"]},[\"Link Button\"]]]],[\"input\",{\"name\":\"yolo\"},[]],[\"input\",{\"name\":\"x\",\"value\":\"Lorem\"},[]],[\"input\",{\"name\":\"y\",\"value\":\"florem\"},[]],[\"input\",{\"name\":\"z\",\"type\":\"number\",\"value\":\"5\"},[]],[\"input\",{\"name\":\"file\",\"type\":\"file\"},[]],[\"textarea\",{\"name\":\"text\"},[]],[\"button\",{},[\"Submit\"]],[\"button\",{\"click\":{\"bind\":\"cancel\"}},[\"Cancel\"]]]]);"},"setup":{"content":"var _base, _base1;\n\nrequire(\"./lib/polyfill\");\n\nif (global.system == null) {\n  global.system = {};\n}\n\nif ((_base = global.system).ui == null) {\n  _base.ui = {};\n}\n\nif ((_base1 = global.system.ui).Jadelet == null) {\n  _base1.Jadelet = require(\"./lib/jadelet\");\n}\n"},"style":{"content":"module.exports = \"@font-face {\\n  font-family: 'Fira Sans';\\n  font-style: normal;\\n  font-weight: 400;\\n  src: local('Fira Sans Regular'), local('FiraSans-Regular'), url(\\\"https://danielx.net/fonts/FiraSans-v10-Regular.woff2\\\") format('woff2');\\n  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;\\n}\\n@font-face {\\n  font-family: 'Fira Sans';\\n  font-style: italic;\\n  font-weight: 400;\\n  src: local('Fira Sans Italic'), local('FiraSans-Italic'), url(\\\"https://danielx.net/fonts/FiraSans-v10-Italic.woff2\\\") format('woff2');\\n  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;\\n}\\n@font-face {\\n  font-family: 'Fira Sans';\\n  font-style: normal;\\n  font-weight: 700;\\n  src: local('Fira Sans Bold'), local('FiraSans-Bold'), url(\\\"https://danielx.net/fonts/FiraSans-v10-Bold.woff2\\\") format('woff2');\\n  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;\\n}\\n/*\\nInspiration\\nhttps://lospec.com/palette-list/hyperchill-10\\n#ffb845\\n#fb7974\\n#f97698\\n#ce5f9f\\n#a348a6\\n#8549ad\\n#674ab3\\n#556dc8\\n#6783db\\n#7998ee\\n*/\\n:root {\\n  --neutral-light: rgba(255,255,255,0.5);\\n  --neutral-faintest: #efefef;\\n  --neutral-faint: rgba(0,0,0,0.25);\\n  --neutral-dark: rgba(0,0,0,0.5);\\n  --neutral-darker: rgba(0,0,0,0.875);\\n  --shadow-low: 1px 2px 0;\\n  --shadow-medium: 4px 4px 0;\\n  --border-radius: 0;\\n  --background-color: #fff;\\n  --background-neutral: #dcdcdc;\\n  --dark-subdued-color: #000080;\\n  --error-color: #800;\\n  --highlight-color: #ffb845;\\n  --hover-color: #d2d9ef;\\n  --primary-color: #8549ad;\\n  --text-color: rgba(0,0,0,0.938);\\n  --text-primary-color: #fff;\\n}\\n* {\\n  box-sizing: border-box;\\n}\\nhtml {\\n  color: var(--text-color);\\n  font-family: 'Fira Sans', Sans-Serif;\\n  font-size: 16px;\\n  line-height: 1.5;\\n}\\nbody,\\nhtml {\\n  height: 100%;\\n}\\nbody {\\n  display: flex;\\n  flex-direction: column;\\n  margin: 0;\\n}\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6 {\\n  margin: 0;\\n}\\niframe {\\n  border: none;\\n}\\np {\\n  margin: 0 0 1rem;\\n}\\nul {\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n}\\ninput,\\ntextarea,\\nkeygen,\\nselect,\\nbutton {\\n  color: inherit;\\n  font: inherit;\\n  line-height: inherit;\\n}\\n:focus-visible {\\n  outline: 2px solid var(--text-color);\\n}\\n::-webkit-scrollbar {\\n  border: 1px solid var(--neutral-darker);\\n  background-color: var(--background-neutral);\\n  border-radius: var(--border-radius);\\n}\\n::-webkit-scrollbar-thumb {\\n  background-color: var(--background-color);\\n  border: 1px solid var(--neutral-darker);\\n  border-radius: var(--border-radius);\\n}\\n::-webkit-scrollbar-thumb:hover {\\n  background-color: var(--neutral-faintest);\\n}\\nbutton,\\na.button,\\ninput[type=\\\"file\\\"]::file-selector-button {\\n  background-color: var(--background-color);\\n  border: 1px solid var(--neutral-darker);\\n  border-radius: var(--border-radius);\\n  box-shadow: var(--shadow-low) var(--neutral-dark);\\n  cursor: pointer;\\n  display: inline-block;\\n  padding: 0.125em 0.375em;\\n}\\nbutton:hover,\\na.button:hover {\\n  background-color: var(--neutral-faintest);\\n}\\nbutton:active,\\na.button:active,\\nbutton.active,\\na.button.active {\\n  background-color: var(--neutral-faintest);\\n  box-shadow: var(--shadow-low) var(--neutral-dark) inset;\\n}\\ninput[type=\\\"file\\\"]:hover::file-selector-button {\\n  background-color: var(--neutral-faintest);\\n}\\ninput[type=\\\"file\\\"]:active::file-selector-button,\\ninput[type=\\\"file\\\"].active::file-selector-button {\\n  background-color: var(--neutral-faintest);\\n  box-shadow: var(--shadow-low) var(--neutral-dark) inset;\\n}\\ninput,\\ntextarea {\\n  border: 1px solid var(--neutral-darker);\\n  border-radius: var(--border-radius);\\n  box-shadow: var(--shadow-low) var(--neutral-dark) inset;\\n  padding: 0.125em 0.25em;\\n}\\ninput::placeholder,\\ntextarea::placeholder {\\n  font-style: italic;\\n}\\ninput[type=\\\"file\\\"] {\\n  border-width: 0;\\n  box-shadow: none;\\n  padding: 3px 0;\\n}\\nlabel > input,\\nlabel > textarea,\\nlabel > select {\\n  width: 100%;\\n}\\nloader {\\n  display: block;\\n  padding: 1em;\\n}\\nloader > p:empty {\\n  margin: 0;\\n}\\nloader > progress {\\n  display: block;\\n}\\nmenu {\\n  user-select: none;\\n  -webkit-user-select: none;\\n  -ms-user-select: none;\\n  background-color: var(--background-neutral);\\n  border-bottom: 1px solid var(--neutral-dark);\\n  line-height: 1.25;\\n  margin: 0;\\n  z-index: 1;\\n}\\nmenu:focus {\\n  outline: none;\\n}\\nmenu.context {\\n  z-index: 2000;\\n}\\nmenu-item {\\n  display: block;\\n  list-style-type: none;\\n}\\nmenu-item.active {\\n  background-color: var(--dark-subdued-color);\\n  color: var(--text-primary-color);\\n}\\nmenu-item > label {\\n  display: flex;\\n  padding: 0 0.25rem;\\n  white-space: nowrap;\\n}\\nmenu-item > label > * {\\n  flex: 1 1 auto;\\n}\\nmenu-item > label > span.hotkey {\\n  margin-left: 1rem;\\n}\\nmenu-item > label > span.hotkey:empty {\\n  margin-left: 0;\\n}\\nmenu-item > label > .decoration {\\n  align-self: center;\\n  flex: 0 1 auto;\\n  text-align: right;\\n  margin-left: 0.5rem;\\n}\\nmenu-item > label > .decoration:empty {\\n  margin-left: 0;\\n}\\nmenu-item[disabled] {\\n  color: #808080;\\n}\\nmenu-item[disabled].active {\\n  background-color: rgba(0,0,0,0.125);\\n}\\nmenu.options {\\n  border-top: 1px solid var(--neutral-light);\\n  border-left: 1px solid var(--neutral-light);\\n  border-right: 1px solid var(--neutral-dark);\\n  box-shadow: var(--shadow-low) var(--neutral-dark);\\n  display: none;\\n  padding: 2px;\\n  padding-bottom: 3px;\\n  position: absolute;\\n}\\nmenu.options.active {\\n  display: block;\\n}\\nmenu.options > menu-item.menu {\\n  position: relative;\\n}\\nmenu.options > menu-item.menu > menu {\\n  position: absolute;\\n  left: 100%;\\n  top: -3px;\\n  margin-left: 1px;\\n}\\nmenu-item.menu.active > menu {\\n  background-color: var(--background-neutral);\\n  color: var(--text-color);\\n  display: block;\\n}\\nmenu.bar {\\n  display: block;\\n  flex: 0 0 auto;\\n  margin: 0;\\n  padding: 0;\\n  position: initial;\\n  white-space: nowrap;\\n  overflow: hidden;\\n}\\nmenu.bar > menu-item {\\n  display: inline-block;\\n}\\nmenu.bar > menu-item > label > .decoration {\\n  display: none;\\n}\\nmenu.bar.accelerator-active span.accelerator {\\n  text-decoration: underline;\\n}\\nmenu.options.bottoms-up menu-item.menu > menu {\\n  top: initial;\\n  bottom: -4px;\\n}\\n#modal {\\n  align-items: center;\\n  background-color: var(--neutral-faint);\\n  display: none;\\n  justify-content: center;\\n  position: absolute;\\n  z-index: 10000;\\n  top: 0;\\n  width: 100%;\\n  height: 100%;\\n}\\n#modal.active {\\n  display: flex;\\n}\\n#modal > * {\\n  background-color: var(--background-color);\\n  border: 1px solid var(--neutral-dark);\\n  border-radius: var(--border-radius);\\n  box-shadow: var(--shadow-medium) var(--neutral-dark);\\n  max-width: 90%;\\n  max-height: 90%;\\n  position: relative;\\n  z-index: 1;\\n}\\n#modal > form {\\n  display: block;\\n  padding: 1rem;\\n}\\n#modal > form > h1,\\n#modal > form > h2 {\\n  font-size: 1.5rem;\\n  line-height: 1.5rem;\\n  margin-bottom: 0.5rem;\\n}\\n#modal > form > input,\\n#modal > form > textarea {\\n  display: block;\\n  margin-bottom: 1rem;\\n  width: 100%;\\n}\\n#modal > form > button {\\n  margin-right: 1rem;\\n}\\n#modal > form > button:last-child {\\n  margin-right: 0;\\n}\\n#modal > section.ws-login {\\n  padding: 2rem;\\n  position: relative;\\n}\\n#modal > section.ws-login > form {\\n  margin-right: 0;\\n  width: 400px;\\n}\\n#modal > section.ws-login > form > h1 {\\n  margin-top: 0;\\n}\\n#modal > section.ws-login > form > section > button.top-left {\\n  position: absolute;\\n  top: 0.5rem;\\n  left: 0.5rem;\\n}\\n#modal > form.fuzzy-list {\\n  display: flex;\\n  flex-direction: column;\\n  width: 66.6%;\\n  height: 66.6%;\\n}\\nform.fuzzy-list > input {\\n  width: 100%;\\n}\\nform.fuzzy-list > ul {\\n  flex: 1 1 auto;\\n  overflow: auto;\\n}\\nform.fuzzy-list > ul > li {\\n  cursor: pointer;\\n}\\nform.fuzzy-list > ul > li:nth-child(even) {\\n  background-color: var(--neutral-faintest);\\n}\\nform.fuzzy-list > ul > li:hover {\\n  background-color: var(--hover-color);\\n}\\nform.fuzzy-list > ul > li.active {\\n  background-color: var(--highlight-color);\\n}\\n@media only screen and (max-width: 768px) {\\n  #modal > form.fuzzy-list {\\n    width: 90%;\\n    height: 90%;\\n  }\\n}\\ncontainer {\\n  display: block;\\n  height: 100%;\\n  overflow: auto;\\n  width: 100%;\\n}\\ntable {\\n  border-collapse: collapse;\\n  width: 100%;\\n}\\nth {\\n  text-align: left;\\n}\\nthead {\\n  border-bottom: 1px solid var(--neutral-darker);\\n}\\ntd > input {\\n  border: none;\\n  box-shadow: none;\\n  background-color: transparent;\\n  padding: 0;\\n  width: 100%;\\n}\\ntr:nth-child(even) {\\n  background-color: var(--neutral-faintest);\\n}\\nwindow {\\n  user-select: none;\\n  -webkit-user-select: none;\\n  -ms-user-select: none;\\n  background-color: var(--background-neutral);\\n  border: 4px double var(--neutral-darker);\\n  border-radius: var(--border-radius);\\n  box-shadow: var(--shadow-low) var(--neutral-dark);\\n  display: flex;\\n  flex-direction: column;\\n  position: absolute;\\n}\\nwindow > header {\\n  background-color: var(--dark-subdued-color);\\n  border-bottom: 1px solid var(--neutral-darker);\\n  cursor: default;\\n  display: flex;\\n  flex: 0 0 auto;\\n  line-height: 18px;\\n}\\nwindow > header > icon {\\n  background-position: 50%;\\n  background-repeat: no-repeat;\\n  background-size: 16px;\\n  color: var(--text-primary-color);\\n  display: inline-block;\\n  flex: 0 0 auto;\\n  text-align: center;\\n  width: 0;\\n}\\nwindow > header > control {\\n  align-items: center;\\n  background-color: var(--background-neutral);\\n  border-left: 1px solid var(--neutral-darker);\\n  color: var(--text-primary-color);\\n  cursor: pointer;\\n  display: inline-flex;\\n  flex: 0 0 auto;\\n  font-family: 'Fira Code', monospace;\\n  justify-content: center;\\n  overflow: hidden;\\n  text-shadow: 1px 0px 0px #000, -1px 0px 0px #000, 0px -1px 0px #000, 0px 1px 0px #000, 1px 1px 0px #808080;\\n  width: 18px;\\n}\\nwindow > header > control:first-child {\\n  border-left: none;\\n}\\nwindow > header > control.close::before {\\n  content: \\\"X\\\";\\n}\\nwindow > header > control.maximize::before {\\n  content: \\\"+\\\";\\n}\\nwindow > header > control.minimize::before {\\n  content: \\\"-\\\";\\n}\\nwindow > header > control.restore {\\n  display: none;\\n}\\nwindow > header > control.restore::before {\\n  content: \\\"-\\\";\\n}\\nwindow > header > title-bar {\\n  color: var(--text-primary-color);\\n  display: inline-block;\\n  flex: 1 1 auto;\\n  overflow: hidden;\\n  padding: 0 1rem 0 6px;\\n  text-overflow: ellipsis;\\n  white-space: nowrap;\\n}\\nwindow > viewport {\\n  background-color: #fff;\\n  display: flex;\\n  height: 100%;\\n  overflow: auto;\\n  position: relative;\\n  z-index: 0;\\n}\\nwindow > viewport > * {\\n  margin: auto;\\n}\\nwindow > viewport > textarea {\\n  border: none;\\n  font-family: monospace;\\n  height: 100%;\\n  padding: 2px 4px;\\n  resize: none;\\n  width: 100%;\\n}\\nwindow > viewport > section.ace_editor {\\n  width: 100%;\\n  height: 100%;\\n}\\nwindow > viewport > iframe {\\n  border: none;\\n  height: 100%;\\n  width: 100%;\\n  position: absolute;\\n}\\nwindow > resize {\\n  border-color: var(--neutral-darker);\\n  display: block;\\n  position: absolute;\\n}\\nwindow > resize.e,\\nwindow > resize.w {\\n  cursor: ew-resize;\\n}\\nwindow > resize.n,\\nwindow > resize.s {\\n  cursor: ns-resize;\\n}\\nwindow > resize.h {\\n  height: 4px;\\n  width: 100%;\\n}\\nwindow > resize.v {\\n  height: 100%;\\n  width: 4px;\\n}\\nwindow > resize.w {\\n  left: -4px;\\n}\\nwindow > resize.e {\\n  right: -4px;\\n}\\nwindow > resize.n {\\n  top: -4px;\\n}\\nwindow > resize.s {\\n  bottom: -4px;\\n}\\nwindow > resize.n.w {\\n  cursor: nw-resize;\\n}\\nwindow > resize.n.e {\\n  cursor: ne-resize;\\n}\\nwindow > resize.s.e {\\n  cursor: se-resize;\\n}\\nwindow > resize.s.w {\\n  cursor: sw-resize;\\n}\\nwindow > resize.n.v {\\n  border-bottom: 1px solid;\\n  height: 23px;\\n}\\nwindow > resize.s.v {\\n  border-top: 1px solid;\\n  height: 23px;\\n}\\nwindow > resize.e.h {\\n  border-left: 1px solid;\\n  width: 22px;\\n}\\nwindow > resize.w.h {\\n  border-right: 1px solid;\\n  width: 22px;\\n}\\nwindow.minimized > header {\\n  border-bottom: none;\\n}\\nwindow.minimized > header > control {\\n  display: none;\\n}\\nwindow.minimized > header > control.minimize {\\n  border-right: none;\\n  display: inline-flex;\\n}\\nwindow.minimized > header > control.minimize::before {\\n  content: \\\"+\\\";\\n}\\nwindow.minimized > menu,\\nwindow.minimized > resize,\\nwindow.minimized > viewport {\\n  display: none;\\n}\\nwindow.maximized {\\n  border: none;\\n  border-radius: 0;\\n  height: 100%;\\n  width: 100%;\\n}\\nwindow.maximized > resize {\\n  display: none;\\n}\\nwindow.maximized > header {\\n  position: absolute;\\n  right: 0;\\n  z-index: 2;\\n}\\nwindow.maximized > header > control {\\n  display: none;\\n}\\nwindow.maximized > header > control.restore,\\nwindow.maximized > header > control.close {\\n  display: inline-flex;\\n}\\nframe-guard {\\n  display: block;\\n  height: 100%;\\n  left: 0;\\n  pointer-events: none;\\n  position: fixed;\\n  top: 0;\\n  width: 100%;\\n  z-index: 100000;\\n}\\nframe-guard.active {\\n  pointer-events: auto;\\n}\\n\";"},"style/demo":{"content":"module.exports = \"desktop {\\n  display: block;\\n  flex: 1 0 auto;\\n  position: relative;\\n  z-index: 0;\\n}\\n\";"},"templates/cancel-button":{"content":"module.exports = system.ui.Jadelet.exec([\"button\",{\"click\":{\"bind\":\"cancel\"}},[\"Cancel\"]]);"},"templates/input":{"content":"module.exports = system.ui.Jadelet.exec([\"input\",{\"value\":{\"bind\":\"value\"},\"type\":{\"bind\":\"type\"}},[]]);"},"templates/menu-item":{"content":"module.exports = system.ui.Jadelet.exec([\"menu-item\",{\"class\":[{\"bind\":\"class\"}],\"click\":{\"bind\":\"click\"},\"mousemove\":{\"bind\":\"mousemove\"},\"disabled\":{\"bind\":\"disabled\"}},[[\"label\",{},[{\"bind\":\"title\"},[\"span\",{\"class\":[\"hotkey\"]},[{\"bind\":\"hotkey\"}]],[\"span\",{\"class\":[\"decoration\"]},[{\"bind\":\"decoration\"}]]]],{\"bind\":\"content\"}]]);"},"templates/menu-separator":{"content":"module.exports = system.ui.Jadelet.exec([\"menu-item\",{},[[\"hr\",{},[]]]]);"},"templates/menu":{"content":"module.exports = system.ui.Jadelet.exec([\"menu\",{\"class\":[{\"bind\":\"class\"}],\"click\":{\"bind\":\"click\"},\"style\":[{\"bind\":\"style\"}]},[{\"bind\":\"items\"}]]);"},"templates/modal":{"content":"module.exports = system.ui.Jadelet.exec([\"div\",{\"id\":[\"modal\"]},[]]);"},"templates/modal/prompt":{"content":"module.exports = system.ui.Jadelet.exec([\"form\",{\"submit\":{\"bind\":\"confirm\"},\"tabindex\":\"-1\"},[[\"h1\",{},[{\"bind\":\"title\"}]],[\"p\",{},[{\"bind\":\"message\"}]],{\"bind\":\"inputElement\"},[\"button\",{},[\"OK\"]],{\"bind\":\"cancelButton\"}]]);"},"templates/progress":{"content":"module.exports = system.ui.Jadelet.exec([\"loader\",{},[[\"p\",{},[{\"bind\":\"message\"}]],[\"progress\",{\"class\":[{\"bind\":\"class\"}],\"value\":{\"bind\":\"value\"},\"max\":{\"bind\":\"max\"}},[]]]]);"},"templates/reader-input":{"content":"module.exports = function(options) {\n  var input;\n  if (options == null) {\n    options = {};\n  }\n  input = document.createElement('input');\n  input.type = \"file\";\n  input.setAttribute(\"accept\", options.accept);\n  input.onchange = function(e) {\n    return typeof options.select === \"function\" ? options.select(input.files[0]) : void 0;\n  };\n  return input;\n};\n"},"templates/table":{"content":"module.exports = system.ui.Jadelet.exec([\"container\",{},[[\"table\",{\"keydown\":{\"bind\":\"keydown\"}},[[\"thead\",{},[{\"bind\":\"headerElements\"}]],[\"tbody\",{},[]]]]]]);"},"templates/window":{"content":"module.exports = system.ui.Jadelet.exec([\"window\",{\"class\":[{\"bind\":\"class\"}]},[[\"resize\",{\"class\":[\"n\",\"h\"]},[]],[\"resize\",{\"class\":[\"e\",\"v\"]},[]],[\"resize\",{\"class\":[\"s\",\"h\"]},[]],[\"resize\",{\"class\":[\"w\",\"v\"]},[]],[\"resize\",{\"class\":[\"n\",\"e\",\"h\"]},[]],[\"resize\",{\"class\":[\"n\",\"e\",\"v\"]},[]],[\"resize\",{\"class\":[\"n\",\"w\",\"h\"]},[]],[\"resize\",{\"class\":[\"n\",\"w\",\"v\"]},[]],[\"resize\",{\"class\":[\"s\",\"e\",\"h\"]},[]],[\"resize\",{\"class\":[\"s\",\"e\",\"v\"]},[]],[\"resize\",{\"class\":[\"s\",\"w\",\"h\"]},[]],[\"resize\",{\"class\":[\"s\",\"w\",\"v\"]},[]],[\"header\",{},[[\"icon\",{\"style\":[{\"bind\":\"iconStyle\"}]},[{\"bind\":\"iconEmoji\"}]],[\"title-bar\",{\"dblclick\":{\"bind\":\"maximize\"}},[{\"bind\":\"title\"}]],[\"control\",{\"class\":[\"minimize\"],\"click\":{\"bind\":\"minimize\"}},[]],[\"control\",{\"class\":[\"maximize\"],\"click\":{\"bind\":\"maximize\"}},[]],[\"control\",{\"class\":[\"restore\"],\"click\":{\"bind\":\"restore\"}},[]],[\"control\",{\"class\":[\"close\"],\"click\":{\"bind\":\"close\"}},[]]]],{\"bind\":\"menuBar\"},[\"viewport\",{},[{\"bind\":\"content\"}]]]]);"},"test/menu-item":{"content":"var MenuItemView, Observable;\n\nPACKAGE.name = \"test\";\n\nrequire(\"../main\");\n\nMenuItemView = require(\"../views/menu-item\");\n\nObservable = require(\"../lib/observable\");\n\ndescribe(\"MenuItem\", function() {\n  return it(\"should have correct custom action names\", function() {\n    var called, menuItem;\n    called = false;\n    menuItem = MenuItemView({\n      label: \"Cool -> Super Cool\",\n      contextRoot: {\n        activeItem: function() {},\n        handlers: {\n          \"Super Cool\": function() {\n            return called = true;\n          }\n        }\n      }\n    });\n    assert(!called);\n    menuItem.click();\n    return assert(called);\n  });\n});\n"},"test/menu-parser":{"content":"var parse;\n\nparse = require(\"../lib/indent-parse\");\n\ndescribe(\"Menu Parser\", function() {\n  it(\"should parse menus into lists\", function() {\n    var data, results;\n    data = \"File\";\n    results = parse(data);\n    return assert.deepEqual([\"File\"], results);\n  });\n  it(\"should parse empty\", function() {\n    var data;\n    data = \"\";\n    return assert.deepEqual([], parse(data));\n  });\n  it(\"should deal with nesting ok\", function() {\n    var data, results;\n    data = \"File\\n  Open\\n  Save\\nEdit\\n  Copy\\n  Paste\\nHelp\";\n    results = parse(data);\n    return assert.deepEqual([[\"File\", [\"Open\", \"Save\"]], [\"Edit\", [\"Copy\", \"Paste\"]], \"Help\"], results);\n  });\n  it(\"should parse big ol' menus\", function() {\n    var results;\n    results = parse(\"File\\n  New\\n  Open\\n  Save\\n  Save As\\nEdit\\n  Undo\\n  Redo\\n  -\\n  Cut\\n  Copy\\n  Paste\\n  Delete\\n  -\\n  Find\\n  Find Next\\n  Replace\\n  Go To\\n  -\\n  Select All\\n  Time/Date\\nFormat\\n  Word Wrap\\n  Font...\\nView\\n  Status Bar\\nHelp\\n  View Help\\n  -\\n  About Notepad\");\n    return assert.deepEqual([[\"File\", [\"New\", \"Open\", \"Save\", \"Save As\"]], [\"Edit\", [\"Undo\", \"Redo\", \"-\", \"Cut\", \"Copy\", \"Paste\", \"Delete\", \"-\", \"Find\", \"Find Next\", \"Replace\", \"Go To\", \"-\", \"Select All\", \"Time/Date\"]], [\"Format\", [\"Word Wrap\", \"Font...\"]], [\"View\", [\"Status Bar\"]], [\"Help\", [\"View Help\", \"-\", \"About Notepad\"]]], results);\n  });\n  return it(\"should parse hella nested menus\", function() {\n    var results;\n    results = parse(\"File\\n  Special\\n    Nested\\n      Super\\n        Awesome\");\n    return assert.deepEqual([[\"File\", [[\"Special\", [[\"Nested\", [[\"Super\", [\"Awesome\"]]]]]]]]], results);\n  });\n});\n"},"test/menu":{"content":"var MenuView, Observable;\n\nMenuView = require(\"../views/menu\");\n\nObservable = require(\"../lib/observable\");\n\ndescribe(\"Menu\", function() {\n  it(\"should work with plain ol' items\", function() {\n    var menu;\n    menu = MenuView({\n      items: [\"Cool\", \"Rad\"],\n      contextRoot: {\n        activeItem: Observable(null),\n        handlers: {}\n      }\n    });\n    return assert.equal(menu.items().length, 2);\n  });\n  return it(\"should allow observable items\", function() {\n    var items, menu;\n    items = Observable([\"Cool\", [\"Rad\", [\"2rad\", \"2Furious\"]]]);\n    menu = MenuView({\n      items: items,\n      contextRoot: {\n        activeItem: Observable(null),\n        handlers: {}\n      }\n    });\n    assert.equal(menu.items().length, 2);\n    items([\"New Stuff\"]);\n    return assert.equal(menu.items().length, 1);\n  });\n});\n"},"test/modal":{"content":"var Modal;\n\nPACKAGE.name = \"test\";\n\nModal = require(\"../lib/ui/index\").Modal;\n\ndescribe(\"Modal\", function() {\n  return it(\"shoud be totally chill\", function() {\n    var called, element, handler;\n    element = document.createElement(\"p\");\n    called = false;\n    handler = function(value) {\n      called = true;\n      return assert.equal(value, \"yolo\");\n    };\n    Modal.show(element, handler);\n    Modal.hide('yolo');\n    return assert(called);\n  });\n});\n"},"util":{"content":"var A, F, Observable, S, Util, accelerateItem, advance, asElement, elementView, empty, entityMap, formDataToObject, get, handle, isDescendant, o;\n\nObservable = require(\"./lib/observable\");\n\nA = function(attr) {\n  return function(x) {\n    return x[attr];\n  };\n};\n\nF = function(methodName) {\n  return function(x) {\n    return x[methodName]();\n  };\n};\n\nget = function(x, context) {\n  if (typeof x === 'function') {\n    return x.call(context);\n  } else {\n    return x;\n  }\n};\n\no = function(object, name) {\n  var attribute;\n  attribute = Observable(object[name]);\n  attribute.observe(function(newValue) {\n    return object[name] = newValue;\n  });\n  return attribute;\n};\n\nhandle = function(fn) {\n  return function(e) {\n    if (e != null ? e.defaultPrevented : void 0) {\n      return;\n    }\n    if (e != null) {\n      e.preventDefault();\n    }\n    return fn.call(this, e);\n  };\n};\n\nS = function(object, method, defaultValue) {\n  return function() {\n    if (typeof (object != null ? object[method] : void 0) === 'function') {\n      return object[method]();\n    } else {\n      return defaultValue;\n    }\n  };\n};\n\nasElement = A('element');\n\naccelerateItem = function(items, key) {\n  var acceleratedItem;\n  acceleratedItem = items.filter(function(item) {\n    return item.accelerator === key;\n  })[0];\n  if (acceleratedItem) {\n    return acceleratedItem.click();\n  }\n};\n\nisDescendant = function(element, ancestor) {\n  var parent;\n  if (!element) {\n    return;\n  }\n  while ((parent = element.parentElement)) {\n    if (element === ancestor) {\n      return true;\n    }\n    element = parent;\n  }\n};\n\nadvance = function(list, amount) {\n  var activeItemIndex, currentItem;\n  currentItem = list.filter(function(item) {\n    return item.active();\n  })[0];\n  activeItemIndex = list.indexOf(currentItem) + amount;\n  if (activeItemIndex < 0) {\n    activeItemIndex = list.length - 1;\n  } else if (activeItemIndex >= list.length) {\n    activeItemIndex = 0;\n  }\n  return list[activeItemIndex];\n};\n\nformDataToObject = function(formData) {\n  return Array.from(formData.entries()).reduce(function(object, _arg) {\n    var key, value;\n    key = _arg[0], value = _arg[1];\n    object[key] = value;\n    return object;\n  }, {});\n};\n\nelementView = function(element) {\n  if (!element) {\n    return;\n  }\n  if (element.view) {\n    return element.view;\n  }\n  return elementView(element.parentElement);\n};\n\nempty = function(node) {\n  while (node.hasChildNodes()) {\n    node.removeChild(node.lastChild);\n  }\n  return node;\n};\n\nmodule.exports = Util = {\n  htmlEscape: function(string) {\n    return String(string).replace(/[&<>\"'\\/]/g, function(s) {\n      return entityMap[s];\n    });\n  },\n  A: A,\n  F: F,\n  S: S,\n  o: o,\n  advance: advance,\n  asElement: asElement,\n  accelerateItem: accelerateItem,\n  elementView: elementView,\n  empty: empty,\n  formDataToObject: formDataToObject,\n  get: get,\n  handle: handle,\n  isDescendant: isDescendant\n};\n\nentityMap = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  \"/\": '&#x2F;'\n};\n"},"views/ace-editor":{"content":"\n/*\nAn element containing an ace editor.\n\nDepends on ace and language tools extension being available in the environment.\n */\nvar AceEditor, defaultSessionOptions, defaultTheme, deprecationWarning, extensionFor, initSession, loadScripts, modes, removeCommands, searchStyleCSS, _ref;\n\nextensionFor = require(\"/lib/fs/index\").extensionFor;\n\n_ref = require(\"/lib/util/index\"), deprecationWarning = _ref.deprecationWarning, loadScripts = _ref.loadScripts;\n\ndefaultSessionOptions = {\n  readOnly: false,\n  focus: true\n};\n\nremoveCommands = \"jumptomatching\\nmodeSelect\\nmodifyNumberDown\\nmodifyNumberUp\\nmovelinesdown\\nmovelinesup\".split(/\\r?\\n/);\n\ntry {\n  defaultTheme = localStorage.getItem(\"ace/theme\");\n} catch (_error) {\n  defaultTheme = \"dracula\";\n}\n\nmodule.exports = AceEditor = function() {\n  var editor, element, self, _ref1;\n  ace.require(\"ace/ext/language_tools\");\n  if ((_ref1 = document.querySelector(\"style#ace_searchbox\")) != null) {\n    _ref1.remove();\n  }\n  ace.require(\"ace/lib/dom\").importCssString(searchStyleCSS, \"ace_searchbox\");\n  element = document.createElement(\"section\");\n  editor = ace.edit(element);\n  editor.$blockScrolling = Infinity;\n  editor.setOptions({\n    fontFamily: \"'Fira Code', 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace\",\n    fontSize: \"16px\",\n    enableBasicAutocompletion: true,\n    enableLiveAutocompletion: true,\n    highlightActiveLine: true,\n    newLineMode: \"unix\",\n    theme: \"ace/theme/\" + defaultTheme\n  });\n  removeCommands.forEach(function(command) {\n    return editor.commands.removeCommand(command);\n  });\n  self = {\n    aceEditor: editor,\n    editor: editor,\n    element: element,\n    hidden: function(b) {\n      if (b) {\n        return element.classList.add(\"hidden\");\n      } else {\n        return element.classList.remove(\"hidden\");\n      }\n    },\n    goto: function(line, selection) {\n      var end, session, start;\n      if (line == null) {\n        line = 0;\n      }\n      editor.moveCursorTo(line, 0);\n      editor.clearSelection();\n      if (selection) {\n        session = editor.getSession();\n        start = session.doc.indexToPosition(selection.start);\n        end = session.doc.indexToPosition(selection.end);\n        editor.selection.setSelectionRange({\n          start: start,\n          end: end\n        });\n      }\n      editor.scrollToLine(line, true, false, function() {});\n    },\n    setSession: function(session, opts) {\n      var focus, readOnly;\n      if (opts == null) {\n        opts = defaultSessionOptions;\n      }\n      readOnly = opts.readOnly, focus = opts.focus;\n      editor.setSession(session);\n      editor.setReadOnly(readOnly);\n      if (focus) {\n        editor.focus();\n      }\n    },\n    theme: function(name) {\n      editor.setTheme(\"ace/theme/\" + name);\n      try {\n        return localStorage.setItem(\"ace/theme\", name);\n      } catch (_error) {}\n    }\n  };\n  return self;\n};\n\n\n/*\nInitialize a session to track an observable\n */\n\ninitSession = function(initialContent, contentObservable, mode) {\n  var session, updating;\n  if (mode == null) {\n    mode = \"coffee\";\n  }\n  if (!contentObservable) {\n    return;\n  }\n  session = ace.createEditSession(initialContent);\n  session.on(\"changeMode\", function() {\n    if (session.$mode.$id === \"ace/mode/css\") {\n      return session.$worker.call('setDisabledRules', [\"ids|order-alphabetical|universal-selector|regex-selectors\"]);\n    }\n  });\n  session.setUseWorker(false);\n  session.setMode(\"ace/mode/\" + mode);\n  session.setUseSoftTabs(true);\n  session.setTabSize(2);\n  updating = 0;\n  contentObservable.observe(function(newContent) {\n    if (updating) {\n      return;\n    }\n    updating++;\n    session.setValue(newContent);\n    return updating--;\n  });\n  session.on(\"change\", function() {\n    if (updating) {\n      return;\n    }\n    updating++;\n    contentObservable(session.getValue());\n    return updating--;\n  });\n  return session;\n};\n\nmodes = {\n  cson: \"coffee\",\n  jadelet: \"jade\",\n  js: \"javascript\",\n  md: \"markdown\",\n  styl: \"stylus\",\n  txt: \"text\"\n};\n\nObject.assign(AceEditor, {\n  initAceSession: deprecationWarning(\"initAceSession -> initSession\", initSession),\n  initSession: initSession,\n  modeFor: function(path) {\n    var extension;\n    extension = extensionFor(path);\n    return modes[extension] || extension;\n  },\n  preload: function() {\n    return loadScripts([\"https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.7/ace.js\"]);\n  }\n});\n\nsearchStyleCSS = \".ace_search {\\n  background-color: var(--background-neutral);\\n  color: var(--text-color);\\n  border: 1px solid var(--neutral-dark);\\n  border-top: 0;\\n  margin: 0;\\n  padding: 0.5em;\\n  position: absolute;\\n  top: 0;\\n  z-index: 99;\\n}\\n.ace_search.right {\\n  border-radius: 0px 0px 0px var(--border-radius);\\n  border-right: 0;\\n  right: -5px;\\n}\\n.ace_search.left {\\n  border-left: 0 none;\\n  border-radius: 0 0 var(--border-radius) 0;\\n  left: -5px;\\n}\\n.ace_search > * {\\n  margin-bottom: 0.5em;\\n}\\n.ace_search > *:last-child {\\n  margin-bottom: 0;\\n}\\n.ace_searchbtn_close {\\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAcCAYAAABRVo5BAAAAZ0lEQVR42u2SUQrAMAhDvazn8OjZBilCkYVVxiis8H4CT0VrAJb4WHT3C5xU2a2IQZXJjiQIRMdkEoJ5Q2yMqpfDIo+XY4k6h+YXOyKqTIj5REaxloNAd0xiKmAtsTHqW8sR2W5f7gCu5nWFUpVjZwAAAABJRU5ErkJggg==) no-repeat 50% 0;\\n  border-radius: var(--border-radius);\\n  border: 0;\\n  cursor: pointer;\\n  padding: 0;\\n  height: 14px;\\n  width: 14px;\\n  top: 9px;\\n  right: 0.75em;\\n  position: absolute;\\n}\\n.ace_searchbtn_close:hover {\\n  background-color: #656565;\\n  background-position: 50% 100%;\\n}\\n.ace_search_form,\\n.ace_replace_form {\\n  display: flex;\\n  justify-content: start;\\n  margin-right: 1.75em;\\n}\\n.ace_replace_form {\\n  margin-right: 0;\\n}\\n.ace_search_field {\\n  z-index: 1;\\n}\\n.ace_search_form.ace_nomatch > .ace_search_field {\\n  border-color: var(--error-color);\\n  outline: 2px solid var(--error-color);\\n}\\n.ace_searchbtn,\\n.ace_button {\\n  background-color: var(--background-color);\\n  border: 1px solid var(--neutral-darker);\\n  border-radius: var(--border-radius);\\n  box-shadow: var(--shadow-low) var(--neutral-dark);\\n  cursor: pointer;\\n  display: inline-block;\\n  padding: 0.125em 0.375em;\\n}\\n.ace_searchbtn:hover,\\n.ace_button:hover {\\n  background-color: var(--neutral-faintest);\\n}\\n.ace_searchbtn:active,\\n.ace_button:active,\\n.ace_searchbtn.active,\\n.ace_button.active,\\n.ace_searchbtn.checked,\\n.ace_button.checked {\\n  background-color: var(--neutral-faintest);\\n  box-shadow: var(--shadow-low) var(--neutral-dark) inset;\\n}\\n.ace_searchbtn:last-child {\\n  border-radius: 0 var(--border-radius) var(--border-radius) 0;\\n}\\n.ace_searchbtn.prev,\\n.ace_searchbtn.next {\\n  display: flex;\\n  align-items: center;\\n}\\n.ace_searchbtn.prev:after,\\n.ace_searchbtn.next:after {\\n  content: \\\"\\\";\\n  border: solid 0 var(--text-color);\\n  width: 0.5em;\\n  height: 0.5em;\\n  border-width: 1px 0 0 1px;\\n  display: inline-block;\\n  transform: rotate(-45deg);\\n}\\n.ace_searchbtn.next:after {\\n  border-width: 0 1px 1px 0;\\n}\\n.ace_search_options {\\n  display: flex;\\n  align-items: center;\\n}\\nuser-select: none {\\n  clear: both;\\n}\\n.ace_search_counter {\\n  padding: 0 0.5em;\\n  margin-right: auto;\\n}\";\n"},"views/context-menu":{"content":"\n/*\nContextMenu\n\nDisplay a context menu!\n\nQuestions:\n\nShould we be able to update the options in the menu after creation?\n */\nvar MenuView, Observable, isDescendant;\n\nObservable = require(\"../lib/observable\");\n\nMenuView = require(\"./menu\");\n\nisDescendant = require(\"../util\").isDescendant;\n\nmodule.exports = function(_arg) {\n  var activeItem, classes, contextRoot, documentHandler, element, handlers, items, left, self, top;\n  items = _arg.items, classes = _arg.classes, handlers = _arg.handlers;\n  activeItem = Observable(null);\n  if (classes == null) {\n    classes = [];\n  }\n  top = Observable(\"\");\n  left = Observable(\"\");\n  contextRoot = {\n    activeItem: activeItem,\n    handlers: handlers,\n    finish: function() {\n      element.remove();\n      return document.removeEventListener(\"mousedown\", documentHandler);\n    }\n  };\n  self = MenuView({\n    items: items,\n    contextRoot: contextRoot,\n    classes: function() {\n      return [\"context\", \"options\"].concat(classes);\n    },\n    style: function() {\n      return \"top: \" + (top()) + \"px; left: \" + (left()) + \"px\";\n    }\n  });\n  element = self.element;\n  element.view = self;\n  documentHandler = function(e) {\n    if (!isDescendant(e.target, element)) {\n      activeItem(null);\n      return contextRoot.finish();\n    }\n  };\n  self.contextRoot = contextRoot;\n  self.display = function(_arg1) {\n    var inElement, x, y;\n    inElement = _arg1.inElement, x = _arg1.x, y = _arg1.y;\n    document.addEventListener(\"mousedown\", documentHandler);\n    top(y);\n    left(x);\n    (inElement || document.body).appendChild(element);\n    activeItem(self);\n    return element.focus();\n  };\n  element.setAttribute(\"tabindex\", \"-1\");\n  element.addEventListener(\"keydown\", function(e) {\n    var currentItem, direction, key;\n    key = e.key;\n    switch (key) {\n      case \"ArrowLeft\":\n      case \"ArrowUp\":\n      case \"ArrowRight\":\n      case \"ArrowDown\":\n        e.preventDefault();\n        direction = key.replace(\"Arrow\", \"\");\n        currentItem = activeItem();\n        if (currentItem) {\n          return currentItem.cursor(direction);\n        }\n        break;\n      case \"Escape\":\n        return activeItem(null);\n    }\n  });\n  return self;\n};\n"},"views/login":{"content":"var Account, Cognito, Modal, Observable, cognito, compileTemplate;\n\nAccount = require(\"/lib/acct/account\");\n\nCognito = require(\"/lib/aws/cognito\");\n\ncognito = Cognito(PACKAGE.config.cognito);\n\ncompileTemplate = require(\"/lib/jadelet\").exec;\n\nObservable = require(\"/lib/observable\");\n\nModal = require(\"/modal\");\n\nmodule.exports = function(options) {\n  var description, element, formTemplate, headless, model, receivedCredentials, reject, resolve, stateTemplates, title;\n  if (options == null) {\n    options = {};\n  }\n  description = options.description, headless = options.headless, resolve = options.resolve, reject = options.reject, title = options.title;\n  if (title == null) {\n    title = \"ðŸ”‘ Log in to Whimsy.Space [DanielX.net]\";\n  }\n  if (description == null) {\n    description = \"Maintain access to your files across different machines. Publish\\neffortlessly to the internet. Participate in the DanielX.net community.\";\n  }\n  model = {\n    loading: Observable(true),\n    state: Observable(\"start\"),\n    content: Observable(),\n    submit: function(e) {\n      e.preventDefault();\n      this.errorMessage(\"\");\n      if (this.state() === \"register\") {\n        this.loading(true);\n        if (this.password() === this.confirmPassword()) {\n          return cognito.signUp(this.email(), this.password()).then((function(_this) {\n            return function() {\n              _this.loading(false);\n              _this.clearForm();\n              _this.errorMessage(\"\");\n              return _this.state(\"confirm\");\n            };\n          })(this))[\"catch\"]((function(_this) {\n            return function(e) {\n              _this.loading(false);\n              return _this.errorMessage(\"Error: \" + e.message);\n            };\n          })(this));\n        } else {\n          this.errorMessage(\"Error: Password does not match password confirmation\");\n          return this.loading(false);\n        }\n      } else {\n        this.loading(true);\n        return cognito.authenticate(this.email(), this.password()).then(receivedCredentials)[\"catch\"]((function(_this) {\n          return function(e) {\n            console.error(e);\n            return _this.errorMessage(\"Error: \" + e.message);\n          };\n        })(this))[\"finally\"]((function(_this) {\n          return function() {\n            return _this.loading(false);\n          };\n        })(this));\n      }\n    },\n    title: title,\n    description: description,\n    email: Observable(\"\"),\n    password: Observable(\"\"),\n    confirmPassword: Observable(\"\"),\n    clearForm: function() {\n      this.email(\"\");\n      this.password(\"\");\n      return this.confirmPassword(\"\");\n    },\n    errorMessage: Observable(\"\"),\n    goBack: function(e) {\n      e.preventDefault();\n      this.errorMessage(\"\");\n      return this.state(\"start\");\n    },\n    goToRegister: function(e) {\n      e.preventDefault();\n      return this.state(\"register\");\n    },\n    goToLogin: function(e) {\n      e.preventDefault();\n      return this.state(\"login\");\n    },\n    logout: function(e) {\n      e.preventDefault();\n      this.id(null);\n      this.state(\"start\");\n      return cognito.logout();\n    }\n  };\n  stateTemplates = {\n    register: compileTemplate(\"section\\n  p.error @errorMessage\\n  label\\n    h2 Email\\n    input(name=\\\"email\\\" value=@email)\\n  label\\n    h2 Password\\n    input(type=\\\"password\\\" name=\\\"password\\\" value=@password)\\n  label\\n    h2 Confirm Password\\n    input(type=\\\"password\\\" name=\\\"confirm\\\" value=@confirmPassword)\\n\\n  button.full Register\\n  button.top-left(click=@goBack) Back\"),\n    loading: compileTemplate(\"progress\"),\n    start: compileTemplate(\"section\\n  p.error @errorMessage\\n  p @description\\n  button.full(click=@goToLogin) Login\\n  button.full(click=@goToRegister) Register\"),\n    confirm: compileTemplate(\"section\\n  p.error @errorMessage\\n  p A confirmation email has been sent to your address, please follow the confirmation link!\\n  button.full(click=@goToLogin) Next\"),\n    login: compileTemplate(\"section\\n  p.error @errorMessage\\n  label\\n    h2 Email or Username\\n    input(name=\\\"email\\\" value=@email)\\n  label\\n    h2 Password\\n    input(type=\\\"password\\\" name=\\\"password\\\" value=@password)\\n\\n  button.full Sign In\\n  a(href=\\\"https://auth.danielx.net/forgotPassword?client_id=3fd84r6idec9iork4e9l43mp61&response_type=token&scope=aws.cognito.signin.user.admin+email+openid+phone+profile&redirect_uri=https://whimsy.space/\\\" target=\\\"_blank\\\") Forgot Password?\\n  button.top-left(click=@goBack) Back\")\n  };\n  formTemplate = compileTemplate(\"section.ws-login\\n  form(@submit)\\n    h1 @title\\n    @content\");\n  Observable(function() {\n    var loading, state;\n    state = model.state();\n    loading = model.loading();\n    if (loading) {\n      return model.content(stateTemplates.loading(model));\n    } else {\n      return model.content(stateTemplates[state](model));\n    }\n  });\n  receivedCredentials = function(AWS) {\n    model.clearForm();\n    resolve(Account(AWS));\n    if (!headless) {\n      return Modal.hide();\n    }\n  };\n  cognito.cachedUser().then(receivedCredentials)[\"catch\"](function(e) {\n    model.loading(false);\n    return console.debug(e);\n  });\n  if (!headless) {\n    element = formTemplate(model);\n    return Modal.show(element, reject);\n  }\n};\n"},"views/menu-bar":{"content":"var MenuView, Observable, advance, isDescendant, _ref;\n\nObservable = require(\"../lib/observable\");\n\nMenuView = require(\"./menu\");\n\n_ref = require(\"../util\"), isDescendant = _ref.isDescendant, advance = _ref.advance;\n\nmodule.exports = function(_arg) {\n  var accelerateIfActive, acceleratorActive, activeItem, contextRoot, deactivate, element, handlers, items, previouslyFocusedElement, self;\n  items = _arg.items, handlers = _arg.handlers;\n  acceleratorActive = Observable(false);\n  activeItem = Observable(null);\n  previouslyFocusedElement = null;\n  contextRoot = {\n    activeItem: activeItem,\n    handlers: handlers\n  };\n  self = MenuView({\n    classes: function() {\n      return [\"bar\", acceleratorActive() ? \"accelerator-active\" : void 0];\n    },\n    items: items,\n    contextRoot: contextRoot\n  });\n  element = self.element;\n  self.cursor = function(direction) {\n    switch (direction) {\n      case \"Right\":\n        return self.advance(1);\n      case \"Left\":\n        return self.advance(-1);\n    }\n  };\n  self.items.forEach(function(item) {\n    item.horizontal = true;\n    return item.cursor = function(direction) {\n      var _ref1, _ref2;\n      console.log(\"Item\", direction);\n      if (direction === \"Down\") {\n        return (_ref1 = item.submenu) != null ? _ref1.advance(1) : void 0;\n      } else if (direction === \"Up\") {\n        return (_ref2 = item.submenu) != null ? _ref2.advance(-1) : void 0;\n      } else {\n        return item.parent.cursor(direction);\n      }\n    };\n  });\n  deactivate = function() {\n    activeItem(null);\n    acceleratorActive(false);\n    return previouslyFocusedElement != null ? previouslyFocusedElement.focus() : void 0;\n  };\n  document.addEventListener(\"mousedown\", function(e) {\n    if (!isDescendant(e.target, element)) {\n      acceleratorActive(false);\n      return activeItem(null);\n    }\n  });\n  document.addEventListener(\"keydown\", function(e) {\n    var key, menuIsActive, _ref1;\n    key = e.key;\n    switch (key) {\n      case \"Enter\":\n        return (_ref1 = activeItem()) != null ? _ref1.click() : void 0;\n      case \"Alt\":\n        menuIsActive = false;\n        if (acceleratorActive() || menuIsActive) {\n          return deactivate();\n        } else {\n          previouslyFocusedElement = document.activeElement;\n          element.focus();\n          if (!activeItem()) {\n            activeItem(self);\n          }\n          return acceleratorActive(true);\n        }\n    }\n  });\n  accelerateIfActive = function(key) {\n    var _ref1;\n    if (acceleratorActive()) {\n      return (_ref1 = activeItem()) != null ? _ref1.accelerate(key) : void 0;\n    }\n  };\n  element.setAttribute(\"tabindex\", \"-1\");\n  element.addEventListener(\"keydown\", function(e) {\n    var accelerated, currentItem, direction, key;\n    key = e.key;\n    switch (key) {\n      case \"ArrowLeft\":\n      case \"ArrowUp\":\n      case \"ArrowRight\":\n      case \"ArrowDown\":\n        e.preventDefault();\n        direction = key.replace(\"Arrow\", \"\");\n        currentItem = activeItem();\n        if (currentItem) {\n          return currentItem.cursor(direction);\n        }\n        break;\n      case \"Escape\":\n        return deactivate();\n      default:\n        accelerated = accelerateIfActive(key.toLowerCase());\n        if (accelerated != null) {\n          return e.preventDefault();\n        }\n    }\n  });\n  return self;\n};\n"},"views/menu-item":{"content":"var F, MenuItemTemplate, S, accelerateItem, advance, asElement, formatAction, formatLabel, handle, htmlEscape, isDescendant, _ref;\n\n_ref = require(\"../util\"), advance = _ref.advance, htmlEscape = _ref.htmlEscape, asElement = _ref.asElement, F = _ref.F, S = _ref.S, isDescendant = _ref.isDescendant, accelerateItem = _ref.accelerateItem, handle = _ref.handle;\n\nMenuItemTemplate = require(\"../templates/menu-item\");\n\nmodule.exports = function(_arg) {\n  var MenuView, accelerator, action, actionName, active, activeItem, click, content, contextRoot, disabled, element, handlers, hotkey, items, label, labelText, parent, self, submenu, title, _ref1, _ref2;\n  label = _arg.label, MenuView = _arg.MenuView, items = _arg.items, contextRoot = _arg.contextRoot, parent = _arg.parent;\n  self = {};\n  activeItem = contextRoot.activeItem, handlers = contextRoot.handlers;\n  active = function() {\n    var _ref1;\n    return isDescendant((_ref1 = activeItem()) != null ? _ref1.element : void 0, element);\n  };\n  self.active = active;\n  if (items) {\n    submenu = MenuView({\n      items: items,\n      contextRoot: contextRoot,\n      parent: self\n    });\n    content = submenu.element;\n  }\n  _ref1 = formatAction(label), labelText = _ref1[0], actionName = _ref1[1];\n  _ref2 = formatLabel(labelText), title = _ref2[0], accelerator = _ref2[1];\n  action = handlers[actionName];\n  disabled = S(action, \"disabled\", false);\n  hotkey = S(action, \"hotkey\", \"\");\n  click = function(e) {\n    if (disabled()) {\n      return;\n    }\n    if (e != null ? e.defaultPrevented : void 0) {\n      return;\n    }\n    if (e != null) {\n      e.preventDefault();\n    }\n    if (submenu) {\n      activeItem(submenu);\n      return;\n    }\n    if (action != null) {\n      if (typeof action.call === \"function\") {\n        action.call(handlers);\n      }\n    }\n    activeItem(null);\n    return typeof contextRoot.finish === \"function\" ? contextRoot.finish() : void 0;\n  };\n  element = MenuItemTemplate({\n    \"class\": function() {\n      return [items ? \"menu\" : void 0, active() ? \"active\" : void 0];\n    },\n    click: click,\n    mousemove: function(e) {\n      if (!activeItem()) {\n        return;\n      }\n      if (!e.defaultPrevented && isDescendant(e.target, element)) {\n        e.preventDefault();\n        return activeItem(self);\n      }\n    },\n    title: title,\n    content: content,\n    decoration: items ? \"â–¸\" : void 0,\n    hotkey: hotkey,\n    disabled: disabled\n  });\n  Object.assign(self, {\n    accelerator: accelerator,\n    accelerate: function(key) {\n      if (submenu) {\n        return submenu.accelerate(key);\n      } else {\n        return parent.accelerate(key);\n      }\n    },\n    click: click,\n    parent: parent,\n    element: element,\n    submenu: submenu,\n    cursor: function(direction) {\n      console.log(\"Item Cursor\", direction);\n      if (submenu && direction === \"Right\") {\n        return activeItem(submenu.navigableItems[0]);\n      } else if (parent.parent && direction === \"Left\") {\n        if (parent.parent.horizontal) {\n          return parent.parent.cursor(direction);\n        } else {\n          return activeItem(parent.parent);\n        }\n      } else {\n        return parent.cursor(direction);\n      }\n    }\n  });\n  return self;\n};\n\nformatAction = function(labelText) {\n  var action, title, _ref1;\n  _ref1 = labelText.split(\"->\").map(F(\"trim\")), title = _ref1[0], action = _ref1[1];\n  if (!action) {\n    action = title.replace(/[^A-Za-z0-9]/g, \"\");\n    action = action.charAt(0).toLowerCase() + action.substring(1);\n  }\n  return [title, action];\n};\n\nformatLabel = function(labelText) {\n  var accelerator, span, titleHTML;\n  accelerator = void 0;\n  titleHTML = htmlEscape(labelText).replace(/\\[([^\\]]+)\\]/, function(match, $1) {\n    accelerator = $1.toLowerCase();\n    return \"<span class=\\\"accelerator\\\">\" + $1 + \"</span>\";\n  });\n  span = document.createElement(\"span\");\n  span.innerHTML = titleHTML;\n  return [span, accelerator];\n};\n"},"views/menu-separator":{"content":"var MenuSeparatorTemplate;\n\nMenuSeparatorTemplate = require(\"../templates/menu-separator\");\n\nmodule.exports = function() {\n  return {\n    element: MenuSeparatorTemplate(),\n    separator: true\n  };\n};\n"},"views/menu":{"content":"var F, MenuItemTemplate, MenuItemView, MenuTemplate, MenuView, Observable, S, SeparatorView, accelerateItem, advance, asElement, assert, get, handle, htmlEscape, isDescendant, parseMenu, _ref;\n\nObservable = require(\"../lib/observable\");\n\nassert = require(\"../lib/assert\");\n\n_ref = require(\"../util\"), advance = _ref.advance, accelerateItem = _ref.accelerateItem, asElement = _ref.asElement, get = _ref.get, F = _ref.F, S = _ref.S, htmlEscape = _ref.htmlEscape, handle = _ref.handle, isDescendant = _ref.isDescendant;\n\nMenuTemplate = require(\"../templates/menu\");\n\nMenuItemTemplate = require(\"../templates/menu-item\");\n\nSeparatorView = require(\"./menu-separator\");\n\nMenuItemView = require(\"./menu-item\");\n\nparseMenu = require(\"../lib/indent-parse\");\n\nmodule.exports = MenuView = function(_arg) {\n  var active, activeItem, classes, contextRoot, getItems, items, navigableItems, parent, self, style;\n  items = _arg.items, classes = _arg.classes, style = _arg.style, contextRoot = _arg.contextRoot, parent = _arg.parent;\n  self = {};\n  if (contextRoot == null) {\n    contextRoot = {\n      activeItem: Observable(),\n      handlers: {}\n    };\n  }\n  if (classes == null) {\n    classes = function() {\n      return [\"options\"];\n    };\n  }\n  activeItem = contextRoot.activeItem;\n  if (typeof items === \"string\") {\n    items = parseMenu(items);\n  }\n  getItems = Observable(function() {\n    return items.map(function(item) {\n      var label, submenuItems;\n      switch (false) {\n        case !(typeof item === \"string\" && item.match(/^[=-]+$/)):\n          return SeparatorView();\n        case !Array.isArray(item):\n          assert(item.length === 2);\n          label = item[0], submenuItems = item[1];\n          return MenuItemView({\n            label: label,\n            items: submenuItems,\n            MenuView: MenuView,\n            contextRoot: contextRoot,\n            parent: self\n          });\n        default:\n          return MenuItemView({\n            label: item,\n            contextRoot: contextRoot,\n            parent: self\n          });\n      }\n    });\n  });\n  navigableItems = Observable(function() {\n    return getItems().filter(function(item) {\n      return !item.separator;\n    });\n  });\n  active = function() {\n    var _ref1;\n    return isDescendant((_ref1 = activeItem()) != null ? _ref1.element : void 0, self.element);\n  };\n  Object.assign(self, {\n    accelerate: function(key) {\n      return accelerateItem(getItems(), key);\n    },\n    cursor: function(direction) {\n      var _ref1;\n      switch (direction) {\n        case \"Up\":\n          return self.advance(-1);\n        case \"Down\":\n          return self.advance(1);\n        default:\n          return (_ref1 = parent.parent) != null ? _ref1.cursor(direction) : void 0;\n      }\n    },\n    parent: parent,\n    items: getItems,\n    advance: function(n) {\n      return activeItem(advance(navigableItems(), n));\n    },\n    navigableItems: navigableItems,\n    element: MenuTemplate({\n      style: style,\n      \"class\": function() {\n        return [active() ? \"active\" : void 0].concat(classes());\n      },\n      click: handle(function(e) {\n        return activeItem(self);\n      }),\n      items: function() {\n        return getItems().map(asElement);\n      }\n    })\n  });\n  return self;\n};\n"},"views/progress":{"content":"var Observable, Template;\n\nTemplate = require(\"../templates/progress\");\n\nObservable = require(\"../lib/observable\");\n\n\"\";\n\nmodule.exports = function(params) {\n  var element, max, message, value;\n  if (params == null) {\n    params = {};\n  }\n  value = params.value, max = params.max, message = params.message;\n  value = Observable(value || 0);\n  max = Observable(max);\n  message = Observable(message);\n  element = Template({\n    value: value,\n    max: max,\n    message: message\n  });\n  return {\n    element: element,\n    value: value,\n    message: message,\n    max: max\n  };\n};\n"},"views/table":{"content":"var TableTemplate, TableView, advanceRow, empty;\n\nempty = require(\"../util\").empty;\n\nTableTemplate = require(\"../templates/table\");\n\nadvanceRow = function(path, prev) {\n  var cellIndex, input, nextRowElement, td, tr;\n  td = path.filter(function(element) {\n    return element.tagName === \"TD\";\n  })[0];\n  if (!td) {\n    return;\n  }\n  tr = td.parentElement;\n  cellIndex = Array.prototype.indexOf.call(tr.children, td);\n  if (prev) {\n    nextRowElement = tr.previousSibling;\n  } else {\n    nextRowElement = tr.nextSibling;\n  }\n  if (nextRowElement) {\n    input = nextRowElement.children[cellIndex].querySelector('input');\n    return input != null ? input.focus() : void 0;\n  }\n};\n\nTableView = function(_arg) {\n  var RowElement, containerElement, data, filterAndSort, filterFn, headers, rowElements, tableBody, update;\n  data = _arg.data, headers = _arg.headers, RowElement = _arg.RowElement;\n  if (headers == null) {\n    headers = Object.keys(data[0]);\n  }\n  containerElement = TableTemplate({\n    headerElements: headers.map(function(header) {\n      var th;\n      th = document.createElement('th');\n      th.textContent = header;\n      return th;\n    }),\n    keydown: function(event) {\n      var key, path;\n      key = event.key, path = event.path;\n      switch (key) {\n        case \"Enter\":\n        case \"ArrowDown\":\n          event.preventDefault();\n          return advanceRow(path);\n        case \"ArrowUp\":\n          event.preventDefault();\n          return advanceRow(path, true);\n      }\n    }\n  });\n  tableBody = containerElement.querySelector('tbody');\n  filterFn = function(datum) {\n    return true;\n  };\n  filterAndSort = function(data, filterFn, sortFn) {\n    var filteredData;\n    if (filterFn == null) {\n      filterFn = function() {\n        return true;\n      };\n    }\n    filteredData = data.filter(filterFn);\n    if (sortFn) {\n      return filteredData.sort(sortFn);\n    } else {\n      return filteredData;\n    }\n  };\n  rowElements = function() {\n    return filterAndSort(data, filterFn, null).map(RowElement);\n  };\n  update = function() {\n    empty(tableBody);\n    return rowElements().forEach(function(element) {\n      return tableBody.appendChild(element);\n    });\n  };\n  update();\n  return {\n    element: containerElement,\n    render: update\n  };\n};\n\nmodule.exports = TableView;\n"},"views/window":{"content":"var Bindable, Observable, WindowTemplate, activeDrag, activeResize, dragStart, elementView, frameGuard, raiseToTop, resizeInitial, resizeStart, styleBind, topIndex;\n\nWindowTemplate = require(\"../templates/window\");\n\nelementView = require(\"../util\").elementView;\n\nframeGuard = document.createElement(\"frame-guard\");\n\ndocument.body.appendChild(frameGuard);\n\ntopIndex = 0;\n\nraiseToTop = function(view) {\n  var zIndex;\n  if (typeof view.zIndex !== 'function') {\n    return;\n  }\n  zIndex = view.zIndex();\n  if (zIndex === topIndex) {\n    return;\n  }\n  topIndex += 1;\n  return view.zIndex(topIndex);\n};\n\nactiveDrag = null;\n\ndragStart = null;\n\ndocument.addEventListener(\"mousedown\", function(e) {\n  var target, view;\n  target = e.target;\n  view = elementView(target);\n  if (view) {\n    raiseToTop(view);\n    if (typeof view.savePosition === \"function\") {\n      view.savePosition();\n    }\n  }\n  if (target.tagName === \"TITLE-BAR\") {\n    dragStart = e;\n    return activeDrag = view;\n  }\n});\n\ndocument.addEventListener(\"mousemove\", function(e) {\n  var bottomEdge, dx, dy, hotHeight, hotWidth, hotX, hotY, leftEdge, prevX, prevY, rightEdge, topEdge, x, xPos, y, yPos;\n  if (activeDrag) {\n    frameGuard.classList.add(\"active\");\n    prevX = dragStart.clientX, prevY = dragStart.clientY;\n    x = e.clientX, y = e.clientY;\n    dragStart = e;\n    if (activeDrag.maximized()) {\n      activeDrag.restore();\n      activeDrag.x(x - activeDrag.width() / 2);\n      activeDrag.y(y - 30);\n    }\n    dx = x - prevX;\n    dy = y - prevY;\n    activeDrag.x(activeDrag.x() + dx);\n    activeDrag.y(activeDrag.y() + dy);\n    leftEdge = x <= 10;\n    rightEdge = x >= document.documentElement.getBoundingClientRect().width - 10;\n    hotX = leftEdge || rightEdge;\n    topEdge = y <= 10;\n    bottomEdge = y >= document.documentElement.getBoundingClientRect().height - 10;\n    hotY = topEdge || bottomEdge;\n    if (hotX || hotY) {\n      xPos = \"0%\";\n      yPos = \"0%\";\n      hotWidth = \"50%\";\n      hotHeight = \"50%\";\n      if (!hotX) {\n        hotWidth = \"100%\";\n      }\n      if (!hotY) {\n        hotHeight = \"100%\";\n      }\n      if (bottomEdge) {\n        yPos = \"50%\";\n      }\n      if (rightEdge) {\n        xPos = \"50%\";\n      }\n      activeDrag.saveSize();\n      activeDrag.maximized(true);\n      activeDrag.x(xPos);\n      activeDrag.y(yPos);\n      activeDrag.width(hotWidth);\n      return activeDrag.height(hotHeight);\n    }\n  }\n});\n\nactiveResize = null;\n\nresizeStart = null;\n\nresizeInitial = null;\n\ndocument.addEventListener(\"mousedown\", function(e) {\n  var height, target, width, x, y, _ref;\n  target = e.target;\n  if (target.tagName === \"RESIZE\") {\n    frameGuard.classList.add(\"active\");\n    resizeStart = e;\n    activeResize = target;\n    _ref = elementView(activeResize), width = _ref.width, height = _ref.height, x = _ref.x, y = _ref.y;\n    return resizeInitial = {\n      width: width(),\n      height: height(),\n      x: x(),\n      y: y()\n    };\n  }\n});\n\ndocument.addEventListener(\"mousemove\", function(e) {\n  var actualDeltaX, actualDeltaY, dx, dy, height, startX, startY, view, width, x, y;\n  if (activeResize) {\n    startX = resizeStart.clientX, startY = resizeStart.clientY;\n    x = e.clientX, y = e.clientY;\n    dx = x - startX;\n    dy = y - startY;\n    width = resizeInitial.width;\n    height = resizeInitial.height;\n    if (activeResize.classList.contains(\"e\")) {\n      width += dx;\n    }\n    if (activeResize.classList.contains(\"w\")) {\n      width -= dx;\n    }\n    if (activeResize.classList.contains(\"s\")) {\n      height += dy;\n    }\n    if (activeResize.classList.contains(\"n\")) {\n      height -= dy;\n    }\n    width = Math.max(width, 200);\n    height = Math.max(height, 50);\n    actualDeltaX = width - resizeInitial.width;\n    actualDeltaY = height - resizeInitial.height;\n    view = elementView(activeResize);\n    if (activeResize.classList.contains(\"n\")) {\n      view.y(resizeInitial.y - actualDeltaY);\n    }\n    if (activeResize.classList.contains(\"w\")) {\n      view.x(resizeInitial.x - actualDeltaX);\n    }\n    view.width(width);\n    view.height(height);\n    return view.trigger(\"resize\");\n  }\n});\n\ndocument.addEventListener(\"mouseup\", function() {\n  activeDrag = null;\n  activeResize = null;\n  return frameGuard.classList.remove(\"active\");\n});\n\nBindable = require(\"../lib/bindable\");\n\nObservable = require(\"../lib/observable\");\n\nmodule.exports = function(params) {\n  var element, height, iconEmoji, iconStyle, iconURL, maximized, minimized, prevHeight, prevWidth, prevX, prevY, restore, self, title, width, x, y, zIndex, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;\n  self = Bindable();\n  x = Observable((_ref = params.x) != null ? _ref : 50);\n  y = Observable((_ref1 = params.y) != null ? _ref1 : 50);\n  width = Observable((_ref2 = params.width) != null ? _ref2 : 400);\n  height = Observable((_ref3 = params.height) != null ? _ref3 : 300);\n  title = Observable((_ref4 = params.title) != null ? _ref4 : \"Untitled\");\n  minimized = Observable(false);\n  maximized = Observable(false);\n  prevWidth = Observable(null);\n  prevHeight = Observable(null);\n  prevX = Observable(null);\n  prevY = Observable(null);\n  iconURL = Observable(params.iconURL || \"data:image/x-icon;base64,AAABAAIAICAQAAEABADoAgAAJgAAABAQEAABAAQAKAEAAA4DAAAoAAAAIAAAAEAAAAABAAQAAAAAAIACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvwAAvwAAAL+/AL8AAAC/AL8Av78AAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAAAAAAAAAAAAAACHd3d3d3d3d3d3d3dwAAAAj///////////////cAAAAI///////////////3AAAACP///////3d///d39wAAAAj/zMzM//mZ//+Zn/cAAAAI////////l///+X/3AAAACP/MzMzM//l3d3l/9wAAAAj/////////mZmZf/cAAAAI/8zMzMzM//l/+X/3AAAACP//////////l/l/9wAAAAj/zMzMzMzM//l5f/cAAAAI////////////mX/3AAAACP/MzMzMzMzM//n/9wAAAAj///////////////cAAAAI/8zMzMzMzMzMzP/3AAAACP//////////////9wAAAAj/zMzMzMzMzMzM//cAAAAI///////////////3AAAACP8AAAAA/8zMzMz/9wAAAAj/iZD/8P////////cAAAAI/4AAAAD/zMzMzP/3AAAACP+P8Luw////////9wAAAAj/gAC7sP/MzMzM//cAAAAI/4/wu7D////////3AAAACP+P8Luw/////4AAAAAAAAj/j/AAAP////+P94AAAAAI/4/wzMD/////j3gAAAAACP+IiIiA/////4eAAAAAAAj///////////+IAAAAAAAI////////////gAAAAAAACIiIiIiIiIiIiIAAAAAA4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAH4AAAB+AAAAfgAAAP4AAAH+AAAD/gAAB/4AAA/+AAAf8oAAAAEAAAACAAAAABAAQAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvwAAvwAAAL+/AL8AAAC/AL8Av78AAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAACHd3d3d3cAAI//////9wAAj8z5//n3AACP//+ZmfcAAI/MzPn59wAAj////5n3AACPzMzM+fcAAI//////9wAAjwAPzMz3AACPmY////cAAI/Pj8zM9wAAj8+P//AAAACPiI//9/gAAI/////3gAAAiIiIiIgAAAgAMAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIADAACAAwAAgAMAAIAHAACADwAAgB8AAA==\");\n  iconEmoji = Observable(params.iconEmoji || null);\n  iconStyle = Observable(function() {\n    if (iconEmoji()) {\n      return \"width: 18px;\";\n    } else {\n      return \"background-image: url(\" + (iconURL()) + \");\\nwidth: 18px;\";\n    }\n  });\n  topIndex += 1;\n  zIndex = Observable((_ref5 = params.zIndex) != null ? _ref5 : topIndex);\n  element = WindowTemplate({\n    iconStyle: iconStyle,\n    iconEmoji: iconEmoji,\n    title: title,\n    menuBar: params.menuBar,\n    content: params.content,\n    \"class\": function() {\n      return [minimized() ? \"minimized\" : void 0, maximized() ? \"maximized\" : void 0];\n    },\n    close: function() {\n      return self.close();\n    },\n    minimize: function() {\n      return self.minimize();\n    },\n    maximize: function() {\n      return self.maximize();\n    },\n    restore: function() {\n      return self.restore();\n    }\n  });\n  styleBind(y, element, \"top\", \"px\");\n  styleBind(x, element, \"left\", \"px\");\n  styleBind(height, element, \"height\", \"px\");\n  styleBind(width, element, \"width\", \"px\");\n  styleBind(zIndex, element, \"zIndex\");\n  restore = function() {\n    if (prevX() != null) {\n      x(prevX());\n    }\n    if (prevY() != null) {\n      y(prevY());\n    }\n    width(prevWidth());\n    height(prevHeight());\n    minimized(false);\n    maximized(false);\n    return self.trigger(\"resize\");\n  };\n  Object.assign(self, {\n    element: element,\n    iconEmoji: iconEmoji,\n    iconURL: iconURL,\n    title: title,\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    zIndex: zIndex,\n    close: function() {\n      element.remove();\n      return self.trigger(\"close\");\n    },\n    savePosition: function() {\n      if (typeof x() === 'number') {\n        prevX(x());\n      }\n      if (typeof y() === 'number') {\n        return prevY(y());\n      }\n    },\n    saveSize: function() {\n      prevWidth(width());\n      return prevHeight(height());\n    },\n    maximized: maximized,\n    maximize: function() {\n      maximized.toggle();\n      if (maximized()) {\n        self.savePosition();\n        self.saveSize();\n        width(null);\n        height(null);\n        x(0);\n        y(0);\n        self.trigger(\"resize\");\n        return self.trigger(\"maximize\");\n      } else {\n        return restore();\n      }\n    },\n    minimized: minimized,\n    minimize: function() {\n      minimized.toggle();\n      if (minimized()) {\n        self.savePosition();\n        self.saveSize();\n        width(null);\n        height(null);\n        self.trigger(\"resize\");\n        return self.trigger(\"minimize\");\n      } else {\n        return restore();\n      }\n    },\n    restore: function() {\n      return restore();\n    },\n    raiseToTop: function() {\n      return raiseToTop(self);\n    }\n  });\n  element.view = self;\n  return self;\n};\n\nstyleBind = function(observable, element, attr, suffix) {\n  var update;\n  if (suffix == null) {\n    suffix = \"\";\n  }\n  update = function(newValue) {\n    if (typeof newValue === \"string\") {\n      return element.style[attr] = newValue;\n    } else if ((newValue != null) && ((newValue = parseInt(newValue)) != null)) {\n      return element.style[attr] = \"\" + newValue + suffix;\n    } else {\n      return element.style[attr] = null;\n    }\n  };\n  observable.observe(update);\n  return update(observable());\n};\n"},"workspaces/size":{"content":"var fmt, items, pre, total;\n\nfmt = function(size) {\n  return size.toString().padStart(10);\n};\n\ntotal = 0;\n\nitems = Object.keys(PACKAGE.source).map(function(name) {\n  return [name, PACKAGE.source[name].content.length];\n}).sort(function(a, b) {\n  return b[1] - a[1];\n}).map(function(_arg) {\n  var name, size;\n  name = _arg[0], size = _arg[1];\n  total += size;\n  return fmt(size) + \" \" + name;\n}).join(\"\\n\");\n\npre = document.createElement(\"pre\");\n\npre.textContent = \"\" + items + \"\\n------------------------------\\n\" + (fmt(total)) + \" Source Total\\n\\n\" + (fmt(JSON.stringify(PACKAGE).length)) + \" Package Total\";\n\npre.style.overflow = \"auto\";\n\ndocument.body.appendChild(pre);\n"},"views/fuzzy-list":{"content":"var Jadelet, LoadingTemplate, Observable, RowTemplate, Template, fuzzyMatch, keepsKeyboard;\n\nJadelet = require(\"../lib/jadelet\");\n\nObservable = require(\"../lib/observable\");\n\nfuzzyMatch = require(\"../lib/util/index\").fuzzyMatch;\n\nTemplate = Jadelet.exec(\"form.fuzzy-list(@submit @keydown)\\n  input(@placeholder @value)\\n  ul(tabindex=0)\\n    @children\");\n\nRowTemplate = Jadelet.exec(\"li(@click @class @dblclick data-index=@index)\\n  @content\");\n\nLoadingTemplate = Jadelet.exec(\"li Loading...\");\n\nkeepsKeyboard = function(element) {\n  return element.tagName === 'INPUT' || element.tagName === 'SELECT' || element.tagName === 'TEXTAREA' || (element.contentEditable && element.contentEditable === 'true');\n};\n\nmodule.exports = function(model) {\n  var ItemTemplate, activeIndex, clickHandler, dblclickHandler, filter, items, loading, maxItems, submit, value, view;\n  filter = model.filter, ItemTemplate = model.ItemTemplate, items = model.items, loading = model.loading, maxItems = model.maxItems, submit = model.submit, value = model.value;\n  if (ItemTemplate == null) {\n    ItemTemplate = function(x) {\n      return x;\n    };\n  }\n  if (loading == null) {\n    loading = Observable(false);\n  }\n  if (value == null) {\n    value = Observable(\"\");\n  }\n  if (maxItems == null) {\n    maxItems = Observable(100);\n  }\n  if (filter == null) {\n    filter = function(value, items) {\n      return fuzzyMatch(value, items);\n    };\n  }\n  activeIndex = Observable(0);\n  clickHandler = function(e) {\n    var index;\n    index = parseInt(e.currentTarget.dataset.index, 10);\n    return activeIndex(index);\n  };\n  dblclickHandler = function(e) {\n    var index;\n    index = parseInt(e.currentTarget.dataset.index, 10);\n    return submit(view.filteredItems()[index]);\n  };\n  view = {\n    activeIndex: activeIndex,\n    activeItem: function() {\n      return view.filteredItems()[activeIndex()];\n    },\n    loading: loading,\n    element: null,\n    children: function() {\n      if (loading()) {\n        return LoadingTemplate();\n      }\n      return view.filteredItems().slice(0, maxItems()).map(function(item, index) {\n        return RowTemplate({\n          \"class\": function() {\n            if (index === activeIndex()) {\n              return \"active\";\n            }\n          },\n          click: clickHandler,\n          dblclick: dblclickHandler,\n          content: ItemTemplate(item),\n          index: index\n        });\n      });\n    },\n    filteredItems: function() {\n      return filter(value(), items());\n    },\n    keydown: function(e) {\n      if (e.key === \"Enter\") {\n        view.submit(e);\n        return;\n      }\n      switch (e.key) {\n        case \"ArrowUp\":\n          view.previousItem();\n          return e.preventDefault();\n        case \"ArrowDown\":\n          view.nextItem();\n          return e.preventDefault();\n      }\n    },\n    placeholder: \"Type to filter results\",\n    nextItem: function() {\n      var n;\n      n = activeIndex() + 1;\n      if (n >= view.filteredItems().length) {\n        n = 0;\n      }\n      return activeIndex(n);\n    },\n    previousItem: function() {\n      var n;\n      n = activeIndex() - 1;\n      if (n < 0) {\n        n = view.filteredItems().length - 1;\n      }\n      return activeIndex(n);\n    },\n    submit: function(e) {\n      e.preventDefault();\n      return submit(view.activeItem());\n    },\n    value: value\n  };\n  activeIndex.observe(function(i) {\n    var el;\n    el = view.element.querySelectorAll(':scope > ul > li')[i];\n    return el != null ? el.scrollIntoView({\n      block: \"nearest\"\n    }) : void 0;\n  });\n  view.element = Template(view);\n  return view;\n};\n"},"lib/pkg/mod-loader":{"content":"var modLoad;\n\nmodLoad = function(path, source, namespace) {\n  var compile, crudeRequire, withoutAllExtensions, _ref;\n  if (namespace == null) {\n    namespace = system;\n  }\n  _ref = system.pkg, compile = _ref.compile, crudeRequire = _ref.crudeRequire;\n  withoutAllExtensions = system.fs.withoutAllExtensions;\n  return compile(path, source).then(function(program) {\n    var exportedModule, l, paths;\n    exportedModule = crudeRequire(program);\n    paths = path.split(\"/\");\n    l = paths.length;\n    return paths.reduce(function(namespace, name, i) {\n      if (i === l - 1) {\n        name = withoutAllExtensions(name);\n        if (typeof exportedModule === \"object\") {\n          return Object.assign(namespace, exportedModule);\n        } else {\n          name = name.replace(/^([a-z])|[_-]([a-z])/g, function(m, a, b) {\n            return (a || b).toUpperCase();\n          });\n          return namespace[name] = exportedModule;\n        }\n      }\n      return namespace[name] || (namespace[name] = {});\n    }, namespace);\n  });\n};\n\nmodule.exports = function(fs, basePath, namespace) {\n  return function(path) {\n    return fs.read(basePath + path).then(function(b) {\n      return b.text();\n    }).then(function(source) {\n      return modLoad(path, source, namespace);\n    });\n  };\n};\n"}},"progenitor":{"url":"https://danielx.net/editor/"},"config":{"name":"system","version":"0.5.3","publishPath":"/My Briefcase/public/danielx.net/","dependencies":{},"remoteDependencies":["https://danielx.net/cdn/dexie/2.0.4.min.js"],"cognito":{"identityPoolId":"us-east-1:4fe22da5-bb5e-4a78-a260-74ae0a140bf9","poolData":{"UserPoolId":"us-east-1_cfvrlBLXG","ClientId":"3fd84r6idec9iork4e9l43mp61"}}},"version":"0.2.1","repository":{"branch":"master","default_branch":"master","full_name":"STRd6/ui","homepage":null,"description":"Classic User Interface","html_url":"https://github.com/STRd6/ui","url":"https://api.github.com/repos/STRd6/ui","publishBranch":"gh-pages"},"dependencies":{},"remoteDependencies":["https://danielx.net/cdn/dexie/2.0.4.min.js"]}